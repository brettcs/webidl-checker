<schema xmlns="http://purl.oclc.org/dsdl/schematron" >
  <let name="standards" value="document('../web-platform/all.xml')"/>
     <pattern  id="definedTypes">
       <title>IDL is using defined types</title>
          <rule context="//Type[@name]">
               <assert role="warning" test="//Interface[@name=current()/@name] or $standards//Interface[@name=current()/@name] or //Dictionary[@name=current()/@name]  or $standards//Dictionary[@name=current()/@name] or //Typedef[@name=current()/@name] or $standards//Typedef[@name=current()/@name] or //Callback[@name=current()/@name] or $standards//Callback[@name=current()/@name] or //Enum[@name=current()/@name] or $standards//Enum[@name=current()/@name]"><value-of select="@name"/> type used in <value-of select="ancestor::*[local-name()='Interface' or local-name()='Dictionary'][1]/@name" />.<value-of select="ancestor::*[Type and local-name()!='Type'][1]/@name" /> declaration undefined.</assert>
          </rule>
     </pattern>
     <pattern>
       <title>partial interface refer to existing interface</title>
       <rule context="//Interface[@partial]">
	 <assert role="warning" test="//Interface[@name=current()/@name and not(@partial)] or $standards//Interface[@name=current()/@name and not(@partial)]">Partial interface <value-of select="@name" /> does not have matching full interface</assert>
       </rule>
     </pattern>
     <pattern>
       <title>Names of interfaces / exceptions / dictionaries don't clash</title>
       <rule context="//Typedef[@id]|//Exception[@id]|//Dictionary[@id]">
	 <assert test="not(preceding::*[local-name()='Interface' or local-name()='Typedef' or local-name()='Exception' or local-name()='Dictionary'][@id=current()/@id])"><value-of select="concat(local-name(.), ' ', @name)"/> clashes with previous definition of <value-of select="concat(local-name(preceding::*[local-name()='Interface'  or local-name()='Typedef' or local-name()='Exception' or local-name()='Dictionary'][@name=current()/@name][1]),' ', @name)"/></assert>
       </rule>
       <rule context="//Interface[@id]">
	 <assert test="(@partial or not(preceding::Interface[@id=current()/@id])) or not(preceding::*[local-name()='Typedef' or local-name()='Exception' or local-name()='Dictionary'][@id=current()/@id])"><value-of select="concat(local-name(.), ' ', @name)"/> clashes with previous definition of <value-of select="concat(local-name(preceding::*[local-name()='Interface' or local-name()='Typedef' or local-name()='Exception' or local-name()='Dictionary'][@name=current()/@name][1]),' ', @name)"/></assert>
       </rule>
     </pattern>
     <pattern>
       <title>Constant/Attribute names don't clash with other interface/exception members</title>
       <rule context="//Const|//Attribute">
	 <assert test="not(preceding-sibling::*[local-name()='Operation' or local-name()='Attribute' or local-name()='Const'][@name=current()/@name])"><value-of select="concat(local-name(), ' ', @name)"/> in <value-of select="concat(local-name(parent::*), ' ', parent::*/@name)"/> clashes with another interface member.</assert>
       </rule>
     </pattern>
     <pattern>
       <title>Dictionary member names don't clash with other dictionary members</title>
       <rule context="//DictionaryMember">
	 <assert test="not(preceding-sibling::DictionaryMember[@name=current()/@name])">Dictionary member <value-of select="@name"/> in <value-of select="parent::Dictionary/@name"/> clashes with another dictionary member.</assert>
       </rule>
     </pattern>
     <pattern>
       <title>Prefer DOMException</title>
       <rule context="//Exception">
	 <assert role="warning" test="ExceptionField[@name!='code' and @name!='name']">New exception (<value-of select="@name"/>) defined; minting new exceptions should only be done if additional fields are needed on top of DOMException.</assert>
	 <assert test="not(@name = 'Error' or @name = 'EvalError' or @name = 'RangeError' or @name = 'ReferenceError' or @name = 'SyntaxError' or @name = 'TypeError' or @name = 'URIError')">Exception <value-of select="@name"/> clashes with predefined ECMAScript error objects.</assert>
       </rule>

     </pattern>
     <pattern>
       <title>Operations</title>
       <rule context="//Operation">
	 <assert test="@name or @stringifier or @getter or @setter or @creator or @deleter or @legacycaller"><value-of select="concat(local-name(parent::*), ' ', parent::*/@name)"/> has an operation without identifier but which is not a special operation.</assert>
	 <assert test="not(preceding-sibling::*[local-name()='Attribute' or local-name()='Const'][@name=current()/@name])"><value-of select="concat(local-name(), ' ', @name)"/> in <value-of select="concat(local-name(parent::*), ' ', parent::*/@name)"/> clashes with another interface member.</assert>
	 <assert test="not(ArgumentList/Argument[@ellipsis]) or not(ArgumentList/Argument[@ellipsis]/following-sibling::Argument)"><value-of select="concat(local-name(parent::*), ' ', parent::*/@name)"/> defines a variadic operation (<value-of select="@name"/>) but the ... is not set on the last argument.</assert>
	 <assert test="not(ArgumentList/Argument[@optional]) or not(ArgumentList/Argument[@optional]/following-sibling::Argument[not(@optional) and not(@ellipsis)])"><value-of select="concat(local-name(parent::*), ' ', parent::*/@name,'.',@name,'()')"/> has a non-optional argument after an optional one.</assert>
       </rule>
     </pattern>
     <pattern>
       <title>Sequence are not to be used for attributes definition</title>
       <rule context="//Attribute">
	 <assert test="not(Type[@type='sequence']) and not(//Typedef[@name=current()/Type/@name]/Type[@type='sequence'])">Attribute <value-of select="@name"/> in <value-of select="concat(local-name(parent::*),' ',parent::*/@name)"/> is defined as a sequence.</assert>
       </rule>
     </pattern>
     <pattern>
       <title>Dictionaries are not to be used for attributes or exception fields</title>
       <rule context="//Attribute|//ExceptionField">
	 <assert test="not(//Dictionary[@name=current()/Type/@name])"><value-of select="concat(local-name(),' ',@name)"/> in <value-of select="concat(local-name(parent::*),' ',parent::*/@name)"/> is defined as a dictionary.</assert>
       </rule>
     </pattern>
     <!--
     <pattern>
       <title>Constant values need to match their types</title>
       <rule context="//Const|//DictionaryMember[@value or @stringvalue]">
	  
       </rule>
     </pattern>
     -->
     <pattern>
       <title>Special Operations</title>
       <rule context="//Operation[@stringifier or @getter or @setter or @creator or @deleter or @legacycaller]">
	 <assert test="not(@stringifier) or not(preceding-sibling::*[@stringifier])"><value-of select="concat(local-name(parent::*),' ',parent::*/@name)" /> defines more than one stringifier.</assert>
	 <assert test="not(@getter) or not(ArgumentList/Argument[1]/Type/@type='unsigned long') or not(preceding-sibling::Operation[@getter]) or not(preceding-sibling::Operation[@getter]/ArgumentList/Argument[1]/Type/@type=current()/ArgumentList/Argument[1]/Type/@type)"><value-of select="concat(local-name(parent::*),' ',parent::*/@name)" /> defines more than one index getter.</assert>
	 <assert test="not(@getter) or not(ArgumentList/Argument[1]/Type/@type='DOMString') or not(preceding-sibling::Operation[@getter]) or not(preceding-sibling::Operation[@getter]/ArgumentList/Argument[1]/Type/@type=current()/ArgumentList/Argument[1]/Type/@type)"><value-of select="concat(local-name(parent::*),' ',parent::*/@name)" /> defines more than one name getter.</assert>
	 <assert test="not(@deleter) or not(ArgumentList/Argument[1]/Type/@type='unsigned long') or not(preceding-sibling::Operation[@deleter]) or not(preceding-sibling::Operation[@deleter]/ArgumentList/Argument[1]/Type/@type=current()/ArgumentList/Argument[1]/Type/@type)"><value-of select="concat(local-name(parent::*),' ',parent::*/@name)" /> defines more than one index deleter.</assert>
	 <assert test="not(@deleter) or not(ArgumentList/Argument[1]/Type/@type='DOMString') or not(preceding-sibling::Operation[@deleter]) or not(preceding-sibling::Operation[@deleter]/ArgumentList/Argument[1]/Type/@type=current()/ArgumentList/Argument[1]/Type/@type)"><value-of select="concat(local-name(parent::*),' ',parent::*/@name)" /> defines more than one name deleter.</assert>
	 <assert test="not(@setter) or not(ArgumentList/Argument[1]/Type/@type='unsigned long') or not(preceding-sibling::Operation[@setter]) or not(preceding-sibling::Operation[@setter]/ArgumentList/Argument[1]/Type/@type=current()/ArgumentList/Argument[1]/Type/@type)"><value-of select="concat(local-name(parent::*),' ',parent::*/@name)" /> defines more than one index setter.</assert>
	 <assert test="not(@setter) or not(ArgumentList/Argument[1]/Type/@type='DOMString') or not(preceding-sibling::Operation[@setter]) or not(preceding-sibling::Operation[@setter]/ArgumentList/Argument[1]/Type/@type=current()/ArgumentList/Argument[1]/Type/@type)"><value-of select="concat(local-name(parent::*),' ',parent::*/@name)" /> defines more than one name setter.</assert>
	 <assert test="not(@creator) or not(ArgumentList/Argument[1]/Type/@type='unsigned long') or not(preceding-sibling::Operation[@creator]) or not(preceding-sibling::Operation[@creator]/ArgumentList/Argument[1]/Type/@type=current()/ArgumentList/Argument[1]/Type/@type)"><value-of select="concat(local-name(parent::*),' ',parent::*/@name)" /> defines more than one index creator.</assert>
	 <assert test="not(@creator) or not(ArgumentList/Argument[1]/Type/@type='DOMString') or not(preceding-sibling::Operation[@creator]) or not(preceding-sibling::Operation[@creator]/ArgumentList/Argument[1]/Type/@type=current()/ArgumentList/Argument[1]/Type/@type)"><value-of select="concat(local-name(parent::*),' ',parent::*/@name)" /> defines more than one name creator.</assert>
	 <assert test="not(ArgumentList/Argument/@ellipsis)"><value-of select="concat(local-name(parent::*),' ',parent::*/@name)" /> defines a special operation that is variadic.</assert>
	 <assert test="not(ArgumentList/Argument/@optional)"><value-of select="concat(local-name(parent::*),' ',parent::*/@name)" /> defines a special operation with optional arguments.</assert>
	 <assert test="not(@stringifier) or not(ArgumentList/Argument)"><value-of select="concat(local-name(parent::*),' ',parent::*/@name)" /> defines a stringifier operation with arguments.</assert>
	 <assert test="not(@stringifier) or Type/@type='DOMString'"><value-of select="concat(local-name(parent::*),' ',parent::*/@name)" /> defines a stringifier operation with a return type that is not a DOMString.</assert>
	 <assert test="not(@getter) or count(ArgumentList/Argument)=1"><value-of select="concat(local-name(parent::*),' ',parent::*/@name)" /> defines a getter operation that doesn't take a single argument.</assert>
	 <assert test="not(@deleter) or count(ArgumentList/Argument)=1"><value-of select="concat(local-name(parent::*),' ',parent::*/@name)" /> defines a deleter operation that doesn't take a single argument.</assert>
	 <assert test="not(@setter) or count(ArgumentList/Argument)=2"><value-of select="concat(local-name(parent::*),' ',parent::*/@name)" /> defines a setter operation that doesn't take exactly two arguments.</assert>
	 <assert test="not(@creator) or count(ArgumentList/Argument)=2"><value-of select="concat(local-name(parent::*),' ',parent::*/@name)" /> defines a creator operation that doesn't take exactly two arguments.</assert>
	 <assert test="not(@getter) or ArgumentList/Argument[1]/Type/@type='DOMString' or ArgumentList/Argument[1]/Type/@type='unsigned long'"><value-of select="concat(local-name(parent::*),' ',parent::*/@name)" /> defines a getter operation with first argument different from DOMString and unsigned long.</assert>
	 <assert test="not(@setter) or ArgumentList/Argument[1]/Type/@type='DOMString' or ArgumentList/Argument[1]/Type/@type='unsigned long'"><value-of select="concat(local-name(parent::*),' ',parent::*/@name)" /> defines a setter operation with first argument different from DOMString and unsigned long.</assert>
	 <assert test="not(@deleter) or ArgumentList/Argument[1]/Type/@type='DOMString' or ArgumentList/Argument[1]/Type/@type='unsigned long'"><value-of select="concat(local-name(parent::*),' ',parent::*/@name)" /> defines a deleter operation with first argument different from DOMString and unsigned long.</assert>
	 <assert test="not(@creator) or ArgumentList/Argument[1]/Type/@type='DOMString' or ArgumentList/Argument[1]/Type/@type='unsigned long'"><value-of select="concat(local-name(parent::*),' ',parent::*/@name)" /> defines a creator operation with first argument different from DOMString and unsigned long.</assert>
	 <assert role="warning" test="not(@legacycaller)"><value-of select="concat(local-name(parent::*),' ',parent::*/@name)" /> defines a caller operation, but caller should be reserved to specify legacy APIs</assert>
       </rule>
     </pattern>
     <pattern>
       <title>Attribute with inherits getter</title>
       <rule context="//Attribute[@inherit='inherit']">
	 <assert test="@readonly='readonly'">Attribute <value-of select="concat(ancestor::Interface/@name, '.', @name)"/> inherits a getter but is not readonly.</assert>
	 <assert test="ancestor::Interface[InterfaceInheritance]">Attribute <value-of select="concat(ancestor::Interface/@name, '.', @name)"/> inherits a getter but does not belong to an interface with inheritance.</assert>
	 <assert test="not(ancestor::Interface[InterfaceInheritance] and //Interface[@name=current()/ancestor::Interface/InterfaceInheritance/Name/@name] and //Interface[@name=current()/ancestor::Interface/InterfaceInheritance/Name/@name]/Attribute[@name=current()/@name])
		       or //Interface[@name=current()/ancestor::Interface/InterfaceInheritance/Name/@name]/Attribute[@name=current()/@name]/Type[concat(@type,@name)=concat(current()/Type/@type,current()/Type/@name)]">Attribute <value-of select="concat(ancestor::Interface/@name, '.', @name)"/> inherits a getter but does not have the same type (<value-of select="concat(Type/@name,Type/@type)"/>) as the attribute <value-of select="concat(//Interface[@name=current()/ancestor::Interface/InterfaceInheritance/Name/@name]/@name, '.', //Interface[@name=current()/ancestor::Interface/InterfaceInheritance/Name/@name]/Attribute/@name)"/> (<value-of select="concat(//Interface[@name=current()/ancestor::Interface/InterfaceInheritance/Name/@name]/Attribute[@name=current()/@name]/Type/@type, //Interface[@name=current()/ancestor::Interface/InterfaceInheritance/Name/@name]/Attribute[@name=current()/@name]/Type/@name)"/>) it inherits from.</assert>
       </rule>       
     </pattern>
     <pattern>
       <title>Stringifier attributes</title>
       <rule context="//Attribute[@stringifier]">
	 <assert test="Type/@type='DOMString'"><value-of select="concat(local-name(parent::*),' ',parent::*/@name)" /> defines a stringifier attribute that is not of type DOMString.</assert>
	 <assert test="not(preceding-sibling::*[@stringifier])"><value-of select="concat(local-name(parent::*),' ',parent::*/@name)" /> defines more than one stringifier.</assert>
       </rule>
     </pattern>
     <pattern>
       <title>Overloading</title>
     </pattern>
     <pattern>
       <title>Extended attributes are well-known</title>
       <rule context="//ExtendedAttribute[@name]">
	 <assert see="http://dev.w3.org/2006/webapi/WebIDL/#es-extended-attributes" test="@name='AllowAny' or @name='ArrayClass' or @name='Callback' or @name='Constructor' or @name='NamedConstructor' or @name='NoInterfaceObject' or @name='OverrideBuiltins' or @name='PutForwards' or @name='Replaceable' or @name='TreatNullAs' or @name='TreatUndefinedAs' or @name='TreatNonCallableAsNull' or @name='TreatNonCallableAsNull' or @name='Clamp' or @name='ReplaceableNamedProperties' or @name='Unforgeable' or @name='EnforceRange' or @name='ImplicitThis' or @name='LenientThis'">Extended attribute of <value-of select="@name"/> is unknown in WebIDL.</assert>
       </rule>
     </pattern>
     <pattern>
       <title>Extended attribute common abstract rules</title>
       <rule  id="extendedAttributeAppliesToInterface" abstract="true">
	 <assert test="parent::ExtendedAttributeList/parent::Interface">Extended attribute <value-of select="@name"/> used on <value-of select="local-name(parent::ExtendedAttributeList/parent::*)" /> — <value-of select="@name"/> expected only on interfaces.</assert>	 
       </rule>
       <rule  name="Extended attribute takes no argument" id="extendedAttributeNoArg" abstract="true">
	 <assert test="not(@value)">Extended attribute <value-of select="@name"/> used with arguments on <value-of select="concat(local-name(parent::ExtendedAttributeList/parent::*),' ',parent::ExtendedAttributeList/parent::*/@name)"/>.</assert>
       </rule>
       <rule name="Extended attribute cannot be used on an interface that inherits from another" id="extendedAttributeNotWithInheritance" abstract="true">
	 <assert test="not(parent::ExtendedAttributeList/parent::Interface/InterfaceInheritance)">The interface <value-of select="parent::ExtendedAttributeList/parent::Interface/@name"/> has extended attribute <value-of select="@name"/> but inherits from another interface (<value-of select="parent::ExtendedAttributeList/parent::Interface/InterfaceInheritance/Name/@name"/>).</assert>
       </rule>
       <rule name="Extended attribute can only be used on attribute" abstract="true" id="extendedAttributeAppliesToAttribute">
	 <assert test="parent::ExtendedAttributeList/parent::Attribute">Extended attribute <value-of select="@name"/> used on <value-of select="local-name(parent::ExtendedAttributeList/parent::*)" /> — <value-of select="@name"/> expected only on attributes.</assert>
       </rule>
       <rule name="Extended attribute can only be used on read-only attribute" abstract="true" id="extendedAttributeAppliesToReadonlyAttribute">
	 <assert test="parent::ExtendedAttributeList/parent::Attribute">Extended attribute <value-of select="@name"/> used on <value-of select="local-name(parent::ExtendedAttributeList/parent::*)" /> — <value-of select="@name"/> expected only on attributes.</assert>
	 <assert test="not(parent::ExtendedAttributeList/parent::Attribute) or parent::ExtendedAttributeList/parent::Attribute[@readonly='readonly']">Extended attribute <value-of select="@name"/> used on non-readonly attribute <value-of select="ancestor::Interface/@name" />.<value-of select="parent::ExtendedAttributeList/parent::Attribute/@name" /> — <value-of select="@name"/> expected only on readonly attributes.</assert>
       </rule>

     </pattern>
     <pattern>
       <title>Extended attribute Callback</title>
       <rule context="//ExtendedAttribute[@name='Callback']">
	 <extends rule="extendedAttributeAppliesToInterface"/>
	 <assert see="http://dev.w3.org/2006/webapi/WebIDL/#Callback" test="not(@value) or @value='FunctionOnly' or @value='PropertyOnly'">Extended attribute Callback used on <value-of select="parent::ExtendedAttributeList/parent::Interface/@name" /> uses an unknown argument <value-of select="@value"/>.</assert>
	 <extends see="http://dev.w3.org/2006/webapi/WebIDL/#native-objects" rule="extendedAttributeNotWithInheritance"/>
	 <assert see="http://dev.w3.org/2006/webapi/WebIDL/#native-objects" test="not(parent::ExtendedAttributeList/ExtendedAttribute[@name='Constructor' or @name='NamedConstructor'])">The interface <value-of select="parent::ExtendedAttributeList/parent::Interface/@name"/> has both extended attributes Callback and <value-of select="parent::ExtendedAttributeList/ExtendedAttribute[@name='Constructor' or @name='NamedConstructor']/@name"/>).</assert>
	 <assert see="http://dev.w3.org/2006/webapi/WebIDL/#native-objects" test="not(parent::ExtendedAttributeList/parent::Interface/Operation[@getter or @setter or @creator or @deleter or @legacycaller or @stringifier])">The interface <value-of select="parent::ExtendedAttributeList/parent::Interface/@name"/> has a Callback extended attribute, but offers a either  getters, setters, creators, deleters, caller or stringifier.</assert>
	 <!-- @@@ widlproc doesn't show extended attributes on attributes ? -->
	 <assert see="http://dev.w3.org/2006/webapi/WebIDL/#native-objects" test="not(parent::ExtendedAttributeList/parent::Interface/Attribute[ExtendedAttributeList/ExtendedAttribute[@name='PutForwards' or @name='TreatNullAs' or @name='TreatUndefinedAs']])">The interface <value-of select="parent::ExtendedAttributeList/parent::Interface/@name"/> has a Callback extended attribute, but exposes an attribute with a <value-of select="parent::ExtendedAttributeList/parent::Interface/Attribute/ExtendedAttributeList/ExtendedAttribute[@name='PutForwards' or @name='TreatNullAs' or @name='TreatUndefinedAs']/@name"/> extended attribute.</assert>
	 <assert see="http://dev.w3.org/2006/webapi/WebIDL/#Callback" test="not(@value and parent::ExtendedAttributeList/parent::Interface/Attribute)">The interface <value-of select="parent::ExtendedAttributeList/parent::Interface/@name"/> uses a Callback extended attribute with an argument, but exposes at least one attribute.</assert>
	 <let name="firstOperationName" value="parent::ExtendedAttributeList/parent::Interface/Operation[1]/@name"/>
	 <assert see="http://dev.w3.org/2006/webapi/WebIDL/#Callback" test="not(@value) or (count(parent::ExtendedAttributeList/parent::Interface/Operation[@name!=$firstOperationName])=0 and $firstOperationName)">The interface <value-of select="parent::ExtendedAttributeList/parent::Interface/@name"/> uses a Callback extended attribute with an argument, but exposes zero or multiple operations with different identifiers.</assert>
       <!-- ECMAScript objetcs as property bags -->
       <assert role="warning" see="http://dev.w3.org/2006/webapi/WebIDL/#Callback" test="not(parent::ExtendedAttributeList/ExtendedAttribute[@name='NoInterfaceObject']) or ancestor::Interface/Operation">Interface <value-of select="ancestor::Interface/@name" /> with no operation declared with NoInterfaceObject and Callback: specification authors wanting to APIs that take ECMAScript objects as “property bag” like function arguments are suggested to use dictionary types rather than interfaces annotated with [Callback,NoInterfaceObject].</assert>
       </rule>
     </pattern>
     <pattern>
       <title>Extended attribute Constructor</title>
       <rule context="//ExtendedAttribute[@name='Constructor']">
	 <extends rule="extendedAttributeAppliesToInterface"/>
       </rule>
     </pattern>
     <pattern>
       <title>Extended attribute NamedConstructor</title>
       <rule context="//ExtendedAttribute[@name='NamedConstructor']">
	 <extends rule="extendedAttributeAppliesToInterface"/>
	 <!-- @@@ The NamedConstructor clash checks should be done across all well-known IDLs -->
	 <assert  see="http://dev.w3.org/2006/webapi/WebIDL/#NamedConstructor" test="not(parent::ExtendedAttributeList/parent::Interface/preceding::Interface/ExtendedAttributeList/ExtendedAttribute[@name='NamedConstructor' and @value=current()/@value])">Extended attribute NamedConstructor with identifier <value-of select="@value"/> in <value-of select="parent::ExtendedAttributeList/parent::Interface/@name"/> interface clashes with NamedConstructor on interface <value-of select="parent::ExtendedAttributeList/parent::Interface/preceding::Interface[ExtendedAttributeList/ExtendedAttribute[@name='NamedConstructor' and @value=current()/@value]]/@name"/>.</assert> 
	 <assert  see="http://dev.w3.org/2006/webapi/WebIDL/#NamedConstructor" test="not($standards//Interface/ExtendedAttributeList/ExtendedAttribute[@name='NamedConstructor' and @value=current()/@value])">Extended attribute NamedConstructor with identifier <value-of select="@value"/> in <value-of select="parent::ExtendedAttributeList/parent::Interface/@name"/> interface clashes with NamedConstructor on externally defined interface <value-of select="$standards//Interface[ExtendedAttributeList/ExtendedAttribute[@name='NamedConstructor' and @value=current()/@value]]/@name"/>.</assert> 

	 <assert  see="http://dev.w3.org/2006/webapi/WebIDL/#NamedConstructor" test="not(parent::ExtendedAttributeList/parent::Interface/preceding::Interface[not(ExtendedAttributeList/ExtendedAttribute[@name='NoInterfaceObject'])][@name=current()/@value])">Extended attribute NamedConstructor with identifier <value-of select="@value"/> in <value-of select="parent::ExtendedAttributeList/parent::Interface/@name"/> interface clashes with  interface <value-of select="parent::ExtendedAttributeList/parent::Interface/preceding::Interface[not(ExtendedAttributeList/ExtendedAttribute[@name='NoInterfaceObject'])][@name=current()/@value]/@name"/>.</assert> 
	 <assert  see="http://dev.w3.org/2006/webapi/WebIDL/#NamedConstructor" test="not($standards//Interface[not(ExtendedAttributeList/ExtendedAttribute[@name='NoInterfaceObject'])][@name=current()/@value])">Extended attribute NamedConstructor with identifier <value-of select="@value"/> in <value-of select="parent::ExtendedAttributeList/parent::Interface/@name"/> interface clashes with externally defined interface <value-of select="$standards//Interface[not(ExtendedAttributeList/ExtendedAttribute[@name='NoInterfaceObject'])][@name=current()/@value]/@name"/>.</assert> 


	 <assert  see="http://dev.w3.org/2006/webapi/WebIDL/#NamedConstructor" test="not(parent::ExtendedAttributeList/parent::Interface/preceding::Exception[not(ExtendedAttributeList/ExtendedAttribute[@name='NoInterfaceObject'])][@name=current()/@value])">Extended attribute NamedConstructor with identifier <value-of select="@value"/> in <value-of select="parent::ExtendedAttributeList/parent::Interface/@name"/> interface clashes with exception interface <value-of select="parent::ExtendedAttributeList/parent::Interface/preceding::Exception[not(ExtendedAttributeList/ExtendedAttribute[@name='NoInterfaceObject'])][@name=current()/@value]/@name"/>.</assert> 
	 <assert  see="http://dev.w3.org/2006/webapi/WebIDL/#NamedConstructor" test="not($standards//Exception[not(ExtendedAttributeList/ExtendedAttribute[@name='NoInterfaceObject'])][@name=current()/@value])">Extended attribute NamedConstructor with identifier <value-of select="@value"/> in <value-of select="parent::ExtendedAttributeList/parent::Interface/@name"/> interface clashes with externally defined exception interface <value-of select="$standards//Exception[not(ExtendedAttributeList/ExtendedAttribute[@name='NoInterfaceObject'])][@name=current()/@value]/@name"/>.</assert> 


       </rule>
     </pattern>
     <pattern>
       <title>Extended attribute NoInterfaceObject</title>
       <rule context="//ExtendedAttribute[@name='NoInterfaceObject']">
	 <assert see="http://dev.w3.org/2006/webapi/WebIDL/#NoInterfaceObject" test="parent::ExtendedAttributeList/parent::Interface or parent::ExtendedAttributeList/parent::Exception">Extended attribute NoInterfaceObject used on <value-of select="local-name(parent::ExtendedAttributeList/parent::*)" /> — NoInterfaceObject expected only on interfaces and exceptions.</assert>
	 <extends rule="extendedAttributeNoArg"/>
	 <!-- @@@ shouldn't this also apply to NamedConstructor? -->
	 <assert see="http://dev.w3.org/2006/webapi/WebIDL/#NoInterfaceObject" test="not(parent::ExtendedAttributeList/ExtendedAttribute[@name='Constructor'])">Extended attribute NoInterfaceObject used in combination with extended attribute Constructor on interface <value-of select="parent::ExtendedAttributeList/parent::*/@name"/>.</assert>
	 <assert see="http://dev.w3.org/2006/webapi/WebIDL/#NoInterfaceObject" test="not(ancestor::Interface/Operation[@static='static'])">Extended attribute NoInterfaceObject used on interface <value-of select="parent::ExtendedAttributeList/parent::*/@name"/>, but that interface that has a static operation .</assert>
	 <!-- TODO: The [NoInterfaceObject] extended attribute SHOULD NOT be used on interfaces that are not solely used as supplemental or callback interfaces, unless there are clear Web compatibility reasons for doing so.  -->
       </rule>
     </pattern>
     <pattern>
       <title>Extended attribute OverrideBuiltins</title>
       <rule context="//ExtendedAttribute[@name='OverrideBuiltins']">
	 <extends rule="extendedAttributeAppliesToInterface"/>
	 <extends rule="extendedAttributeNoArg"/>
	 <assert see="http://dev.w3.org/2006/webapi/WebIDL/#OverrideBuiltins" test="parent::ExtendedAttributeList/parent::Interface[Operation/@getter]">Extended attribute OverrideBuiltins used on interface <value-of select="parent::ExtendedAttributeList/parent::Interface/@name"/> that does not have a name getter.</assert>
       </rule>
     </pattern>
     <pattern>
       <title>Extended Attribute PutForwards</title>
       <rule context="//ExtendedAttribute[@name='PutForwards']" >
	 <let name="validObject" value="parent::ExtendedAttributeList/parent::Attribute"/>
	 <extends see="http://dev.w3.org/2006/webapi/WebIDL/#PutForwards" rule="extendedAttributeAppliesToReadonlyAttribute"/>
	 <assert test="@value">Extended attribute <value-of select="@name"/> used without required argument on <value-of select="ancestor::Interface/@name" />.<value-of select="parent::ExtendedAttributeList/parent::Attribute/@name" />.</assert>
	 <let name="linkedInterface" value="parent::ExtendedAttributeList/parent::Attribute/Type/@name"/>
	 <assert see="http://dev.w3.org/2006/webapi/WebIDL/#PutForwards" test="not(@value and $validObject) or //Interface[@name=$linkedInterface]/Attribute[@name=current()/@value] or $standards//Interface[@name=$linkedInterface]/Attribute[@name=current()/@value]">Extended attribute PutForwards used on attribute <value-of select="ancestor::Interface/@name" />.<value-of select="parent::ExtendedAttributeList/parent::Attribute/@name" /> with argument <value-of select="@value"/> does not match a known attribute in <value-of select="$linkedInterface"/> interface.</assert>
	 <!--<assert see="http://dev.w3.org/2006/webapi/WebIDL/#PutForwards" test="false">PutForwards on attribute <value-of select="parent::ExtendedAttributeList/parent::Interface/@name"/>.<value-of select="parent::ExtendedAttributeList/parent::Attribute/@name" /> is creating a cycle</assert>-->
       </rule>
     </pattern>
     <pattern>
       <title>Extended Attribute Replaceable</title>
       <rule context="//ExtendedAttribute[@name='Replaceable']" >
	 <extends rule="extendedAttributeNoArg"/>
	 <extends see="http://dev.w3.org/2006/webapi/WebIDL/#PutForwards" rule="extendedAttributeAppliesToReadonlyAttribute"/>
       </rule>
     </pattern>
     <pattern>
       <title>Extended Attribute TreatNullAs</title>
       <rule context="//ExtendedAttribute[@name='TreatNullAs']">
	 <let name="validObject" value="parent::ExtendedAttributeList/parent::Attribute or parent::ExtendedAttributeList/parent::Argument/parent::ArgumentList/parent::Operation or parent::ExtendedAttributeList/parent::Operation"/>
	 <let name="objectName" value="concat(ancestor::Interface/@name,'.',concat(parent::ExtendedAttributeList/parent::Attribute/@name, parent::ExtendedAttributeList/parent::Argument/parent::ArgumentList/parent::Operation/@name, parent::ExtendedAttributeList/parent::Operation/@name))"/>
	 <assert test="$validObject">Extended attribute <value-of select="@name"/> used on <value-of select="local-name(parent::ExtendedAttributeList/parent::*)" /> — <value-of select="@name"/> expected only on attribute, operation arguments, or operations.</assert>
	 <assert test="not($validObject) or parent::ExtendedAttributeList/parent::*/Type[@type='DOMString' and not(@nullable)]">Extended attribute TreatNullAs used on <value-of select="$objectName" /> applied to type <value-of select="concat(parent::ExtendedAttributeList/parent::*/Type/@type, parent::ExtendedAttributeList/parent::*/Type/@name)"/> — TreatNullAs expected only on attributes, operations or operations arguments with non-nullable DOMString type.</assert>
	 <assert test="not($validObject) or @value='EmptyString'">Extended attribute TreatNullAs used on <value-of select="$objectName" /> without required “EmptyString” argument.</assert>
       </rule>
     </pattern>
     <pattern>
       <title>Extended Attribute TreatUndefinedAs</title>
       <rule context="//ExtendedAttribute[@name='TreatUndefinedAs']">
	 <let name="validObject" value="parent::ExtendedAttributeList/parent::Attribute or parent::ExtendedAttributeList/parent::Argument/parent::ArgumentList/parent::Operation or parent::ExtendedAttributeList/parent::Operation"/>
	 <let name="objectName" value="concat(ancestor::Interface/@name,'.',concat(parent::ExtendedAttributeList/parent::Attribute/@name, parent::ExtendedAttributeList/parent::Argument/parent::ArgumentList/parent::Operation/@name, parent::ExtendedAttributeList/parent::Operation/@name))"/>
	 <assert test="$validObject">Extended attribute <value-of select="@name"/> used on <value-of select="local-name(parent::ExtendedAttributeList/parent::*)" /> — <value-of select="@name"/> expected only on attribute, operation arguments, or operations.</assert>
	 <assert test="not($validObject) or parent::ExtendedAttributeList/parent::*/Type[@type='DOMString']">Extended attribute TreatUndefinedAs used on <value-of select="$objectName" /> applied to type <value-of select="concat(parent::ExtendedAttributeList/parent::*/Type/@type, parent::ExtendedAttributeList/parent::*/Type/@name)"/> — TreatUndefinedAs expected only on attributes, operations or operations arguments with DOMString or DOMString? type.</assert>
	 <assert test="not($validObject) or (@value='EmptyString' or @value='Null')">Extended attribute TreatUndefinedAs used on <value-of select="$objectName" /> without required “EmptyString” or “Null” argument.</assert>
	 <assert test="not($validObject and parent::ExtendedAttributeList/parent::*/Type[@type='DOMString']) or not(@value='Null') or  (@value='Null' and parent::ExtendedAttributeList/parent::*/Type[@nullable='nullable'])">Extended attribute TreatUndefinedAs used on <value-of select="$objectName" /> with required “Null” argument, but not applied to a DOMString? object.</assert>
       </rule>
     </pattern>
     <pattern>
       <title>Extended Attribute Clamp</title>
       <rule context="//ExtendedAttribute[@name='Clamp']">
	 <let name="validObject" value="parent::ExtendedAttributeList/parent::Attribute or parent::ExtendedAttributeList/parent::Argument/parent::ArgumentList/parent::Operation or parent::ExtendedAttributeList/parent::DictionaryMember"/>
	 <let name="objectName" value="concat(ancestor::*[local-name()='Interface' or local-name()='Dictionary'][1]/@name,'.',concat(parent::ExtendedAttributeList/parent::Attribute/@name, parent::ExtendedAttributeList/parent::Argument/parent::ArgumentList/parent::Operation/@name, parent::ExtendedAttributeList/parent::Operation/@name, parent::ExtendedAttributeList/parent::DictionaryMember/@name))"/>
	 <extends rule="extendedAttributeNoArg"/>
	 <assert test="$validObject">Extended attribute <value-of select="@name"/> used on <value-of select="concat(local-name(parent::ExtendedAttributeList/parent::*), ' ', parent::ExtendedAttributeList/parent::*/@name)" /> — <value-of select="@name"/> expected only on attribute, operation arguments, or dictionary members.</assert>
	 <assert test="not($validObject and parent::ExtendedAttributeList/parent::Attribute) or (parent::ExtendedAttributeList/parent::Attribute[not(@readonly)])">Extended attribute Clamp used on non-writable attribute <value-of select="$objectName"/></assert>
	 <assert test="not($validObject) or (parent::ExtendedAttributeList/parent::*/Type[@type='byte' or @type='octet' or @type='short' or @type='unsigned short' or @type='long' or @type='unsigned long' or @type='long long' or @type='unsigned long long'])">Extended attribute Clamp used on non-integer <value-of select="local-name(parent::ExtendedAttributeList/parent::*)"/> <value-of select="$objectName"/></assert>

       </rule>
     </pattern>
     <pattern>
       <title>Extended attribute ReplaceableNamedProperties</title>
       <rule context="//ExtendedAttribute[@name='ReplaceableNamedProperties']">
	 <let name="validObject" value="parent::ExtendedAttributeList/parent::Interface"/>
	 <extends rule="extendedAttributeAppliesToInterface"/>
	 <extends rule="extendedAttributeNoArg"/>
	 <assert test="not($validObject) or parent::ExtendedAttributeList/parent::Interface[Operation/@getter]">Extended attribute ReplaceNamedProperties used on interface <value-of select="parent::ExtendedAttributeList/parent::Interface/@name"/>  that does not define a name getter</assert>
	 <assert test="not($validObject) or not(parent::ExtendedAttributeList/parent::Interface/Operation/@setter)">Extended attribute ReplaceNamedProperties used on interface <value-of select="parent::ExtendedAttributeList/parent::Interface/@name"/>  that defines a name setter</assert>
	 <assert test="not($validObject) or not(parent::ExtendedAttributeList/ExtendedAttribute/@name='OverrideBuiltins')">Extended attribute ReplaceNamedProperties used on interface <value-of select="parent::ExtendedAttributeList/parent::Interface/@name"/> that also has the OverrideBuiltins extended attribute</assert>
       </rule>
     </pattern>
     <pattern>
       <title>Extended attribute Unforgeable</title>
       <rule context="//ExtendedAttribute[@name='Unforgeable']">
	 <let name="validObject" value="parent::ExtendedAttributeList/parent::Attribute"/>
	 <extends rule="extendedAttributeAppliesToAttribute"/>
	 <extends rule="extendedAttributeNoArg"/>
	 <assert test="not($validObject) or parent::ExtendedAttributeList/parent::Attribute/@readonly">Extended attribute Unforgeable used on non-readonly attribute <value-of select="concat(parent::ExtendedAttributeList/parent::Attribute/parent::Interface/@name, '.', parent::ExtendedAttributeList/parent::Attribute/@name)"/></assert>
	 <!-- @@@ TODO: It also MUST NOT appear on an attribute on interface A if there exists another interface B that defines any interface member with the same identifier, and which either has A as an inherited interface or which is a consequential interface of A. -->
       </rule>
     </pattern>
     <pattern>
       <title>Extended attribute TreatNonCallableAsNull</title>
       <rule context="//ExtendedAttribute[@name='TreatNonCallableAsNull']">
	 <assert role="warning" test="false">Extended attribute TreatNonCallableAsNull used on <value-of select="concat(local-name(parent::ExtendedAttributeList/parent::*), ' ', parent::ExtendedAttributeList/parent::*/@name)"/> ; specifications SHOULD NOT use [TreatNonCallableAsNull] unless required to specify the behavior of legacy APIs.</assert>
	 <assert test="parent::ExtendedAttributeList/parent::Attribute or parent::ExtendedAttributeList/parent::Argument">Extended attribute TreatNonCallableAsNull used on <value-of select="concat(local-name(parent::ExtendedAttributeList/parent::*), ' ', parent::ExtendedAttributeList/parent::*/@name)"/> can only be used on attributes or operation arguments</assert>
	 <assert test="not(parent::ExtendedAttributeList/parent::Attribute or parent::ExtendedAttributeList/parent::Argument) or (parent::ExtendedAttributeList/parent::*/Type/@nullable='nullable' and (parent::ExtendedAttributeList/parent::*/Type/@name = 'Function' or //Interface[@name = current()/parent::ExtendedAttributeList/parent::*/Type/@name]/@callback='callback'))">Extended attribute TreatNonCallableAsNull used on <value-of select="concat(local-name(parent::ExtendedAttributeList/parent::*), ' ', parent::ExtendedAttributeList/ancestor::Interface/@name, '.', parent::ExtendedAttributeList/ancestor::*[local-name()='Attribute' or local-name()='Operation']/@name)"/> can only be used on an attribute or operation argument whose type is a nullable callback interface.</assert>
       </rule>
     </pattern>
     <pattern>
       <title>Extended attribute ArrayClass</title>
       <rule context="//ExtendedAttribute[@name='ArrayClass']">
	 <extends rule="extendedAttributeNoArg"/>
	 <extends rule="extendedAttributeAppliesToInterface"/>
	 <extends rule="extendedAttributeNotWithInheritance"/>
       </rule>
     </pattern>

     <pattern>
       <title>Extended attribute EnforceRange</title>
       <rule context="//ExtendedAttribute[@name='EnforceRange']">
	 <let name="validObject" value="parent::ExtendedAttributeList/parent::Attribute or parent::ExtendedAttributeList/parent::Argument/parent::ArgumentList/parent::Operation or parent::ExtendedAttributeList/parent::DictionaryMember"/>
	 <let name="objectName" value="concat(ancestor::*[local-name()='Interface' or local-name()='Dictionary'][1]/@name,'.',concat(parent::ExtendedAttributeList/parent::Attribute/@name, parent::ExtendedAttributeList/parent::Argument/parent::ArgumentList/parent::Operation/@name, parent::ExtendedAttributeList/parent::Operation/@name, parent::ExtendedAttributeList/parent::DictionaryMember/@name))"/>
	 <extends rule="extendedAttributeNoArg"/>
	 <assert test="$validObject">Extended attribute <value-of select="@name"/> used on <value-of select="concat(local-name(parent::ExtendedAttributeList/parent::*), ' ', parent::ExtendedAttributeList/parent::*/@name)" /> — <value-of select="@name"/> expected only on attribute, operation arguments, or dictionary members.</assert>
	 <assert test="not($validObject and parent::ExtendedAttributeList/parent::Attribute) or (parent::ExtendedAttributeList/parent::Attribute[not(@readonly)])">Extended attribute EnforceRange used on non-writable attribute <value-of select="$objectName"/></assert>
	 <assert test="not($validObject) or (parent::ExtendedAttributeList/parent::*/Type[@type='byte' or @type='octet' or @type='short' or @type='unsigned short' or @type='long' or @type='unsigned long' or @type='long long' or @type='unsigned long long'])">Extended attribute EnforceRange used on non-integer <value-of select="local-name(parent::ExtendedAttributeList/parent::*)"/> <value-of select="$objectName"/></assert>
	 <assert test="not($validObject) or not(parent::ExtendedAttributeList/ExtendedAttribute[@name='Clamp'])">Extended attribute EnforceRange used in conjunction with Clamp on <value-of select="local-name(parent::ExtendedAttributeList/parent::*)"/> <value-of select="$objectName"/></assert>
       </rule>
     </pattern>
     <pattern>
       <title>Extended attribute ImplicitThis</title>
       <rule context="//ExtendedAttribute[@name='ImplicitThis']">
	 <extends rule="extendedAttributeNoArg"/>
	 <extends rule="extendedAttributeAppliesToInterface"/>
       </rule>
     </pattern>
     <pattern>
       <title>Extended attribute LenientThis</title>
       <rule context="//ExtendedAttribute[@name='LenientThis']">
	 <extends rule="extendedAttributeNoArg"/>
	 <extends rule="extendedAttributeAppliesToAttribute"/>
	 <assert role="warning" test="false">Extended attribute LenientThis used on <value-of select="concat(local-name(parent::ExtendedAttributeList/parent::*), ' ', parent::ExtendedAttributeList/parent::*/@name)"/> ; specifications SHOULD NOT use [LenientThis] unless required for compatibility reasons.</assert>
       </rule>
     </pattern>
     <pattern>
       <title>Constants</title>
       <rule context="//Const">
	 <assert role="warning" test="Type[@type='unsigned short']">Numeric constant used <value-of select="@name"/> in <value-of select="concat(local-name(parent::*), ' ', parent::*/@name)"/>; the Web platform is moving away from using named integer codes in the style of an enumeration, in favor of the use of strings.</assert>
       </rule>
     </pattern>
</schema>
