<schema xmlns="http://purl.oclc.org/dsdl/schematron" >
  <let name="standards" value="document('../web-platform/standards.xml')"/>
     <pattern  id="definedTypes">
       <title>IDL is using defined types</title>
          <rule context="//Type[@name]">
               <assert role="warning" test="//Interface[@name=current()/@name] or $standards//Interface[@name=current()/@name] or //Dictionary[@name=current()/@name] or $standards//Dictionary[@name=current()/@name] or //Typedef[@name=current()/@name] or $standards//Typedef[@name=current()/@name]"><value-of select="@name"/> type used in <value-of select="ancestor::Interface[1]/@name" />.<value-of select="parent::*[1]/@name" /> declaration undefined.</assert>
          </rule>
     </pattern>
     <pattern>
       <title>Constant/Attribute names don't clash with other interface/exception members</title>
       <rule context="//Const|//Attribute">
	 <assert test="not(preceding-sibling::*[local-name()='Operation' or local-name()='Attribute' or local-name()='Const'][@name=current()/@name])"><value-of select="concat(local-name(), ' ', @name)"/> in <value-of select="concat(local-name(parent::*), ' ', parent::*/@name)"/> clashes with another interface member.</assert>
       </rule>
     </pattern>
     <pattern>
       <title>Dictionary member names don't clash with other dictionary members</title>
       <rule context="//DictionaryMember">
	 <assert test="not(preceding-sibling::DictionaryMember[@name=current()/@name])">Dictionary member <value-of select="@name"/> in <value-of select="parent::Dictionary/@name"/> clashes with another dictionary member.</assert>
       </rule>
     </pattern>
     <pattern>
       <title>Exceptions raised are well-known</title>
       <rule context="//RaiseException">
	 <assert role="warning" test="//Exception[@name=current()/@name] or $standards//Exception[@name=current()/@name]"><value-of select="@name"/> Exception raised by <value-of select="ancestor::Interface[1]/@name" />.<value-of select="parent::*/parent::*/@name" /> does not match a defined Exception.</assert>
       </rule>
     </pattern>
     <pattern>
       <title>Operations</title>
       <rule context="//Operation">
	 <assert test="@name or @stringifier or @getter or @setter or @creator or @deleter or @caller"><value-of select="concat(local-name(parent::*), ' ', parent::*/@name)"/> has an operation without identifier but which is not a special operation.</assert>
	 <assert test="not(preceding-sibling::*[local-name()='Attribute' or local-name()='Const'][@name=current()/@name])"><value-of select="concat(local-name(), ' ', @name)"/> in <value-of select="concat(local-name(parent::*), ' ', parent::*/@name)"/> clashes with another interface member.</assert>
	 <assert test="not(ArgumentList/Argument[@ellipsis]) or not(ArgumentList/Argument[@ellipsis]/following-sibling::Argument)"><value-of select="concat(local-name(parent::*), ' ', parent::*/@name)"/> defines a variadic operation (<value-of select="@name"/>) but the ... is not set on the last argument.</assert>
	 <assert test="not(ArgumentList/Argument[@optional]) or not(ArgumentList/Argument[@optional]/following-sibling::Argument[not(@optional) and not(@ellipsis)])"><value-of select="concat(local-name(parent::*), ' ', parent::*/@name,'.',@name,'()')"/> has a non-optional argument after an optional one.</assert>
       </rule>
     </pattern>
     <pattern>
       <title>Sequence are not to be used for attributes definition</title>
       <rule context="//Attribute">
	 <assert test="not(Type[@type='sequence']) and not(//Typedef[@name=current()/Type/@name]/Type[@type='sequence'])">Attribute <value-of select="@name"/> in <value-of select="concat(local-name(parent::*),' ',parent::*/@name)"/> is defined as a sequence.</assert>
       </rule>
     </pattern>
     <pattern>
       <title>Dictionaries are not to be used for attributes or exception fields</title>
       <rule context="//Attribute|//ExceptionField">
	 <assert test="not(//Dictionary[@name=current()/Type/@name])"><value-of select="concat(local-name(),' ',@name)"/> in <value-of select="concat(local-name(parent::*),' ',parent::*/@name)"/> is defined as a dictionary.</assert>
       </rule>
     </pattern>
     <!--
     <pattern>
       <title>Constant values need to match their types</title>
       <rule context="//Const|//DictionaryMember[@value or @stringvalue]">
	  
       </rule>
     </pattern>
     -->
     <pattern>
       <title>Special Operations</title>
       <rule context="//Operation[@stringifier or @getter or @setter or @creator or @deleter or @caller]">
	 <assert test="not(@omittable) or (@name)"><value-of select="concat(local-name(parent::*),' ',parent::*/@name)" /> defines an omittable operation that does not have an identifier.</assert>
	 <assert test="not(@stringifier) or not(preceding-sibling::*[@stringifier])"><value-of select="concat(local-name(parent::*),' ',parent::*/@name)" /> defines more than one stringifier.</assert>
	 <assert test="not(@getter) or not(ArgumentList/Argument[1]/Type/@type='unsigned long') or not(preceding-sibling::Operation[@getter]) or not(preceding-sibling::Operation[@getter]/ArgumentList/Argument[1]/Type/@type=current()/ArgumentList/Argument[1]/Type/@type)"><value-of select="concat(local-name(parent::*),' ',parent::*/@name)" /> defines more than one index getter.</assert>
	 <assert test="not(@getter) or not(ArgumentList/Argument[1]/Type/@type='DOMString') or not(preceding-sibling::Operation[@getter]) or not(preceding-sibling::Operation[@getter]/ArgumentList/Argument[1]/Type/@type=current()/ArgumentList/Argument[1]/Type/@type)"><value-of select="concat(local-name(parent::*),' ',parent::*/@name)" /> defines more than one name getter.</assert>
	 <assert test="not(@deleter) or not(ArgumentList/Argument[1]/Type/@type='unsigned long') or not(preceding-sibling::Operation[@deleter]) or not(preceding-sibling::Operation[@deleter]/ArgumentList/Argument[1]/Type/@type=current()/ArgumentList/Argument[1]/Type/@type)"><value-of select="concat(local-name(parent::*),' ',parent::*/@name)" /> defines more than one index deleter.</assert>
	 <assert test="not(@deleter) or not(ArgumentList/Argument[1]/Type/@type='DOMString') or not(preceding-sibling::Operation[@deleter]) or not(preceding-sibling::Operation[@deleter]/ArgumentList/Argument[1]/Type/@type=current()/ArgumentList/Argument[1]/Type/@type)"><value-of select="concat(local-name(parent::*),' ',parent::*/@name)" /> defines more than one name deleter.</assert>
	 <assert test="not(@setter) or not(ArgumentList/Argument[1]/Type/@type='unsigned long') or not(preceding-sibling::Operation[@setter]) or not(preceding-sibling::Operation[@setter]/ArgumentList/Argument[1]/Type/@type=current()/ArgumentList/Argument[1]/Type/@type)"><value-of select="concat(local-name(parent::*),' ',parent::*/@name)" /> defines more than one index setter.</assert>
	 <assert test="not(@setter) or not(ArgumentList/Argument[1]/Type/@type='DOMString') or not(preceding-sibling::Operation[@setter]) or not(preceding-sibling::Operation[@setter]/ArgumentList/Argument[1]/Type/@type=current()/ArgumentList/Argument[1]/Type/@type)"><value-of select="concat(local-name(parent::*),' ',parent::*/@name)" /> defines more than one name setter.</assert>
	 <assert test="not(@creator) or not(ArgumentList/Argument[1]/Type/@type='unsigned long') or not(preceding-sibling::Operation[@creator]) or not(preceding-sibling::Operation[@creator]/ArgumentList/Argument[1]/Type/@type=current()/ArgumentList/Argument[1]/Type/@type)"><value-of select="concat(local-name(parent::*),' ',parent::*/@name)" /> defines more than one index creator.</assert>
	 <assert test="not(@creator) or not(ArgumentList/Argument[1]/Type/@type='DOMString') or not(preceding-sibling::Operation[@creator]) or not(preceding-sibling::Operation[@creator]/ArgumentList/Argument[1]/Type/@type=current()/ArgumentList/Argument[1]/Type/@type)"><value-of select="concat(local-name(parent::*),' ',parent::*/@name)" /> defines more than one name creator.</assert>
	 <assert test="not(ArgumentList/Argument/@ellipsis)"><value-of select="concat(local-name(parent::*),' ',parent::*/@name)" /> defines a special operation that is variadic.</assert>
	 <assert test="not(ArgumentList/Argument/@optional)"><value-of select="concat(local-name(parent::*),' ',parent::*/@name)" /> defines a special operation with optional arguments.</assert>
	 <assert test="not(@stringifier) or not(ArgumentList/Argument)"><value-of select="concat(local-name(parent::*),' ',parent::*/@name)" /> defines a stringifier operation with arguments.</assert>
	 <assert test="not(@stringifier) or Type/@type='DOMString'"><value-of select="concat(local-name(parent::*),' ',parent::*/@name)" /> defines a stringifier operation with a return type that is not a DOMString.</assert>
	 <assert test="not(@getter) or count(ArgumentList/Argument)=1"><value-of select="concat(local-name(parent::*),' ',parent::*/@name)" /> defines a getter operation that doesn't take a single argument.</assert>
	 <assert test="not(@deleter) or count(ArgumentList/Argument)=1"><value-of select="concat(local-name(parent::*),' ',parent::*/@name)" /> defines a deleter operation that doesn't take a single argument.</assert>
	 <assert test="not(@setter) or count(ArgumentList/Argument)=2"><value-of select="concat(local-name(parent::*),' ',parent::*/@name)" /> defines a setter operation that doesn't take exactly two arguments.</assert>
	 <assert test="not(@creator) or count(ArgumentList/Argument)=2"><value-of select="concat(local-name(parent::*),' ',parent::*/@name)" /> defines a creator operation that doesn't take exactly two arguments.</assert>
	 <assert test="not(@getter) or ArgumentList/Argument[1]/Type/@type='DOMString' or ArgumentList/Argument[1]/Type/@type='unsigned long'"><value-of select="concat(local-name(parent::*),' ',parent::*/@name)" /> defines a getter operation with first argument different from DOMString and unsigned long.</assert>
	 <assert test="not(@setter) or ArgumentList/Argument[1]/Type/@type='DOMString' or ArgumentList/Argument[1]/Type/@type='unsigned long'"><value-of select="concat(local-name(parent::*),' ',parent::*/@name)" /> defines a setter operation with first argument different from DOMString and unsigned long.</assert>
	 <assert test="not(@deleter) or ArgumentList/Argument[1]/Type/@type='DOMString' or ArgumentList/Argument[1]/Type/@type='unsigned long'"><value-of select="concat(local-name(parent::*),' ',parent::*/@name)" /> defines a deleter operation with first argument different from DOMString and unsigned long.</assert>
	 <assert test="not(@creator) or ArgumentList/Argument[1]/Type/@type='DOMString' or ArgumentList/Argument[1]/Type/@type='unsigned long'"><value-of select="concat(local-name(parent::*),' ',parent::*/@name)" /> defines a creator operation with first argument different from DOMString and unsigned long.</assert>
       </rule>
     </pattern>
     <pattern>
       <title>Stringifier attributes</title>
       <rule context="//Attribute[@stringifier]">
	 <assert test="Type/@type='DOMString'"><value-of select="concat(local-name(parent::*),' ',parent::*/@name)" /> defines a stringifier attribute that is not of type DOMString.</assert>
	 <assert test="not(preceding-sibling::*[@stringifier])"><value-of select="concat(local-name(parent::*),' ',parent::*/@name)" /> defines more than one stringifier.</assert>
       </rule>
     </pattern>
     <pattern>
       <title>Overloading</title>
     </pattern>
     <pattern>
       <title>Extended attributes are well-known</title>
       <rule context="//ExtendedAttribute[@name]">
	 <assert see="http://dev.w3.org/2006/webapi/WebIDL/#es-extended-attributes" test="@name='Prefix' or @name='AllowAny' or @name='Callback' or @name='Constructor' or @name='NamedConstructor' or @name='NamespaceObject' or @name='NoInterfaceObject' or @name='OverrideBuiltins' or @name='PrototypeRoot' or @name='PutForwards' or @name='Replaceable' or @name='TreatNullAs' or @name='TreatUndefinedAs' or @name='Clamp'">Extended attribute of <value-of select="@name"/> is unknown in WebIDL.</assert>
       </rule>
     </pattern>
     <pattern>
       <title>Extended attribute common abstract rules</title>
       <rule  id="extendedAttributeAppliesToInterface" abstract="true">
	 <assert test="parent::ExtendedAttributeList/parent::Interface">Extended attribute <value-of select="@name"/> used on <value-of select="local-name(parent::ExtendedAttributeList/parent::*)" /> — <value-of select="@name"/> expected only on interfaces.</assert>	 
       </rule>
       <rule  name="Extended attribute takes no argument" id="extendedAttributeNoArg" abstract="true">
	 <assert test="not(@value)">Extended attribute <value-of select="@name"/> used with arguments on <value-of select="concat(local-name(parent::ExtendedAttributeList/parent::*),' ',parent::ExtendedAttributeList/parent::*/@name)"/>.</assert>
       </rule>
       <rule name="Extended attribute cannot be used on an interface that inherits from another" id="extendedAttributeNotWithInheritance" abstract="true">
	 <assert test="not(parent::ExtendedAttributeList/parent::Interface/InterfaceInheritance)">The interface <value-of select="parent::ExtendedAttributeList/parent::Interface/@name"/> has extended attribute <value-of select="@name"/> but inherits from another interface (<value-of select="parent::ExtendedAttributeList/parent::Interface/InterfaceInheritance/Name/@name"/>).</assert>
       </rule>
       <rule name="Extended attribute can only be used on attribute" abstract="true" id="extendedAttributeAppliesToAttribute">
	 <assert test="parent::ExtendedAttributeList/parent::Attribute">Extended attribute <value-of select="@name"/> used on <value-of select="local-name(parent::ExtendedAttributeList/parent::*)" /> — <value-of select="@name"/> expected only on attributes.</assert>
       </rule>
       <rule name="Extended attribute can only be used on read-only attribute" abstract="true" id="extendedAttributeAppliesToReadonlyAttribute">
	 <assert test="parent::ExtendedAttributeList/parent::Attribute">Extended attribute <value-of select="@name"/> used on <value-of select="local-name(parent::ExtendedAttributeList/parent::*)" /> — <value-of select="@name"/> expected only on attributes.</assert>
	 <assert test="not(parent::ExtendedAttributeList/parent::Attribute) or parent::ExtendedAttributeList/parent::Attribute[@readonly='readonly']">Extended attribute <value-of select="@name"/> used on non-readonly attribute <value-of select="ancestor::Interface/@name" />.<value-of select="parent::ExtendedAttributeList/parent::Attribute/@name" /> — <value-of select="@name"/> expected only on readonly attributes.</assert>
       </rule>

     </pattern>
     <pattern>
       <title>Extended attribute Callback</title>
       <rule context="//ExtendedAttribute[@name='Callback']">
	 <extends rule="extendedAttributeAppliesToInterface"/>
	 <assert see="http://dev.w3.org/2006/webapi/WebIDL/#Callback" test="not(@value) or @value='FunctionOnly' or @value='PropertyOnly'">Extended attribute Callback used on <value-of select="parent::ExtendedAttributeList/parent::Interface/@name" /> uses an unknown argument <value-of select="@value"/>.</assert>
	 <extends see="http://dev.w3.org/2006/webapi/WebIDL/#native-objects" rule="extendedAttributeNotWithInheritance"/>
	 <assert see="http://dev.w3.org/2006/webapi/WebIDL/#native-objects" test="not(parent::ExtendedAttributeList/ExtendedAttribute[@name='Constructor' or @name='NamedConstructor'])">The interface <value-of select="parent::ExtendedAttributeList/parent::Interface/@name"/> has both extended attributes Callback and <value-of select="parent::ExtendedAttributeList/ExtendedAttribute[@name='Constructor' or @name='NamedConstructor']/@name"/>).</assert>
	 <assert see="http://dev.w3.org/2006/webapi/WebIDL/#native-objects" test="not(parent::ExtendedAttributeList/parent::Interface/Operation[@getter or @setter or @creator or @deleter or @caller or @stringifier])">The interface <value-of select="parent::ExtendedAttributeList/parent::Interface/@name"/> has a Callback extended attribute, but offers a either  getters, setters, creators, deleters, caller or stringifier.</assert>
	 <!-- @@@ widlproc doesn't show extended attributes on attributes ? -->
	 <assert see="http://dev.w3.org/2006/webapi/WebIDL/#native-objects" test="not(parent::ExtendedAttributeList/parent::Interface/Attribute[ExtendedAttributeList/ExtendedAttribute[@name='PutForwards' or @name='TreatNullAs' or @name='TreatUndefinedAs']])">The interface <value-of select="parent::ExtendedAttributeList/parent::Interface/@name"/> has a Callback extended attribute, but exposes an attribute with a <value-of select="parent::ExtendedAttributeList/parent::Interface/Attribute/ExtendedAttributeList/ExtendedAttribute[@name='PutForwards' or @name='TreatNullAs' or @name='TreatUndefinedAs']/@name"/> extended attribute.</assert>
	 <assert see="http://dev.w3.org/2006/webapi/WebIDL/#Callback" test="not(@value and parent::ExtendedAttributeList/parent::Interface/Attribute)">The interface <value-of select="parent::ExtendedAttributeList/parent::Interface/@name"/> uses a Callback extended attribute with an argument, but exposes at least one attribute.</assert>
	 <let name="firstOperationName" value="parent::ExtendedAttributeList/parent::Interface/Operation[1]/@name"/>
	 <assert see="http://dev.w3.org/2006/webapi/WebIDL/#Callback" test="not(@value) or (count(parent::ExtendedAttributeList/parent::Interface/Operation[@name!=$firstOperationName])=0 and $firstOperationName)">The interface <value-of select="parent::ExtendedAttributeList/parent::Interface/@name"/> uses a Callback extended attribute with an argument, but exposes zero or multiple operations with different identifiers.</assert>
       </rule>
     </pattern>
     <pattern>
       <title>Extended attribute Constructor</title>
       <rule context="//ExtendedAttribute[@name='Constructor']">
	 <extends rule="extendedAttributeAppliesToInterface"/>
       </rule>
     </pattern>
     <pattern>
       <title>Extended attribute NamedConstructor</title>
       <rule context="//ExtendedAttribute[@name='NamedConstructor']">
	 <extends rule="extendedAttributeAppliesToInterface"/>
	 <!-- @@@ The NamedConstructor clash checks should be done across all well-known IDLs -->
	 <assert  see="http://dev.w3.org/2006/webapi/WebIDL/#NamedConstructor" test="not(parent::ExtendedAttributeList/parent::Interface/preceding::Interface/ExtendedAttributeList/ExtendedAttribute[@name='NamedConstructor' and @value=current()/@value])">Extended attribute NamedConstructor with identifier <value-of select="@value"/> in <value-of select="parent::ExtendedAttributeList/parent::Interface/@name"/> interface clashes with NamedConstructor on interface <value-of select="parent::ExtendedAttributeList/parent::Interface/preceding::Interface[ExtendedAttributeList/ExtendedAttribute[@name='NamedConstructor' and @value=current()/@value]]/@name"/>.</assert> 
	 <assert  see="http://dev.w3.org/2006/webapi/WebIDL/#NamedConstructor" test="not($standards//Interface/ExtendedAttributeList/ExtendedAttribute[@name='NamedConstructor' and @value=current()/@value])">Extended attribute NamedConstructor with identifier <value-of select="@value"/> in <value-of select="parent::ExtendedAttributeList/parent::Interface/@name"/> interface clashes with NamedConstructor on externally defined interface <value-of select="$standards//Interface[ExtendedAttributeList/ExtendedAttribute[@name='NamedConstructor' and @value=current()/@value]]/@name"/>.</assert> 

	 <assert  see="http://dev.w3.org/2006/webapi/WebIDL/#NamedConstructor" test="not(parent::ExtendedAttributeList/parent::Interface/preceding::Interface[not(ExtendedAttributeList/ExtendedAttribute[@name='NoInterfaceObject'])][@name=current()/@value])">Extended attribute NamedConstructor with identifier <value-of select="@value"/> in <value-of select="parent::ExtendedAttributeList/parent::Interface/@name"/> interface clashes with  interface <value-of select="parent::ExtendedAttributeList/parent::Interface/preceding::Interface[not(ExtendedAttributeList/ExtendedAttribute[@name='NoInterfaceObject'])][@name=current()/@value]/@name"/>.</assert> 
	 <assert  see="http://dev.w3.org/2006/webapi/WebIDL/#NamedConstructor" test="not($standards//Interface[not(ExtendedAttributeList/ExtendedAttribute[@name='NoInterfaceObject'])][@name=current()/@value])">Extended attribute NamedConstructor with identifier <value-of select="@value"/> in <value-of select="parent::ExtendedAttributeList/parent::Interface/@name"/> interface clashes with externally defined interface <value-of select="$standards//Interface[not(ExtendedAttributeList/ExtendedAttribute[@name='NoInterfaceObject'])][@name=current()/@value]/@name"/>.</assert> 


	 <assert  see="http://dev.w3.org/2006/webapi/WebIDL/#NamedConstructor" test="not(parent::ExtendedAttributeList/parent::Interface/preceding::Exception[not(ExtendedAttributeList/ExtendedAttribute[@name='NoInterfaceObject'])][@name=current()/@value])">Extended attribute NamedConstructor with identifier <value-of select="@value"/> in <value-of select="parent::ExtendedAttributeList/parent::Interface/@name"/> interface clashes with exception interface <value-of select="parent::ExtendedAttributeList/parent::Interface/preceding::Exception[not(ExtendedAttributeList/ExtendedAttribute[@name='NoInterfaceObject'])][@name=current()/@value]/@name"/>.</assert> 
	 <assert  see="http://dev.w3.org/2006/webapi/WebIDL/#NamedConstructor" test="not($standards//Exception[not(ExtendedAttributeList/ExtendedAttribute[@name='NoInterfaceObject'])][@name=current()/@value])">Extended attribute NamedConstructor with identifier <value-of select="@value"/> in <value-of select="parent::ExtendedAttributeList/parent::Interface/@name"/> interface clashes with externally defined exception interface <value-of select="$standards//Exception[not(ExtendedAttributeList/ExtendedAttribute[@name='NoInterfaceObject'])][@name=current()/@value]/@name"/>.</assert> 


       </rule>
     </pattern>
     <pattern>
       <title>Extended attribute NamespaceObject</title>
       <rule context="//ExtendedAttribute[@name='NamespaceObject']">
	 <assert see="http://dev.w3.org/2006/webapi/WebIDL/#NamespaceObject" test="parent::ExtendedAttributeList/parent::Module">Extended attribute NamespaceObject used on <value-of select="local-name(parent::ExtendedAttributeList/parent::*)" /> — NamespaceObject expected only on modules.</assert>
	 <extends rule="extendedAttributeNoArg"/>
	 <assert see="http://dev.w3.org/2006/webapi/WebIDL/#NamespaceObject" test="not(parent::ExtendedAttributeList/parent::Module/ancestor::Module[ExtendedAttributeList/ExtendedAttribute[@name='NamespaceObject']])">Extended attribute NamespaceObject used on module <value-of select="parent::ExtendedAttributeList/parent::Module/@name" /> that is included in module <value-of select="parent::ExtendedAttributeList/parent::Module/ancestor::Module[ExtendedAttributeList/ExtendedAttribute[@name='NamespaceObject']]/@name"/> that also has a NamespaceOjbect extended attribute.</assert>
       </rule>
     </pattern>
     <pattern>
       <title>Extended attribute NoInterfaceObject</title>
       <rule context="//ExtendedAttribute[@name='NoInterfaceObject']">
	 <assert see="http://dev.w3.org/2006/webapi/WebIDL/#NoInterfaceObject" test="parent::ExtendedAttributeList/parent::Interface or parent::ExtendedAttributeList/parent::Exception">Extended attribute NoInterfaceObject used on <value-of select="local-name(parent::ExtendedAttributeList/parent::*)" /> — NoInterfaceObject expected only on interfaces and exceptions.</assert>
	 <extends rule="extendedAttributeNoArg"/>
	 <!-- @@@ shouldn't this also apply to NamedConstructor? -->
	 <assert see="http://dev.w3.org/2006/webapi/WebIDL/#NoInterfaceObject" test="not(parent::ExtendedAttributeList/ExtendedAttribute[@name='Constructor'])">Extended attribute NoInterfaceObject used in combination with extended attribute Constructor on interface <value-of select="parent::ExtendedAttributeList/parent::*/@name"/>.</assert>
       </rule>
     </pattern>
     <pattern>
       <title>Extended attribute OverrideBuiltins</title>
       <rule context="//ExtendedAttribute[@name='OverrideBuiltins']">
	 <extends rule="extendedAttributeAppliesToInterface"/>
	 <extends rule="extendedAttributeNoArg"/>
	 <assert see="http://dev.w3.org/2006/webapi/WebIDL/#OverrideBuiltins" test="parent::ExtendedAttributeList/parent::Interface[Operation/@getter]">Extended attribute OverrideBuiltins used on interface <value-of select="parent::ExtendedAttributeList/parent::Interface/@name"/> that does not have a name getter.</assert>
       </rule>
     </pattern>
     <pattern>
       <title>Extended attribute PrototypeRoot</title>
       <rule context="//ExtendedAttribute[@name='PrototypeRoot']">
	 <extends see="http://dev.w3.org/2006/webapi/WebIDL/#PrototypeRoot" rule="extendedAttributeAppliesToInterface"/>
	 <extends see="http://dev.w3.org/2006/webapi/WebIDL/#PrototypeRoot" rule="extendedAttributeNoArg"/>
	 <extends see="http://dev.w3.org/2006/webapi/WebIDL/#PrototypeRoot" rule="extendedAttributeNotWithInheritance"/>
	 <!--<assert see="http://dev.w3.org/2006/webapi/WebIDL/#PrototypeRoot" test="false">Interface <value-of select="parent::ExtendedAttributeList/parent::Interface/@name"/> has multiple heritance paths to <value-of select="'@@@'"/></assert>-->
       </rule>
     </pattern>
     <pattern>
       <title>Extended Attribute PutForwards</title>
       <rule context="//ExtendedAttribute[@name='PutForwards']" >
	 <let name="validObject" value="parent::ExtendedAttributeList/parent::Attribute"/>
	 <extends see="http://dev.w3.org/2006/webapi/WebIDL/#PutForwards" rule="extendedAttributeAppliesToReadonlyAttribute"/>
	 <assert test="@value">Extended attribute <value-of select="@name"/> used without required argument on <value-of select="ancestor::Interface/@name" />.<value-of select="parent::ExtendedAttributeList/parent::Attribute/@name" />.</assert>
	 <let name="linkedInterface" value="parent::ExtendedAttributeList/parent::Attribute/Type/@name"/>
	 <assert see="http://dev.w3.org/2006/webapi/WebIDL/#PutForwards" test="not(@value and $validObject) or //Interface[@name=$linkedInterface]/Attribute[@name=current()/@value] or $standards//Interface[@name=$linkedInterface]/Attribute[@name=current()/@value]">Extended attribute PutForwards used on attribute <value-of select="ancestor::Interface/@name" />.<value-of select="parent::ExtendedAttributeList/parent::Attribute/@name" /> with argument <value-of select="@value"/> does not match a known attribute in <value-of select="$linkedInterface"/> interface.</assert>
	 <!--<assert see="http://dev.w3.org/2006/webapi/WebIDL/#PutForwards" test="false">PutForwards on attribute <value-of select="parent::ExtendedAttributeList/parent::Interface/@name"/>.<value-of select="parent::ExtendedAttributeList/parent::Attribute/@name" /> is creating a cycle</assert>-->
       </rule>
     </pattern>
     <pattern>
       <title>Extended Attribute Replaceable</title>
       <rule context="//ExtendedAttribute[@name='Replaceable']" >
	 <extends rule="extendedAttributeNoArg"/>
	 <extends see="http://dev.w3.org/2006/webapi/WebIDL/#PutForwards" rule="extendedAttributeAppliesToReadonlyAttribute"/>
       </rule>
     </pattern>
     <pattern>
       <title>Extended Attribute TreatNullAs</title>
       <rule context="//ExtendedAttribute[@name='TreatNullAs']">
	 <let name="validObject" value="parent::ExtendedAttributeList/parent::Attribute or parent::ExtendedAttributeList/parent::Argument/parent::ArgumentList/parent::Operation or parent::ExtendedAttributeList/parent::Operation"/>
	 <let name="objectName" value="concat(ancestor::Interface/@name,'.',concat(parent::ExtendedAttributeList/parent::Attribute/@name, parent::ExtendedAttributeList/parent::Argument/parent::ArgumentList/parent::Operation/@name, parent::ExtendedAttributeList/parent::Operation/@name))"/>
	 <assert test="$validObject">Extended attribute <value-of select="@name"/> used on <value-of select="local-name(parent::ExtendedAttributeList/parent::*)" /> — <value-of select="@name"/> expected only on attribute, operation arguments, or operations.</assert>
	 <assert test="not($validObject) or parent::ExtendedAttributeList/parent::*/Type[@type='DOMString' and not(@nullable)]">Extended attribute TreatNullAs used on <value-of select="$objectName" /> applied to type <value-of select="concat(parent::ExtendedAttributeList/parent::*/Type/@type, parent::ExtendedAttributeList/parent::*/Type/@name)"/> — TreatNullAs expected only on attributes, operations or operations arguments with non-nullable DOMString type.</assert>
	 <assert test="not($validObject) or @value='String'">Extended attribute TreatNullAs used on <value-of select="$objectName" /> without required “String” argument.</assert>
       </rule>
     </pattern>
     <pattern>
       <title>Extended Attribute TreatUndefinedAs</title>
       <rule context="//ExtendedAttribute[@name='TreatUndefinedAs']">
	 <let name="validObject" value="parent::ExtendedAttributeList/parent::Attribute or parent::ExtendedAttributeList/parent::Argument/parent::ArgumentList/parent::Operation or parent::ExtendedAttributeList/parent::Operation"/>
	 <let name="objectName" value="concat(ancestor::Interface/@name,'.',concat(parent::ExtendedAttributeList/parent::Attribute/@name, parent::ExtendedAttributeList/parent::Argument/parent::ArgumentList/parent::Operation/@name, parent::ExtendedAttributeList/parent::Operation/@name))"/>
	 <assert test="$validObject">Extended attribute <value-of select="@name"/> used on <value-of select="local-name(parent::ExtendedAttributeList/parent::*)" /> — <value-of select="@name"/> expected only on attribute, operation arguments, or operations.</assert>
	 <assert test="not($validObject) or parent::ExtendedAttributeList/parent::*/Type[@type='DOMString']">Extended attribute TreatUndefinedAs used on <value-of select="$objectName" /> applied to type <value-of select="concat(parent::ExtendedAttributeList/parent::*/Type/@type, parent::ExtendedAttributeList/parent::*/Type/@name)"/> — TreatUndefinedAs expected only on attributes, operations or operations arguments with DOMString or DOMString? type.</assert>
	 <assert test="not($validObject) or (@value='EmptyString' or @value='Null')">Extended attribute TreatUndefinedAs used on <value-of select="$objectName" /> without required “EmptyString” or “Null” argument.</assert>
	 <assert test="not($validObject and parent::ExtendedAttributeList/parent::*/Type[@type='DOMString']) or not(@value='Null') or  (@value='Null' and parent::ExtendedAttributeList/parent::*/Type[@nullable='nullable'])">Extended attribute TreatUndefinedAs used on <value-of select="$objectName" /> with required “Null” argument, but not applied to a DOMString? object.</assert>
       </rule>
     </pattern>

</schema>
