<Module>
<Definitions>
  <Module name="css" id="::css">
    <webidl>module css {

  typedef <ref>dom::Document</ref> Document;
  typedef <ref>dom::Element</ref> Element;
  typedef <ref>dom::DOMImplementation</ref> DOMImplementation;
  typedef <ref>dom::DOMException</ref> DOMException;
  typedef <ref>views::AbstractView</ref> AbstractView;

  interface CSSRuleList {
    readonly attribute unsigned long length;
    getter <ref>CSSRule</ref> item(in unsigned long index);
  };

  [PrototypeRoot]
  interface CSSRule {

    const unsigned short      UNKNOWN_RULE                   = 0;
    const unsigned short      STYLE_RULE                     = 1;
    const unsigned short      CHARSET_RULE                   = 2;
    const unsigned short      IMPORT_RULE                    = 3;
    const unsigned short      MEDIA_RULE                     = 4;
    const unsigned short      FONT_FACE_RULE                 = 5;
    const unsigned short      PAGE_RULE                      = 6;

    readonly attribute unsigned short   type;
             attribute DOMString        cssText setraises(<ref>DOMException</ref>);

    readonly attribute <ref>CSSStyleSheet</ref>    parentStyleSheet;
    readonly attribute <ref>CSSRule</ref>          parentRule;
  };

  interface CSSStyleRule : <ref>CSSRule</ref> {
             attribute DOMString        selectorText setraises(<ref>DOMException</ref>);

    readonly attribute <ref>CSSStyleDeclaration</ref>  style;
  };

  interface CSSMediaRule : <ref>CSSRule</ref> {
    readonly attribute <ref>stylesheets::MediaList</ref>  media;
    readonly attribute <ref>CSSRuleList</ref>      cssRules;
    unsigned long      insertRule(in DOMString rule, 
                                  in unsigned long index)
                                        raises(<ref>DOMException</ref>);
    void               deleteRule(in unsigned long index)
                                        raises(<ref>DOMException</ref>);
  };

  interface CSSFontFaceRule : <ref>CSSRule</ref> {
    readonly attribute <ref>CSSStyleDeclaration</ref>  style;
  };

  interface CSSPageRule : <ref>CSSRule</ref> {
             attribute DOMString        selectorText setraises(<ref>DOMException</ref>);

    readonly attribute <ref>CSSStyleDeclaration</ref>  style;
  };

  interface CSSImportRule : <ref>CSSRule</ref> {
    readonly attribute DOMString        href;
    readonly attribute <ref>stylesheets::MediaList</ref>  media;
    readonly attribute <ref>CSSStyleSheet</ref>    styleSheet;
  };

  interface CSSCharsetRule : <ref>CSSRule</ref> {
             attribute DOMString        encoding setraises(<ref>DOMException</ref>);

  };

  interface CSSUnknownRule : <ref>CSSRule</ref> {
  };

  interface CSSStyleDeclaration {
             attribute DOMString        cssText setraises(<ref>DOMException</ref>);

    DOMString          getPropertyValue(in DOMString propertyName);
    <ref>CSSValue</ref>           getPropertyCSSValue(in DOMString propertyName);
    DOMString          removeProperty(in DOMString propertyName)
                                        raises(<ref>DOMException</ref>);
    DOMString          getPropertyPriority(in DOMString propertyName);
    void               setProperty(in DOMString propertyName, 
                                   in DOMString value, 
                                   in DOMString? priority)
                                        raises(<ref>DOMException</ref>);
    readonly attribute unsigned long    length;
    getter DOMString item(in unsigned long index);
    readonly attribute <ref>CSSRule</ref>          parentRule;
  };

  [PrototypeRoot]
  interface CSSValue {

    const unsigned short      CSS_INHERIT                    = 0;
    const unsigned short      CSS_PRIMITIVE_VALUE            = 1;
    const unsigned short      CSS_VALUE_LIST                 = 2;
    const unsigned short      CSS_CUSTOM                     = 3;

             attribute DOMString        cssText setraises(<ref>DOMException</ref>);

    readonly attribute unsigned short   cssValueType;
  };

  interface CSSPrimitiveValue : <ref>CSSValue</ref> {

    const unsigned short      CSS_UNKNOWN                    = 0;
    const unsigned short      CSS_NUMBER                     = 1;
    const unsigned short      CSS_PERCENTAGE                 = 2;
    const unsigned short      CSS_EMS                        = 3;
    const unsigned short      CSS_EXS                        = 4;
    const unsigned short      CSS_PX                         = 5;
    const unsigned short      CSS_CM                         = 6;
    const unsigned short      CSS_MM                         = 7;
    const unsigned short      CSS_IN                         = 8;
    const unsigned short      CSS_PT                         = 9;
    const unsigned short      CSS_PC                         = 10;
    const unsigned short      CSS_DEG                        = 11;
    const unsigned short      CSS_RAD                        = 12;
    const unsigned short      CSS_GRAD                       = 13;
    const unsigned short      CSS_MS                         = 14;
    const unsigned short      CSS_S                          = 15;
    const unsigned short      CSS_HZ                         = 16;
    const unsigned short      CSS_KHZ                        = 17;
    const unsigned short      CSS_DIMENSION                  = 18;
    const unsigned short      CSS_STRING                     = 19;
    const unsigned short      CSS_URI                        = 20;
    const unsigned short      CSS_IDENT                      = 21;
    const unsigned short      CSS_ATTR                       = 22;
    const unsigned short      CSS_COUNTER                    = 23;
    const unsigned short      CSS_RECT                       = 24;
    const unsigned short      CSS_RGBCOLOR                   = 25;

    readonly attribute unsigned short   primitiveType;
    void               setFloatValue(in unsigned short unitType, 
                                     in float floatValue)
                                        raises(<ref>DOMException</ref>);
    float              getFloatValue(in unsigned short unitType)
                                        raises(<ref>DOMException</ref>);
    void               setStringValue(in unsigned short stringType, 
                                      in DOMString stringValue)
                                        raises(<ref>DOMException</ref>);
    DOMString          getStringValue()
                                        raises(<ref>DOMException</ref>);
    <ref>Counter</ref>            getCounterValue()
                                        raises(<ref>DOMException</ref>);
    <ref>Rect</ref>               getRectValue()
                                        raises(<ref>DOMException</ref>);
    <ref>RGBColor</ref>           getRGBColorValue()
                                        raises(<ref>DOMException</ref>);
  };

  interface CSSValueList : <ref>CSSValue</ref> {
    readonly attribute unsigned long length;
    getter <ref>CSSValue</ref> item(in unsigned long index);
  };

  interface RGBColor {
    readonly attribute <ref>CSSPrimitiveValue</ref>  red;
    readonly attribute <ref>CSSPrimitiveValue</ref>  green;
    readonly attribute <ref>CSSPrimitiveValue</ref>  blue;
  };

  interface Rect {
    readonly attribute <ref>CSSPrimitiveValue</ref>  top;
    readonly attribute <ref>CSSPrimitiveValue</ref>  right;
    readonly attribute <ref>CSSPrimitiveValue</ref>  bottom;
    readonly attribute <ref>CSSPrimitiveValue</ref>  left;
  };

  interface Counter {
    readonly attribute DOMString        identifier;
    readonly attribute DOMString        listStyle;
    readonly attribute DOMString        separator;
  };

  interface ElementCSSInlineStyle {
    readonly attribute <ref>CSSStyleDeclaration</ref>  style;
  };

  interface CSS2Properties {
             attribute DOMString        azimuth setraises(<ref>DOMException</ref>);

             attribute DOMString        background setraises(<ref>DOMException</ref>);

             attribute DOMString        backgroundAttachment setraises(<ref>DOMException</ref>);

             attribute DOMString        backgroundColor setraises(<ref>DOMException</ref>);

             attribute DOMString        backgroundImage setraises(<ref>DOMException</ref>);

             attribute DOMString        backgroundPosition setraises(<ref>DOMException</ref>);

             attribute DOMString        backgroundRepeat setraises(<ref>DOMException</ref>);

             attribute DOMString        border setraises(<ref>DOMException</ref>);

             attribute DOMString        borderCollapse setraises(<ref>DOMException</ref>);

             attribute DOMString        borderColor setraises(<ref>DOMException</ref>);

             attribute DOMString        borderSpacing setraises(<ref>DOMException</ref>);

             attribute DOMString        borderStyle setraises(<ref>DOMException</ref>);

             attribute DOMString        borderTop setraises(<ref>DOMException</ref>);

             attribute DOMString        borderRight setraises(<ref>DOMException</ref>);

             attribute DOMString        borderBottom setraises(<ref>DOMException</ref>);

             attribute DOMString        borderLeft setraises(<ref>DOMException</ref>);

             attribute DOMString        borderTopColor setraises(<ref>DOMException</ref>);

             attribute DOMString        borderRightColor setraises(<ref>DOMException</ref>);

             attribute DOMString        borderBottomColor setraises(<ref>DOMException</ref>);

             attribute DOMString        borderLeftColor setraises(<ref>DOMException</ref>);

             attribute DOMString        borderTopStyle setraises(<ref>DOMException</ref>);

             attribute DOMString        borderRightStyle setraises(<ref>DOMException</ref>);

             attribute DOMString        borderBottomStyle setraises(<ref>DOMException</ref>);

             attribute DOMString        borderLeftStyle setraises(<ref>DOMException</ref>);

             attribute DOMString        borderTopWidth setraises(<ref>DOMException</ref>);

             attribute DOMString        borderRightWidth setraises(<ref>DOMException</ref>);

             attribute DOMString        borderBottomWidth setraises(<ref>DOMException</ref>);

             attribute DOMString        borderLeftWidth setraises(<ref>DOMException</ref>);

             attribute DOMString        borderWidth setraises(<ref>DOMException</ref>);

             attribute DOMString        bottom setraises(<ref>DOMException</ref>);

             attribute DOMString        captionSide setraises(<ref>DOMException</ref>);

             attribute DOMString        clear setraises(<ref>DOMException</ref>);

             attribute DOMString        clip setraises(<ref>DOMException</ref>);

             attribute DOMString        color setraises(<ref>DOMException</ref>);

             attribute DOMString        content setraises(<ref>DOMException</ref>);

             attribute DOMString        counterIncrement setraises(<ref>DOMException</ref>);

             attribute DOMString        counterReset setraises(<ref>DOMException</ref>);

             attribute DOMString        cue setraises(<ref>DOMException</ref>);

             attribute DOMString        cueAfter setraises(<ref>DOMException</ref>);

             attribute DOMString        cueBefore setraises(<ref>DOMException</ref>);

             attribute DOMString        cursor setraises(<ref>DOMException</ref>);

             attribute DOMString        direction setraises(<ref>DOMException</ref>);

             attribute DOMString        display setraises(<ref>DOMException</ref>);

             attribute DOMString        elevation setraises(<ref>DOMException</ref>);

             attribute DOMString        emptyCells setraises(<ref>DOMException</ref>);

             attribute DOMString        cssFloat setraises(<ref>DOMException</ref>);

             attribute DOMString        font setraises(<ref>DOMException</ref>);

             attribute DOMString        fontFamily setraises(<ref>DOMException</ref>);

             attribute DOMString        fontSize setraises(<ref>DOMException</ref>);

             attribute DOMString        fontSizeAdjust setraises(<ref>DOMException</ref>);

             attribute DOMString        fontStretch setraises(<ref>DOMException</ref>);

             attribute DOMString        fontStyle setraises(<ref>DOMException</ref>);

             attribute DOMString        fontVariant setraises(<ref>DOMException</ref>);

             attribute DOMString        fontWeight setraises(<ref>DOMException</ref>);

             attribute DOMString        height setraises(<ref>DOMException</ref>);

             attribute DOMString        left setraises(<ref>DOMException</ref>);

             attribute DOMString        letterSpacing setraises(<ref>DOMException</ref>);

             attribute DOMString        lineHeight setraises(<ref>DOMException</ref>);

             attribute DOMString        listStyle setraises(<ref>DOMException</ref>);

             attribute DOMString        listStyleImage setraises(<ref>DOMException</ref>);

             attribute DOMString        listStylePosition setraises(<ref>DOMException</ref>);

             attribute DOMString        listStyleType setraises(<ref>DOMException</ref>);

             attribute DOMString        margin setraises(<ref>DOMException</ref>);

             attribute DOMString        marginTop setraises(<ref>DOMException</ref>);

             attribute DOMString        marginRight setraises(<ref>DOMException</ref>);

             attribute DOMString        marginBottom setraises(<ref>DOMException</ref>);

             attribute DOMString        marginLeft setraises(<ref>DOMException</ref>);

             attribute DOMString        markerOffset setraises(<ref>DOMException</ref>);

             attribute DOMString        marks setraises(<ref>DOMException</ref>);

             attribute DOMString        maxHeight setraises(<ref>DOMException</ref>);

             attribute DOMString        maxWidth setraises(<ref>DOMException</ref>);

             attribute DOMString        minHeight setraises(<ref>DOMException</ref>);

             attribute DOMString        minWidth setraises(<ref>DOMException</ref>);

             attribute DOMString        orphans setraises(<ref>DOMException</ref>);

             attribute DOMString        outline setraises(<ref>DOMException</ref>);

             attribute DOMString        outlineColor setraises(<ref>DOMException</ref>);

             attribute DOMString        outlineStyle setraises(<ref>DOMException</ref>);

             attribute DOMString        outlineWidth setraises(<ref>DOMException</ref>);

             attribute DOMString        overflow setraises(<ref>DOMException</ref>);

             attribute DOMString        padding setraises(<ref>DOMException</ref>);

             attribute DOMString        paddingTop setraises(<ref>DOMException</ref>);

             attribute DOMString        paddingRight setraises(<ref>DOMException</ref>);

             attribute DOMString        paddingBottom setraises(<ref>DOMException</ref>);

             attribute DOMString        paddingLeft setraises(<ref>DOMException</ref>);

             attribute DOMString        page setraises(<ref>DOMException</ref>);

             attribute DOMString        pageBreakAfter setraises(<ref>DOMException</ref>);

             attribute DOMString        pageBreakBefore setraises(<ref>DOMException</ref>);

             attribute DOMString        pageBreakInside setraises(<ref>DOMException</ref>);

             attribute DOMString        pause setraises(<ref>DOMException</ref>);

             attribute DOMString        pauseAfter setraises(<ref>DOMException</ref>);

             attribute DOMString        pauseBefore setraises(<ref>DOMException</ref>);

             attribute DOMString        pitch setraises(<ref>DOMException</ref>);

             attribute DOMString        pitchRange setraises(<ref>DOMException</ref>);

             attribute DOMString        playDuring setraises(<ref>DOMException</ref>);

             attribute DOMString        position setraises(<ref>DOMException</ref>);

             attribute DOMString        quotes setraises(<ref>DOMException</ref>);

             attribute DOMString        richness setraises(<ref>DOMException</ref>);

             attribute DOMString        right setraises(<ref>DOMException</ref>);

             attribute DOMString        size setraises(<ref>DOMException</ref>);

             attribute DOMString        speak setraises(<ref>DOMException</ref>);

             attribute DOMString        speakHeader setraises(<ref>DOMException</ref>);

             attribute DOMString        speakNumeral setraises(<ref>DOMException</ref>);

             attribute DOMString        speakPunctuation setraises(<ref>DOMException</ref>);

             attribute DOMString        speechRate setraises(<ref>DOMException</ref>);

             attribute DOMString        stress setraises(<ref>DOMException</ref>);

             attribute DOMString        tableLayout setraises(<ref>DOMException</ref>);

             attribute DOMString        textAlign setraises(<ref>DOMException</ref>);

             attribute DOMString        textDecoration setraises(<ref>DOMException</ref>);

             attribute DOMString        textIndent setraises(<ref>DOMException</ref>);

             attribute DOMString        textShadow setraises(<ref>DOMException</ref>);

             attribute DOMString        textTransform setraises(<ref>DOMException</ref>);

             attribute DOMString        top setraises(<ref>DOMException</ref>);

             attribute DOMString        unicodeBidi setraises(<ref>DOMException</ref>);

             attribute DOMString        verticalAlign setraises(<ref>DOMException</ref>);

             attribute DOMString        visibility setraises(<ref>DOMException</ref>);

             attribute DOMString        voiceFamily setraises(<ref>DOMException</ref>);

             attribute DOMString        volume setraises(<ref>DOMException</ref>);

             attribute DOMString        whiteSpace setraises(<ref>DOMException</ref>);

             attribute DOMString        widows setraises(<ref>DOMException</ref>);

             attribute DOMString        width setraises(<ref>DOMException</ref>);

             attribute DOMString        wordSpacing setraises(<ref>DOMException</ref>);

             attribute DOMString        zIndex setraises(<ref>DOMException</ref>);

  };

  interface CSSStyleSheet : <ref>stylesheets::StyleSheet</ref> {
    readonly attribute <ref>CSSRule</ref>          ownerRule;
    readonly attribute <ref>CSSRuleList</ref>      cssRules;
    unsigned long      insertRule(in DOMString rule, 
                                  in unsigned long index)
                                        raises(<ref>DOMException</ref>);
    void               deleteRule(in unsigned long index)
                                        raises(<ref>DOMException</ref>);
  };

  interface ViewCSS  {
    <ref>CSSStyleDeclaration</ref> getComputedStyle(in <ref>Element</ref> elt, 
                                         in DOMString? pseudoElt);
  };

  <ref>AbstractView</ref> implements <ref>ViewCSS</ref>;

  interface DocumentCSS  {
    <ref>CSSStyleDeclaration</ref> getOverrideStyle(in <ref>Element</ref> elt, 
                                         in DOMString? pseudoElt);
  };

  <ref>Document</ref> implements <ref>DocumentCSS</ref>;

  interface DOMImplementationCSS  {
    <ref>CSSStyleSheet</ref>      createCSSStyleSheet(in DOMString title, 
                                           in DOMString media)
                                        raises(<ref>DOMException</ref>);
  };

  <ref>DOMImplementation</ref> implements <ref>DOMImplementationCSS</ref>;
};</webidl>
    <Typedef name="Document" id="::css::Document">
      <webidl>  typedef <ref>dom::Document</ref> Document;</webidl>
      <Type name="domDocument"/>
    </Typedef>
    <Typedef name="Element" id="::css::Element">
      <webidl>  typedef <ref>dom::Element</ref> Element;</webidl>
      <Type name="domElement"/>
    </Typedef>
    <Typedef name="DOMImplementation" id="::css::DOMImplementation">
      <webidl>  typedef <ref>dom::DOMImplementation</ref> DOMImplementation;</webidl>
      <Type name="domDOMImplementation"/>
    </Typedef>
    <Typedef name="DOMException" id="::css::DOMException">
      <webidl>  typedef <ref>dom::DOMException</ref> DOMException;</webidl>
      <Type name="domDOMException"/>
    </Typedef>
    <Typedef name="AbstractView" id="::css::AbstractView">
      <webidl>  typedef <ref>views::AbstractView</ref> AbstractView;</webidl>
      <Type name="viewsAbstractView"/>
    </Typedef>
    <Interface name="CSSRuleList" id="::css::CSSRuleList">
      <webidl>  interface CSSRuleList {
    readonly attribute unsigned long length;
    getter <ref>CSSRule</ref> item(in unsigned long index);
  };</webidl>
      <Attribute readonly="readonly" name="length" id="::css::CSSRuleList::length">
        <webidl>    readonly attribute unsigned long length;</webidl>
        <Type type="unsigned long"/>
      </Attribute>
      <Operation getter="getter" name="item" id="::css::CSSRuleList::item">
        <webidl>    getter <ref>CSSRule</ref> item(in unsigned long index);</webidl>
        <Type name="CSSRule"/>
        <ArgumentList>
          <Argument in="in" name="index">
            <Type type="unsigned long"/>
          </Argument>
        </ArgumentList>
      </Operation>
    </Interface>
    <Interface name="CSSRule" id="::css::CSSRule">
      <webidl>  [PrototypeRoot]
  interface CSSRule {

    const unsigned short      UNKNOWN_RULE                   = 0;
    const unsigned short      STYLE_RULE                     = 1;
    const unsigned short      CHARSET_RULE                   = 2;
    const unsigned short      IMPORT_RULE                    = 3;
    const unsigned short      MEDIA_RULE                     = 4;
    const unsigned short      FONT_FACE_RULE                 = 5;
    const unsigned short      PAGE_RULE                      = 6;

    readonly attribute unsigned short   type;
             attribute DOMString        cssText setraises(<ref>DOMException</ref>);

    readonly attribute <ref>CSSStyleSheet</ref>    parentStyleSheet;
    readonly attribute <ref>CSSRule</ref>          parentRule;
  };</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="PrototypeRoot"/>
      </ExtendedAttributeList>
      <Const name="UNKNOWN_RULE" value="0" id="::css::CSSRule::UNKNOWN_RULE">
        <webidl>    const unsigned short      UNKNOWN_RULE                   = 0;</webidl>
        <Type type="unsigned short"/>
      </Const>
      <Const name="STYLE_RULE" value="1" id="::css::CSSRule::STYLE_RULE">
        <webidl>    const unsigned short      STYLE_RULE                     = 1;</webidl>
        <Type type="unsigned short"/>
      </Const>
      <Const name="CHARSET_RULE" value="2" id="::css::CSSRule::CHARSET_RULE">
        <webidl>    const unsigned short      CHARSET_RULE                   = 2;</webidl>
        <Type type="unsigned short"/>
      </Const>
      <Const name="IMPORT_RULE" value="3" id="::css::CSSRule::IMPORT_RULE">
        <webidl>    const unsigned short      IMPORT_RULE                    = 3;</webidl>
        <Type type="unsigned short"/>
      </Const>
      <Const name="MEDIA_RULE" value="4" id="::css::CSSRule::MEDIA_RULE">
        <webidl>    const unsigned short      MEDIA_RULE                     = 4;</webidl>
        <Type type="unsigned short"/>
      </Const>
      <Const name="FONT_FACE_RULE" value="5" id="::css::CSSRule::FONT_FACE_RULE">
        <webidl>    const unsigned short      FONT_FACE_RULE                 = 5;</webidl>
        <Type type="unsigned short"/>
      </Const>
      <Const name="PAGE_RULE" value="6" id="::css::CSSRule::PAGE_RULE">
        <webidl>    const unsigned short      PAGE_RULE                      = 6;</webidl>
        <Type type="unsigned short"/>
      </Const>
      <Attribute readonly="readonly" name="type" id="::css::CSSRule::type">
        <webidl>    readonly attribute unsigned short   type;</webidl>
        <Type type="unsigned short"/>
      </Attribute>
      <Attribute name="cssText" id="::css::CSSRule::cssText">
        <webidl>             attribute DOMString        cssText setraises(<ref>DOMException</ref>);</webidl>
        <Type type="DOMString"/>
        <SetRaises>
          <RaiseException name="DOMException"/>
        </SetRaises>
      </Attribute>
      <Attribute readonly="readonly" name="parentStyleSheet" id="::css::CSSRule::parentStyleSheet">
        <webidl>    readonly attribute <ref>CSSStyleSheet</ref>    parentStyleSheet;</webidl>
        <Type name="CSSStyleSheet"/>
      </Attribute>
      <Attribute readonly="readonly" name="parentRule" id="::css::CSSRule::parentRule">
        <webidl>    readonly attribute <ref>CSSRule</ref>          parentRule;</webidl>
        <Type name="CSSRule"/>
      </Attribute>
    </Interface>
    <Interface name="CSSStyleRule" id="::css::CSSStyleRule">
      <webidl>  interface CSSStyleRule : <ref>CSSRule</ref> {
             attribute DOMString        selectorText setraises(<ref>DOMException</ref>);

    readonly attribute <ref>CSSStyleDeclaration</ref>  style;
  };</webidl>
      <InterfaceInheritance>
        <Name name="CSSRule"/>
      </InterfaceInheritance>
      <Attribute name="selectorText" id="::css::CSSStyleRule::selectorText">
        <webidl>             attribute DOMString        selectorText setraises(<ref>DOMException</ref>);</webidl>
        <Type type="DOMString"/>
        <SetRaises>
          <RaiseException name="DOMException"/>
        </SetRaises>
      </Attribute>
      <Attribute readonly="readonly" name="style" id="::css::CSSStyleRule::style">
        <webidl>    readonly attribute <ref>CSSStyleDeclaration</ref>  style;</webidl>
        <Type name="CSSStyleDeclaration"/>
      </Attribute>
    </Interface>
    <Interface name="CSSMediaRule" id="::css::CSSMediaRule">
      <webidl>  interface CSSMediaRule : <ref>CSSRule</ref> {
    readonly attribute <ref>stylesheets::MediaList</ref>  media;
    readonly attribute <ref>CSSRuleList</ref>      cssRules;
    unsigned long      insertRule(in DOMString rule, 
                                  in unsigned long index)
                                        raises(<ref>DOMException</ref>);
    void               deleteRule(in unsigned long index)
                                        raises(<ref>DOMException</ref>);
  };</webidl>
      <InterfaceInheritance>
        <Name name="CSSRule"/>
      </InterfaceInheritance>
      <Attribute readonly="readonly" name="media" id="::css::CSSMediaRule::media">
        <webidl>    readonly attribute <ref>stylesheets::MediaList</ref>  media;</webidl>
        <Type name="stylesheetsMediaList"/>
      </Attribute>
      <Attribute readonly="readonly" name="cssRules" id="::css::CSSMediaRule::cssRules">
        <webidl>    readonly attribute <ref>CSSRuleList</ref>      cssRules;</webidl>
        <Type name="CSSRuleList"/>
      </Attribute>
      <Operation name="insertRule" id="::css::CSSMediaRule::insertRule">
        <webidl>    unsigned long      insertRule(in DOMString rule, 
                                  in unsigned long index)
                                        raises(<ref>DOMException</ref>);</webidl>
        <Type type="unsigned long"/>
        <ArgumentList>
          <Argument in="in" name="rule">
            <Type type="DOMString"/>
          </Argument>
          <Argument in="in" name="index">
            <Type type="unsigned long"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="DOMException"/>
        </Raises>
      </Operation>
      <Operation name="deleteRule" id="::css::CSSMediaRule::deleteRule">
        <webidl>    void               deleteRule(in unsigned long index)
                                        raises(<ref>DOMException</ref>);</webidl>
        <Type type="void"/>
        <ArgumentList>
          <Argument in="in" name="index">
            <Type type="unsigned long"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="DOMException"/>
        </Raises>
      </Operation>
    </Interface>
    <Interface name="CSSFontFaceRule" id="::css::CSSFontFaceRule">
      <webidl>  interface CSSFontFaceRule : <ref>CSSRule</ref> {
    readonly attribute <ref>CSSStyleDeclaration</ref>  style;
  };</webidl>
      <InterfaceInheritance>
        <Name name="CSSRule"/>
      </InterfaceInheritance>
      <Attribute readonly="readonly" name="style" id="::css::CSSFontFaceRule::style">
        <webidl>    readonly attribute <ref>CSSStyleDeclaration</ref>  style;</webidl>
        <Type name="CSSStyleDeclaration"/>
      </Attribute>
    </Interface>
    <Interface name="CSSPageRule" id="::css::CSSPageRule">
      <webidl>  interface CSSPageRule : <ref>CSSRule</ref> {
             attribute DOMString        selectorText setraises(<ref>DOMException</ref>);

    readonly attribute <ref>CSSStyleDeclaration</ref>  style;
  };</webidl>
      <InterfaceInheritance>
        <Name name="CSSRule"/>
      </InterfaceInheritance>
      <Attribute name="selectorText" id="::css::CSSPageRule::selectorText">
        <webidl>             attribute DOMString        selectorText setraises(<ref>DOMException</ref>);</webidl>
        <Type type="DOMString"/>
        <SetRaises>
          <RaiseException name="DOMException"/>
        </SetRaises>
      </Attribute>
      <Attribute readonly="readonly" name="style" id="::css::CSSPageRule::style">
        <webidl>    readonly attribute <ref>CSSStyleDeclaration</ref>  style;</webidl>
        <Type name="CSSStyleDeclaration"/>
      </Attribute>
    </Interface>
    <Interface name="CSSImportRule" id="::css::CSSImportRule">
      <webidl>  interface CSSImportRule : <ref>CSSRule</ref> {
    readonly attribute DOMString        href;
    readonly attribute <ref>stylesheets::MediaList</ref>  media;
    readonly attribute <ref>CSSStyleSheet</ref>    styleSheet;
  };</webidl>
      <InterfaceInheritance>
        <Name name="CSSRule"/>
      </InterfaceInheritance>
      <Attribute readonly="readonly" name="href" id="::css::CSSImportRule::href">
        <webidl>    readonly attribute DOMString        href;</webidl>
        <Type type="DOMString"/>
      </Attribute>
      <Attribute readonly="readonly" name="media" id="::css::CSSImportRule::media">
        <webidl>    readonly attribute <ref>stylesheets::MediaList</ref>  media;</webidl>
        <Type name="stylesheetsMediaList"/>
      </Attribute>
      <Attribute readonly="readonly" name="styleSheet" id="::css::CSSImportRule::styleSheet">
        <webidl>    readonly attribute <ref>CSSStyleSheet</ref>    styleSheet;</webidl>
        <Type name="CSSStyleSheet"/>
      </Attribute>
    </Interface>
    <Interface name="CSSCharsetRule" id="::css::CSSCharsetRule">
      <webidl>  interface CSSCharsetRule : <ref>CSSRule</ref> {
             attribute DOMString        encoding setraises(<ref>DOMException</ref>);

  };</webidl>
      <InterfaceInheritance>
        <Name name="CSSRule"/>
      </InterfaceInheritance>
      <Attribute name="encoding" id="::css::CSSCharsetRule::encoding">
        <webidl>             attribute DOMString        encoding setraises(<ref>DOMException</ref>);</webidl>
        <Type type="DOMString"/>
        <SetRaises>
          <RaiseException name="DOMException"/>
        </SetRaises>
      </Attribute>
    </Interface>
    <Interface name="CSSUnknownRule" id="::css::CSSUnknownRule">
      <webidl>  interface CSSUnknownRule : <ref>CSSRule</ref> {
  };</webidl>
      <InterfaceInheritance>
        <Name name="CSSRule"/>
      </InterfaceInheritance>
    </Interface>
    <Interface name="CSSStyleDeclaration" id="::css::CSSStyleDeclaration">
      <webidl>  interface CSSStyleDeclaration {
             attribute DOMString        cssText setraises(<ref>DOMException</ref>);

    DOMString          getPropertyValue(in DOMString propertyName);
    <ref>CSSValue</ref>           getPropertyCSSValue(in DOMString propertyName);
    DOMString          removeProperty(in DOMString propertyName)
                                        raises(<ref>DOMException</ref>);
    DOMString          getPropertyPriority(in DOMString propertyName);
    void               setProperty(in DOMString propertyName, 
                                   in DOMString value, 
                                   in DOMString? priority)
                                        raises(<ref>DOMException</ref>);
    readonly attribute unsigned long    length;
    getter DOMString item(in unsigned long index);
    readonly attribute <ref>CSSRule</ref>          parentRule;
  };</webidl>
      <Attribute name="cssText" id="::css::CSSStyleDeclaration::cssText">
        <webidl>             attribute DOMString        cssText setraises(<ref>DOMException</ref>);</webidl>
        <Type type="DOMString"/>
        <SetRaises>
          <RaiseException name="DOMException"/>
        </SetRaises>
      </Attribute>
      <Operation name="getPropertyValue" id="::css::CSSStyleDeclaration::getPropertyValue">
        <webidl>    DOMString          getPropertyValue(in DOMString propertyName);</webidl>
        <Type type="DOMString"/>
        <ArgumentList>
          <Argument in="in" name="propertyName">
            <Type type="DOMString"/>
          </Argument>
        </ArgumentList>
      </Operation>
      <Operation name="getPropertyCSSValue" id="::css::CSSStyleDeclaration::getPropertyCSSValue">
        <webidl>    <ref>CSSValue</ref>           getPropertyCSSValue(in DOMString propertyName);</webidl>
        <Type name="CSSValue"/>
        <ArgumentList>
          <Argument in="in" name="propertyName">
            <Type type="DOMString"/>
          </Argument>
        </ArgumentList>
      </Operation>
      <Operation name="removeProperty" id="::css::CSSStyleDeclaration::removeProperty">
        <webidl>    DOMString          removeProperty(in DOMString propertyName)
                                        raises(<ref>DOMException</ref>);</webidl>
        <Type type="DOMString"/>
        <ArgumentList>
          <Argument in="in" name="propertyName">
            <Type type="DOMString"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="DOMException"/>
        </Raises>
      </Operation>
      <Operation name="getPropertyPriority" id="::css::CSSStyleDeclaration::getPropertyPriority">
        <webidl>    DOMString          getPropertyPriority(in DOMString propertyName);</webidl>
        <Type type="DOMString"/>
        <ArgumentList>
          <Argument in="in" name="propertyName">
            <Type type="DOMString"/>
          </Argument>
        </ArgumentList>
      </Operation>
      <Operation name="setProperty" id="::css::CSSStyleDeclaration::setProperty">
        <webidl>    void               setProperty(in DOMString propertyName, 
                                   in DOMString value, 
                                   in DOMString? priority)
                                        raises(<ref>DOMException</ref>);</webidl>
        <Type type="void"/>
        <ArgumentList>
          <Argument in="in" name="propertyName">
            <Type type="DOMString"/>
          </Argument>
          <Argument in="in" name="value">
            <Type type="DOMString"/>
          </Argument>
          <Argument in="in" name="priority">
            <Type type="DOMString" nullable="nullable"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="DOMException"/>
        </Raises>
      </Operation>
      <Attribute readonly="readonly" name="length" id="::css::CSSStyleDeclaration::length">
        <webidl>    readonly attribute unsigned long    length;</webidl>
        <Type type="unsigned long"/>
      </Attribute>
      <Operation getter="getter" name="item" id="::css::CSSStyleDeclaration::item">
        <webidl>    getter DOMString item(in unsigned long index);</webidl>
        <Type type="DOMString"/>
        <ArgumentList>
          <Argument in="in" name="index">
            <Type type="unsigned long"/>
          </Argument>
        </ArgumentList>
      </Operation>
      <Attribute readonly="readonly" name="parentRule" id="::css::CSSStyleDeclaration::parentRule">
        <webidl>    readonly attribute <ref>CSSRule</ref>          parentRule;</webidl>
        <Type name="CSSRule"/>
      </Attribute>
    </Interface>
    <Interface name="CSSValue" id="::css::CSSValue">
      <webidl>  [PrototypeRoot]
  interface CSSValue {

    const unsigned short      CSS_INHERIT                    = 0;
    const unsigned short      CSS_PRIMITIVE_VALUE            = 1;
    const unsigned short      CSS_VALUE_LIST                 = 2;
    const unsigned short      CSS_CUSTOM                     = 3;

             attribute DOMString        cssText setraises(<ref>DOMException</ref>);

    readonly attribute unsigned short   cssValueType;
  };</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="PrototypeRoot"/>
      </ExtendedAttributeList>
      <Const name="CSS_INHERIT" value="0" id="::css::CSSValue::CSS_INHERIT">
        <webidl>    const unsigned short      CSS_INHERIT                    = 0;</webidl>
        <Type type="unsigned short"/>
      </Const>
      <Const name="CSS_PRIMITIVE_VALUE" value="1" id="::css::CSSValue::CSS_PRIMITIVE_VALUE">
        <webidl>    const unsigned short      CSS_PRIMITIVE_VALUE            = 1;</webidl>
        <Type type="unsigned short"/>
      </Const>
      <Const name="CSS_VALUE_LIST" value="2" id="::css::CSSValue::CSS_VALUE_LIST">
        <webidl>    const unsigned short      CSS_VALUE_LIST                 = 2;</webidl>
        <Type type="unsigned short"/>
      </Const>
      <Const name="CSS_CUSTOM" value="3" id="::css::CSSValue::CSS_CUSTOM">
        <webidl>    const unsigned short      CSS_CUSTOM                     = 3;</webidl>
        <Type type="unsigned short"/>
      </Const>
      <Attribute name="cssText" id="::css::CSSValue::cssText">
        <webidl>             attribute DOMString        cssText setraises(<ref>DOMException</ref>);</webidl>
        <Type type="DOMString"/>
        <SetRaises>
          <RaiseException name="DOMException"/>
        </SetRaises>
      </Attribute>
      <Attribute readonly="readonly" name="cssValueType" id="::css::CSSValue::cssValueType">
        <webidl>    readonly attribute unsigned short   cssValueType;</webidl>
        <Type type="unsigned short"/>
      </Attribute>
    </Interface>
    <Interface name="CSSPrimitiveValue" id="::css::CSSPrimitiveValue">
      <webidl>  interface CSSPrimitiveValue : <ref>CSSValue</ref> {

    const unsigned short      CSS_UNKNOWN                    = 0;
    const unsigned short      CSS_NUMBER                     = 1;
    const unsigned short      CSS_PERCENTAGE                 = 2;
    const unsigned short      CSS_EMS                        = 3;
    const unsigned short      CSS_EXS                        = 4;
    const unsigned short      CSS_PX                         = 5;
    const unsigned short      CSS_CM                         = 6;
    const unsigned short      CSS_MM                         = 7;
    const unsigned short      CSS_IN                         = 8;
    const unsigned short      CSS_PT                         = 9;
    const unsigned short      CSS_PC                         = 10;
    const unsigned short      CSS_DEG                        = 11;
    const unsigned short      CSS_RAD                        = 12;
    const unsigned short      CSS_GRAD                       = 13;
    const unsigned short      CSS_MS                         = 14;
    const unsigned short      CSS_S                          = 15;
    const unsigned short      CSS_HZ                         = 16;
    const unsigned short      CSS_KHZ                        = 17;
    const unsigned short      CSS_DIMENSION                  = 18;
    const unsigned short      CSS_STRING                     = 19;
    const unsigned short      CSS_URI                        = 20;
    const unsigned short      CSS_IDENT                      = 21;
    const unsigned short      CSS_ATTR                       = 22;
    const unsigned short      CSS_COUNTER                    = 23;
    const unsigned short      CSS_RECT                       = 24;
    const unsigned short      CSS_RGBCOLOR                   = 25;

    readonly attribute unsigned short   primitiveType;
    void               setFloatValue(in unsigned short unitType, 
                                     in float floatValue)
                                        raises(<ref>DOMException</ref>);
    float              getFloatValue(in unsigned short unitType)
                                        raises(<ref>DOMException</ref>);
    void               setStringValue(in unsigned short stringType, 
                                      in DOMString stringValue)
                                        raises(<ref>DOMException</ref>);
    DOMString          getStringValue()
                                        raises(<ref>DOMException</ref>);
    <ref>Counter</ref>            getCounterValue()
                                        raises(<ref>DOMException</ref>);
    <ref>Rect</ref>               getRectValue()
                                        raises(<ref>DOMException</ref>);
    <ref>RGBColor</ref>           getRGBColorValue()
                                        raises(<ref>DOMException</ref>);
  };</webidl>
      <InterfaceInheritance>
        <Name name="CSSValue"/>
      </InterfaceInheritance>
      <Const name="CSS_UNKNOWN" value="0" id="::css::CSSPrimitiveValue::CSS_UNKNOWN">
        <webidl>    const unsigned short      CSS_UNKNOWN                    = 0;</webidl>
        <Type type="unsigned short"/>
      </Const>
      <Const name="CSS_NUMBER" value="1" id="::css::CSSPrimitiveValue::CSS_NUMBER">
        <webidl>    const unsigned short      CSS_NUMBER                     = 1;</webidl>
        <Type type="unsigned short"/>
      </Const>
      <Const name="CSS_PERCENTAGE" value="2" id="::css::CSSPrimitiveValue::CSS_PERCENTAGE">
        <webidl>    const unsigned short      CSS_PERCENTAGE                 = 2;</webidl>
        <Type type="unsigned short"/>
      </Const>
      <Const name="CSS_EMS" value="3" id="::css::CSSPrimitiveValue::CSS_EMS">
        <webidl>    const unsigned short      CSS_EMS                        = 3;</webidl>
        <Type type="unsigned short"/>
      </Const>
      <Const name="CSS_EXS" value="4" id="::css::CSSPrimitiveValue::CSS_EXS">
        <webidl>    const unsigned short      CSS_EXS                        = 4;</webidl>
        <Type type="unsigned short"/>
      </Const>
      <Const name="CSS_PX" value="5" id="::css::CSSPrimitiveValue::CSS_PX">
        <webidl>    const unsigned short      CSS_PX                         = 5;</webidl>
        <Type type="unsigned short"/>
      </Const>
      <Const name="CSS_CM" value="6" id="::css::CSSPrimitiveValue::CSS_CM">
        <webidl>    const unsigned short      CSS_CM                         = 6;</webidl>
        <Type type="unsigned short"/>
      </Const>
      <Const name="CSS_MM" value="7" id="::css::CSSPrimitiveValue::CSS_MM">
        <webidl>    const unsigned short      CSS_MM                         = 7;</webidl>
        <Type type="unsigned short"/>
      </Const>
      <Const name="CSS_IN" value="8" id="::css::CSSPrimitiveValue::CSS_IN">
        <webidl>    const unsigned short      CSS_IN                         = 8;</webidl>
        <Type type="unsigned short"/>
      </Const>
      <Const name="CSS_PT" value="9" id="::css::CSSPrimitiveValue::CSS_PT">
        <webidl>    const unsigned short      CSS_PT                         = 9;</webidl>
        <Type type="unsigned short"/>
      </Const>
      <Const name="CSS_PC" value="10" id="::css::CSSPrimitiveValue::CSS_PC">
        <webidl>    const unsigned short      CSS_PC                         = 10;</webidl>
        <Type type="unsigned short"/>
      </Const>
      <Const name="CSS_DEG" value="11" id="::css::CSSPrimitiveValue::CSS_DEG">
        <webidl>    const unsigned short      CSS_DEG                        = 11;</webidl>
        <Type type="unsigned short"/>
      </Const>
      <Const name="CSS_RAD" value="12" id="::css::CSSPrimitiveValue::CSS_RAD">
        <webidl>    const unsigned short      CSS_RAD                        = 12;</webidl>
        <Type type="unsigned short"/>
      </Const>
      <Const name="CSS_GRAD" value="13" id="::css::CSSPrimitiveValue::CSS_GRAD">
        <webidl>    const unsigned short      CSS_GRAD                       = 13;</webidl>
        <Type type="unsigned short"/>
      </Const>
      <Const name="CSS_MS" value="14" id="::css::CSSPrimitiveValue::CSS_MS">
        <webidl>    const unsigned short      CSS_MS                         = 14;</webidl>
        <Type type="unsigned short"/>
      </Const>
      <Const name="CSS_S" value="15" id="::css::CSSPrimitiveValue::CSS_S">
        <webidl>    const unsigned short      CSS_S                          = 15;</webidl>
        <Type type="unsigned short"/>
      </Const>
      <Const name="CSS_HZ" value="16" id="::css::CSSPrimitiveValue::CSS_HZ">
        <webidl>    const unsigned short      CSS_HZ                         = 16;</webidl>
        <Type type="unsigned short"/>
      </Const>
      <Const name="CSS_KHZ" value="17" id="::css::CSSPrimitiveValue::CSS_KHZ">
        <webidl>    const unsigned short      CSS_KHZ                        = 17;</webidl>
        <Type type="unsigned short"/>
      </Const>
      <Const name="CSS_DIMENSION" value="18" id="::css::CSSPrimitiveValue::CSS_DIMENSION">
        <webidl>    const unsigned short      CSS_DIMENSION                  = 18;</webidl>
        <Type type="unsigned short"/>
      </Const>
      <Const name="CSS_STRING" value="19" id="::css::CSSPrimitiveValue::CSS_STRING">
        <webidl>    const unsigned short      CSS_STRING                     = 19;</webidl>
        <Type type="unsigned short"/>
      </Const>
      <Const name="CSS_URI" value="20" id="::css::CSSPrimitiveValue::CSS_URI">
        <webidl>    const unsigned short      CSS_URI                        = 20;</webidl>
        <Type type="unsigned short"/>
      </Const>
      <Const name="CSS_IDENT" value="21" id="::css::CSSPrimitiveValue::CSS_IDENT">
        <webidl>    const unsigned short      CSS_IDENT                      = 21;</webidl>
        <Type type="unsigned short"/>
      </Const>
      <Const name="CSS_ATTR" value="22" id="::css::CSSPrimitiveValue::CSS_ATTR">
        <webidl>    const unsigned short      CSS_ATTR                       = 22;</webidl>
        <Type type="unsigned short"/>
      </Const>
      <Const name="CSS_COUNTER" value="23" id="::css::CSSPrimitiveValue::CSS_COUNTER">
        <webidl>    const unsigned short      CSS_COUNTER                    = 23;</webidl>
        <Type type="unsigned short"/>
      </Const>
      <Const name="CSS_RECT" value="24" id="::css::CSSPrimitiveValue::CSS_RECT">
        <webidl>    const unsigned short      CSS_RECT                       = 24;</webidl>
        <Type type="unsigned short"/>
      </Const>
      <Const name="CSS_RGBCOLOR" value="25" id="::css::CSSPrimitiveValue::CSS_RGBCOLOR">
        <webidl>    const unsigned short      CSS_RGBCOLOR                   = 25;</webidl>
        <Type type="unsigned short"/>
      </Const>
      <Attribute readonly="readonly" name="primitiveType" id="::css::CSSPrimitiveValue::primitiveType">
        <webidl>    readonly attribute unsigned short   primitiveType;</webidl>
        <Type type="unsigned short"/>
      </Attribute>
      <Operation name="setFloatValue" id="::css::CSSPrimitiveValue::setFloatValue">
        <webidl>    void               setFloatValue(in unsigned short unitType, 
                                     in float floatValue)
                                        raises(<ref>DOMException</ref>);</webidl>
        <Type type="void"/>
        <ArgumentList>
          <Argument in="in" name="unitType">
            <Type type="unsigned short"/>
          </Argument>
          <Argument in="in" name="floatValue">
            <Type type="float"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="DOMException"/>
        </Raises>
      </Operation>
      <Operation name="getFloatValue" id="::css::CSSPrimitiveValue::getFloatValue">
        <webidl>    float              getFloatValue(in unsigned short unitType)
                                        raises(<ref>DOMException</ref>);</webidl>
        <Type type="float"/>
        <ArgumentList>
          <Argument in="in" name="unitType">
            <Type type="unsigned short"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="DOMException"/>
        </Raises>
      </Operation>
      <Operation name="setStringValue" id="::css::CSSPrimitiveValue::setStringValue">
        <webidl>    void               setStringValue(in unsigned short stringType, 
                                      in DOMString stringValue)
                                        raises(<ref>DOMException</ref>);</webidl>
        <Type type="void"/>
        <ArgumentList>
          <Argument in="in" name="stringType">
            <Type type="unsigned short"/>
          </Argument>
          <Argument in="in" name="stringValue">
            <Type type="DOMString"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="DOMException"/>
        </Raises>
      </Operation>
      <Operation name="getStringValue" id="::css::CSSPrimitiveValue::getStringValue">
        <webidl>    DOMString          getStringValue()
                                        raises(<ref>DOMException</ref>);</webidl>
        <Type type="DOMString"/>
        <ArgumentList/>
        <Raises>
          <RaiseException name="DOMException"/>
        </Raises>
      </Operation>
      <Operation name="getCounterValue" id="::css::CSSPrimitiveValue::getCounterValue">
        <webidl>    <ref>Counter</ref>            getCounterValue()
                                        raises(<ref>DOMException</ref>);</webidl>
        <Type name="Counter"/>
        <ArgumentList/>
        <Raises>
          <RaiseException name="DOMException"/>
        </Raises>
      </Operation>
      <Operation name="getRectValue" id="::css::CSSPrimitiveValue::getRectValue">
        <webidl>    <ref>Rect</ref>               getRectValue()
                                        raises(<ref>DOMException</ref>);</webidl>
        <Type name="Rect"/>
        <ArgumentList/>
        <Raises>
          <RaiseException name="DOMException"/>
        </Raises>
      </Operation>
      <Operation name="getRGBColorValue" id="::css::CSSPrimitiveValue::getRGBColorValue">
        <webidl>    <ref>RGBColor</ref>           getRGBColorValue()
                                        raises(<ref>DOMException</ref>);</webidl>
        <Type name="RGBColor"/>
        <ArgumentList/>
        <Raises>
          <RaiseException name="DOMException"/>
        </Raises>
      </Operation>
    </Interface>
    <Interface name="CSSValueList" id="::css::CSSValueList">
      <webidl>  interface CSSValueList : <ref>CSSValue</ref> {
    readonly attribute unsigned long length;
    getter <ref>CSSValue</ref> item(in unsigned long index);
  };</webidl>
      <InterfaceInheritance>
        <Name name="CSSValue"/>
      </InterfaceInheritance>
      <Attribute readonly="readonly" name="length" id="::css::CSSValueList::length">
        <webidl>    readonly attribute unsigned long length;</webidl>
        <Type type="unsigned long"/>
      </Attribute>
      <Operation getter="getter" name="item" id="::css::CSSValueList::item">
        <webidl>    getter <ref>CSSValue</ref> item(in unsigned long index);</webidl>
        <Type name="CSSValue"/>
        <ArgumentList>
          <Argument in="in" name="index">
            <Type type="unsigned long"/>
          </Argument>
        </ArgumentList>
      </Operation>
    </Interface>
    <Interface name="RGBColor" id="::css::RGBColor">
      <webidl>  interface RGBColor {
    readonly attribute <ref>CSSPrimitiveValue</ref>  red;
    readonly attribute <ref>CSSPrimitiveValue</ref>  green;
    readonly attribute <ref>CSSPrimitiveValue</ref>  blue;
  };</webidl>
      <Attribute readonly="readonly" name="red" id="::css::RGBColor::red">
        <webidl>    readonly attribute <ref>CSSPrimitiveValue</ref>  red;</webidl>
        <Type name="CSSPrimitiveValue"/>
      </Attribute>
      <Attribute readonly="readonly" name="green" id="::css::RGBColor::green">
        <webidl>    readonly attribute <ref>CSSPrimitiveValue</ref>  green;</webidl>
        <Type name="CSSPrimitiveValue"/>
      </Attribute>
      <Attribute readonly="readonly" name="blue" id="::css::RGBColor::blue">
        <webidl>    readonly attribute <ref>CSSPrimitiveValue</ref>  blue;</webidl>
        <Type name="CSSPrimitiveValue"/>
      </Attribute>
    </Interface>
    <Interface name="Rect" id="::css::Rect">
      <webidl>  interface Rect {
    readonly attribute <ref>CSSPrimitiveValue</ref>  top;
    readonly attribute <ref>CSSPrimitiveValue</ref>  right;
    readonly attribute <ref>CSSPrimitiveValue</ref>  bottom;
    readonly attribute <ref>CSSPrimitiveValue</ref>  left;
  };</webidl>
      <Attribute readonly="readonly" name="top" id="::css::Rect::top">
        <webidl>    readonly attribute <ref>CSSPrimitiveValue</ref>  top;</webidl>
        <Type name="CSSPrimitiveValue"/>
      </Attribute>
      <Attribute readonly="readonly" name="right" id="::css::Rect::right">
        <webidl>    readonly attribute <ref>CSSPrimitiveValue</ref>  right;</webidl>
        <Type name="CSSPrimitiveValue"/>
      </Attribute>
      <Attribute readonly="readonly" name="bottom" id="::css::Rect::bottom">
        <webidl>    readonly attribute <ref>CSSPrimitiveValue</ref>  bottom;</webidl>
        <Type name="CSSPrimitiveValue"/>
      </Attribute>
      <Attribute readonly="readonly" name="left" id="::css::Rect::left">
        <webidl>    readonly attribute <ref>CSSPrimitiveValue</ref>  left;</webidl>
        <Type name="CSSPrimitiveValue"/>
      </Attribute>
    </Interface>
    <Interface name="Counter" id="::css::Counter">
      <webidl>  interface Counter {
    readonly attribute DOMString        identifier;
    readonly attribute DOMString        listStyle;
    readonly attribute DOMString        separator;
  };</webidl>
      <Attribute readonly="readonly" name="identifier" id="::css::Counter::identifier">
        <webidl>    readonly attribute DOMString        identifier;</webidl>
        <Type type="DOMString"/>
      </Attribute>
      <Attribute readonly="readonly" name="listStyle" id="::css::Counter::listStyle">
        <webidl>    readonly attribute DOMString        listStyle;</webidl>
        <Type type="DOMString"/>
      </Attribute>
      <Attribute readonly="readonly" name="separator" id="::css::Counter::separator">
        <webidl>    readonly attribute DOMString        separator;</webidl>
        <Type type="DOMString"/>
      </Attribute>
    </Interface>
    <Interface name="ElementCSSInlineStyle" id="::css::ElementCSSInlineStyle">
      <webidl>  interface ElementCSSInlineStyle {
    readonly attribute <ref>CSSStyleDeclaration</ref>  style;
  };</webidl>
      <Attribute readonly="readonly" name="style" id="::css::ElementCSSInlineStyle::style">
        <webidl>    readonly attribute <ref>CSSStyleDeclaration</ref>  style;</webidl>
        <Type name="CSSStyleDeclaration"/>
      </Attribute>
    </Interface>
    <Interface name="CSS2Properties" id="::css::CSS2Properties">
      <webidl>  interface CSS2Properties {
             attribute DOMString        azimuth setraises(<ref>DOMException</ref>);

             attribute DOMString        background setraises(<ref>DOMException</ref>);

             attribute DOMString        backgroundAttachment setraises(<ref>DOMException</ref>);

             attribute DOMString        backgroundColor setraises(<ref>DOMException</ref>);

             attribute DOMString        backgroundImage setraises(<ref>DOMException</ref>);

             attribute DOMString        backgroundPosition setraises(<ref>DOMException</ref>);

             attribute DOMString        backgroundRepeat setraises(<ref>DOMException</ref>);

             attribute DOMString        border setraises(<ref>DOMException</ref>);

             attribute DOMString        borderCollapse setraises(<ref>DOMException</ref>);

             attribute DOMString        borderColor setraises(<ref>DOMException</ref>);

             attribute DOMString        borderSpacing setraises(<ref>DOMException</ref>);

             attribute DOMString        borderStyle setraises(<ref>DOMException</ref>);

             attribute DOMString        borderTop setraises(<ref>DOMException</ref>);

             attribute DOMString        borderRight setraises(<ref>DOMException</ref>);

             attribute DOMString        borderBottom setraises(<ref>DOMException</ref>);

             attribute DOMString        borderLeft setraises(<ref>DOMException</ref>);

             attribute DOMString        borderTopColor setraises(<ref>DOMException</ref>);

             attribute DOMString        borderRightColor setraises(<ref>DOMException</ref>);

             attribute DOMString        borderBottomColor setraises(<ref>DOMException</ref>);

             attribute DOMString        borderLeftColor setraises(<ref>DOMException</ref>);

             attribute DOMString        borderTopStyle setraises(<ref>DOMException</ref>);

             attribute DOMString        borderRightStyle setraises(<ref>DOMException</ref>);

             attribute DOMString        borderBottomStyle setraises(<ref>DOMException</ref>);

             attribute DOMString        borderLeftStyle setraises(<ref>DOMException</ref>);

             attribute DOMString        borderTopWidth setraises(<ref>DOMException</ref>);

             attribute DOMString        borderRightWidth setraises(<ref>DOMException</ref>);

             attribute DOMString        borderBottomWidth setraises(<ref>DOMException</ref>);

             attribute DOMString        borderLeftWidth setraises(<ref>DOMException</ref>);

             attribute DOMString        borderWidth setraises(<ref>DOMException</ref>);

             attribute DOMString        bottom setraises(<ref>DOMException</ref>);

             attribute DOMString        captionSide setraises(<ref>DOMException</ref>);

             attribute DOMString        clear setraises(<ref>DOMException</ref>);

             attribute DOMString        clip setraises(<ref>DOMException</ref>);

             attribute DOMString        color setraises(<ref>DOMException</ref>);

             attribute DOMString        content setraises(<ref>DOMException</ref>);

             attribute DOMString        counterIncrement setraises(<ref>DOMException</ref>);

             attribute DOMString        counterReset setraises(<ref>DOMException</ref>);

             attribute DOMString        cue setraises(<ref>DOMException</ref>);

             attribute DOMString        cueAfter setraises(<ref>DOMException</ref>);

             attribute DOMString        cueBefore setraises(<ref>DOMException</ref>);

             attribute DOMString        cursor setraises(<ref>DOMException</ref>);

             attribute DOMString        direction setraises(<ref>DOMException</ref>);

             attribute DOMString        display setraises(<ref>DOMException</ref>);

             attribute DOMString        elevation setraises(<ref>DOMException</ref>);

             attribute DOMString        emptyCells setraises(<ref>DOMException</ref>);

             attribute DOMString        cssFloat setraises(<ref>DOMException</ref>);

             attribute DOMString        font setraises(<ref>DOMException</ref>);

             attribute DOMString        fontFamily setraises(<ref>DOMException</ref>);

             attribute DOMString        fontSize setraises(<ref>DOMException</ref>);

             attribute DOMString        fontSizeAdjust setraises(<ref>DOMException</ref>);

             attribute DOMString        fontStretch setraises(<ref>DOMException</ref>);

             attribute DOMString        fontStyle setraises(<ref>DOMException</ref>);

             attribute DOMString        fontVariant setraises(<ref>DOMException</ref>);

             attribute DOMString        fontWeight setraises(<ref>DOMException</ref>);

             attribute DOMString        height setraises(<ref>DOMException</ref>);

             attribute DOMString        left setraises(<ref>DOMException</ref>);

             attribute DOMString        letterSpacing setraises(<ref>DOMException</ref>);

             attribute DOMString        lineHeight setraises(<ref>DOMException</ref>);

             attribute DOMString        listStyle setraises(<ref>DOMException</ref>);

             attribute DOMString        listStyleImage setraises(<ref>DOMException</ref>);

             attribute DOMString        listStylePosition setraises(<ref>DOMException</ref>);

             attribute DOMString        listStyleType setraises(<ref>DOMException</ref>);

             attribute DOMString        margin setraises(<ref>DOMException</ref>);

             attribute DOMString        marginTop setraises(<ref>DOMException</ref>);

             attribute DOMString        marginRight setraises(<ref>DOMException</ref>);

             attribute DOMString        marginBottom setraises(<ref>DOMException</ref>);

             attribute DOMString        marginLeft setraises(<ref>DOMException</ref>);

             attribute DOMString        markerOffset setraises(<ref>DOMException</ref>);

             attribute DOMString        marks setraises(<ref>DOMException</ref>);

             attribute DOMString        maxHeight setraises(<ref>DOMException</ref>);

             attribute DOMString        maxWidth setraises(<ref>DOMException</ref>);

             attribute DOMString        minHeight setraises(<ref>DOMException</ref>);

             attribute DOMString        minWidth setraises(<ref>DOMException</ref>);

             attribute DOMString        orphans setraises(<ref>DOMException</ref>);

             attribute DOMString        outline setraises(<ref>DOMException</ref>);

             attribute DOMString        outlineColor setraises(<ref>DOMException</ref>);

             attribute DOMString        outlineStyle setraises(<ref>DOMException</ref>);

             attribute DOMString        outlineWidth setraises(<ref>DOMException</ref>);

             attribute DOMString        overflow setraises(<ref>DOMException</ref>);

             attribute DOMString        padding setraises(<ref>DOMException</ref>);

             attribute DOMString        paddingTop setraises(<ref>DOMException</ref>);

             attribute DOMString        paddingRight setraises(<ref>DOMException</ref>);

             attribute DOMString        paddingBottom setraises(<ref>DOMException</ref>);

             attribute DOMString        paddingLeft setraises(<ref>DOMException</ref>);

             attribute DOMString        page setraises(<ref>DOMException</ref>);

             attribute DOMString        pageBreakAfter setraises(<ref>DOMException</ref>);

             attribute DOMString        pageBreakBefore setraises(<ref>DOMException</ref>);

             attribute DOMString        pageBreakInside setraises(<ref>DOMException</ref>);

             attribute DOMString        pause setraises(<ref>DOMException</ref>);

             attribute DOMString        pauseAfter setraises(<ref>DOMException</ref>);

             attribute DOMString        pauseBefore setraises(<ref>DOMException</ref>);

             attribute DOMString        pitch setraises(<ref>DOMException</ref>);

             attribute DOMString        pitchRange setraises(<ref>DOMException</ref>);

             attribute DOMString        playDuring setraises(<ref>DOMException</ref>);

             attribute DOMString        position setraises(<ref>DOMException</ref>);

             attribute DOMString        quotes setraises(<ref>DOMException</ref>);

             attribute DOMString        richness setraises(<ref>DOMException</ref>);

             attribute DOMString        right setraises(<ref>DOMException</ref>);

             attribute DOMString        size setraises(<ref>DOMException</ref>);

             attribute DOMString        speak setraises(<ref>DOMException</ref>);

             attribute DOMString        speakHeader setraises(<ref>DOMException</ref>);

             attribute DOMString        speakNumeral setraises(<ref>DOMException</ref>);

             attribute DOMString        speakPunctuation setraises(<ref>DOMException</ref>);

             attribute DOMString        speechRate setraises(<ref>DOMException</ref>);

             attribute DOMString        stress setraises(<ref>DOMException</ref>);

             attribute DOMString        tableLayout setraises(<ref>DOMException</ref>);

             attribute DOMString        textAlign setraises(<ref>DOMException</ref>);

             attribute DOMString        textDecoration setraises(<ref>DOMException</ref>);

             attribute DOMString        textIndent setraises(<ref>DOMException</ref>);

             attribute DOMString        textShadow setraises(<ref>DOMException</ref>);

             attribute DOMString        textTransform setraises(<ref>DOMException</ref>);

             attribute DOMString        top setraises(<ref>DOMException</ref>);

             attribute DOMString        unicodeBidi setraises(<ref>DOMException</ref>);

             attribute DOMString        verticalAlign setraises(<ref>DOMException</ref>);

             attribute DOMString        visibility setraises(<ref>DOMException</ref>);

             attribute DOMString        voiceFamily setraises(<ref>DOMException</ref>);

             attribute DOMString        volume setraises(<ref>DOMException</ref>);

             attribute DOMString        whiteSpace setraises(<ref>DOMException</ref>);

             attribute DOMString        widows setraises(<ref>DOMException</ref>);

             attribute DOMString        width setraises(<ref>DOMException</ref>);

             attribute DOMString        wordSpacing setraises(<ref>DOMException</ref>);

             attribute DOMString        zIndex setraises(<ref>DOMException</ref>);

  };</webidl>
      <Attribute name="azimuth" id="::css::CSS2Properties::azimuth">
        <webidl>             attribute DOMString        azimuth setraises(<ref>DOMException</ref>);</webidl>
        <Type type="DOMString"/>
        <SetRaises>
          <RaiseException name="DOMException"/>
        </SetRaises>
      </Attribute>
      <Attribute name="background" id="::css::CSS2Properties::background">
        <webidl>             attribute DOMString        background setraises(<ref>DOMException</ref>);</webidl>
        <Type type="DOMString"/>
        <SetRaises>
          <RaiseException name="DOMException"/>
        </SetRaises>
      </Attribute>
      <Attribute name="backgroundAttachment" id="::css::CSS2Properties::backgroundAttachment">
        <webidl>             attribute DOMString        backgroundAttachment setraises(<ref>DOMException</ref>);</webidl>
        <Type type="DOMString"/>
        <SetRaises>
          <RaiseException name="DOMException"/>
        </SetRaises>
      </Attribute>
      <Attribute name="backgroundColor" id="::css::CSS2Properties::backgroundColor">
        <webidl>             attribute DOMString        backgroundColor setraises(<ref>DOMException</ref>);</webidl>
        <Type type="DOMString"/>
        <SetRaises>
          <RaiseException name="DOMException"/>
        </SetRaises>
      </Attribute>
      <Attribute name="backgroundImage" id="::css::CSS2Properties::backgroundImage">
        <webidl>             attribute DOMString        backgroundImage setraises(<ref>DOMException</ref>);</webidl>
        <Type type="DOMString"/>
        <SetRaises>
          <RaiseException name="DOMException"/>
        </SetRaises>
      </Attribute>
      <Attribute name="backgroundPosition" id="::css::CSS2Properties::backgroundPosition">
        <webidl>             attribute DOMString        backgroundPosition setraises(<ref>DOMException</ref>);</webidl>
        <Type type="DOMString"/>
        <SetRaises>
          <RaiseException name="DOMException"/>
        </SetRaises>
      </Attribute>
      <Attribute name="backgroundRepeat" id="::css::CSS2Properties::backgroundRepeat">
        <webidl>             attribute DOMString        backgroundRepeat setraises(<ref>DOMException</ref>);</webidl>
        <Type type="DOMString"/>
        <SetRaises>
          <RaiseException name="DOMException"/>
        </SetRaises>
      </Attribute>
      <Attribute name="border" id="::css::CSS2Properties::border">
        <webidl>             attribute DOMString        border setraises(<ref>DOMException</ref>);</webidl>
        <Type type="DOMString"/>
        <SetRaises>
          <RaiseException name="DOMException"/>
        </SetRaises>
      </Attribute>
      <Attribute name="borderCollapse" id="::css::CSS2Properties::borderCollapse">
        <webidl>             attribute DOMString        borderCollapse setraises(<ref>DOMException</ref>);</webidl>
        <Type type="DOMString"/>
        <SetRaises>
          <RaiseException name="DOMException"/>
        </SetRaises>
      </Attribute>
      <Attribute name="borderColor" id="::css::CSS2Properties::borderColor">
        <webidl>             attribute DOMString        borderColor setraises(<ref>DOMException</ref>);</webidl>
        <Type type="DOMString"/>
        <SetRaises>
          <RaiseException name="DOMException"/>
        </SetRaises>
      </Attribute>
      <Attribute name="borderSpacing" id="::css::CSS2Properties::borderSpacing">
        <webidl>             attribute DOMString        borderSpacing setraises(<ref>DOMException</ref>);</webidl>
        <Type type="DOMString"/>
        <SetRaises>
          <RaiseException name="DOMException"/>
        </SetRaises>
      </Attribute>
      <Attribute name="borderStyle" id="::css::CSS2Properties::borderStyle">
        <webidl>             attribute DOMString        borderStyle setraises(<ref>DOMException</ref>);</webidl>
        <Type type="DOMString"/>
        <SetRaises>
          <RaiseException name="DOMException"/>
        </SetRaises>
      </Attribute>
      <Attribute name="borderTop" id="::css::CSS2Properties::borderTop">
        <webidl>             attribute DOMString        borderTop setraises(<ref>DOMException</ref>);</webidl>
        <Type type="DOMString"/>
        <SetRaises>
          <RaiseException name="DOMException"/>
        </SetRaises>
      </Attribute>
      <Attribute name="borderRight" id="::css::CSS2Properties::borderRight">
        <webidl>             attribute DOMString        borderRight setraises(<ref>DOMException</ref>);</webidl>
        <Type type="DOMString"/>
        <SetRaises>
          <RaiseException name="DOMException"/>
        </SetRaises>
      </Attribute>
      <Attribute name="borderBottom" id="::css::CSS2Properties::borderBottom">
        <webidl>             attribute DOMString        borderBottom setraises(<ref>DOMException</ref>);</webidl>
        <Type type="DOMString"/>
        <SetRaises>
          <RaiseException name="DOMException"/>
        </SetRaises>
      </Attribute>
      <Attribute name="borderLeft" id="::css::CSS2Properties::borderLeft">
        <webidl>             attribute DOMString        borderLeft setraises(<ref>DOMException</ref>);</webidl>
        <Type type="DOMString"/>
        <SetRaises>
          <RaiseException name="DOMException"/>
        </SetRaises>
      </Attribute>
      <Attribute name="borderTopColor" id="::css::CSS2Properties::borderTopColor">
        <webidl>             attribute DOMString        borderTopColor setraises(<ref>DOMException</ref>);</webidl>
        <Type type="DOMString"/>
        <SetRaises>
          <RaiseException name="DOMException"/>
        </SetRaises>
      </Attribute>
      <Attribute name="borderRightColor" id="::css::CSS2Properties::borderRightColor">
        <webidl>             attribute DOMString        borderRightColor setraises(<ref>DOMException</ref>);</webidl>
        <Type type="DOMString"/>
        <SetRaises>
          <RaiseException name="DOMException"/>
        </SetRaises>
      </Attribute>
      <Attribute name="borderBottomColor" id="::css::CSS2Properties::borderBottomColor">
        <webidl>             attribute DOMString        borderBottomColor setraises(<ref>DOMException</ref>);</webidl>
        <Type type="DOMString"/>
        <SetRaises>
          <RaiseException name="DOMException"/>
        </SetRaises>
      </Attribute>
      <Attribute name="borderLeftColor" id="::css::CSS2Properties::borderLeftColor">
        <webidl>             attribute DOMString        borderLeftColor setraises(<ref>DOMException</ref>);</webidl>
        <Type type="DOMString"/>
        <SetRaises>
          <RaiseException name="DOMException"/>
        </SetRaises>
      </Attribute>
      <Attribute name="borderTopStyle" id="::css::CSS2Properties::borderTopStyle">
        <webidl>             attribute DOMString        borderTopStyle setraises(<ref>DOMException</ref>);</webidl>
        <Type type="DOMString"/>
        <SetRaises>
          <RaiseException name="DOMException"/>
        </SetRaises>
      </Attribute>
      <Attribute name="borderRightStyle" id="::css::CSS2Properties::borderRightStyle">
        <webidl>             attribute DOMString        borderRightStyle setraises(<ref>DOMException</ref>);</webidl>
        <Type type="DOMString"/>
        <SetRaises>
          <RaiseException name="DOMException"/>
        </SetRaises>
      </Attribute>
      <Attribute name="borderBottomStyle" id="::css::CSS2Properties::borderBottomStyle">
        <webidl>             attribute DOMString        borderBottomStyle setraises(<ref>DOMException</ref>);</webidl>
        <Type type="DOMString"/>
        <SetRaises>
          <RaiseException name="DOMException"/>
        </SetRaises>
      </Attribute>
      <Attribute name="borderLeftStyle" id="::css::CSS2Properties::borderLeftStyle">
        <webidl>             attribute DOMString        borderLeftStyle setraises(<ref>DOMException</ref>);</webidl>
        <Type type="DOMString"/>
        <SetRaises>
          <RaiseException name="DOMException"/>
        </SetRaises>
      </Attribute>
      <Attribute name="borderTopWidth" id="::css::CSS2Properties::borderTopWidth">
        <webidl>             attribute DOMString        borderTopWidth setraises(<ref>DOMException</ref>);</webidl>
        <Type type="DOMString"/>
        <SetRaises>
          <RaiseException name="DOMException"/>
        </SetRaises>
      </Attribute>
      <Attribute name="borderRightWidth" id="::css::CSS2Properties::borderRightWidth">
        <webidl>             attribute DOMString        borderRightWidth setraises(<ref>DOMException</ref>);</webidl>
        <Type type="DOMString"/>
        <SetRaises>
          <RaiseException name="DOMException"/>
        </SetRaises>
      </Attribute>
      <Attribute name="borderBottomWidth" id="::css::CSS2Properties::borderBottomWidth">
        <webidl>             attribute DOMString        borderBottomWidth setraises(<ref>DOMException</ref>);</webidl>
        <Type type="DOMString"/>
        <SetRaises>
          <RaiseException name="DOMException"/>
        </SetRaises>
      </Attribute>
      <Attribute name="borderLeftWidth" id="::css::CSS2Properties::borderLeftWidth">
        <webidl>             attribute DOMString        borderLeftWidth setraises(<ref>DOMException</ref>);</webidl>
        <Type type="DOMString"/>
        <SetRaises>
          <RaiseException name="DOMException"/>
        </SetRaises>
      </Attribute>
      <Attribute name="borderWidth" id="::css::CSS2Properties::borderWidth">
        <webidl>             attribute DOMString        borderWidth setraises(<ref>DOMException</ref>);</webidl>
        <Type type="DOMString"/>
        <SetRaises>
          <RaiseException name="DOMException"/>
        </SetRaises>
      </Attribute>
      <Attribute name="bottom" id="::css::CSS2Properties::bottom">
        <webidl>             attribute DOMString        bottom setraises(<ref>DOMException</ref>);</webidl>
        <Type type="DOMString"/>
        <SetRaises>
          <RaiseException name="DOMException"/>
        </SetRaises>
      </Attribute>
      <Attribute name="captionSide" id="::css::CSS2Properties::captionSide">
        <webidl>             attribute DOMString        captionSide setraises(<ref>DOMException</ref>);</webidl>
        <Type type="DOMString"/>
        <SetRaises>
          <RaiseException name="DOMException"/>
        </SetRaises>
      </Attribute>
      <Attribute name="clear" id="::css::CSS2Properties::clear">
        <webidl>             attribute DOMString        clear setraises(<ref>DOMException</ref>);</webidl>
        <Type type="DOMString"/>
        <SetRaises>
          <RaiseException name="DOMException"/>
        </SetRaises>
      </Attribute>
      <Attribute name="clip" id="::css::CSS2Properties::clip">
        <webidl>             attribute DOMString        clip setraises(<ref>DOMException</ref>);</webidl>
        <Type type="DOMString"/>
        <SetRaises>
          <RaiseException name="DOMException"/>
        </SetRaises>
      </Attribute>
      <Attribute name="color" id="::css::CSS2Properties::color">
        <webidl>             attribute DOMString        color setraises(<ref>DOMException</ref>);</webidl>
        <Type type="DOMString"/>
        <SetRaises>
          <RaiseException name="DOMException"/>
        </SetRaises>
      </Attribute>
      <Attribute name="content" id="::css::CSS2Properties::content">
        <webidl>             attribute DOMString        content setraises(<ref>DOMException</ref>);</webidl>
        <Type type="DOMString"/>
        <SetRaises>
          <RaiseException name="DOMException"/>
        </SetRaises>
      </Attribute>
      <Attribute name="counterIncrement" id="::css::CSS2Properties::counterIncrement">
        <webidl>             attribute DOMString        counterIncrement setraises(<ref>DOMException</ref>);</webidl>
        <Type type="DOMString"/>
        <SetRaises>
          <RaiseException name="DOMException"/>
        </SetRaises>
      </Attribute>
      <Attribute name="counterReset" id="::css::CSS2Properties::counterReset">
        <webidl>             attribute DOMString        counterReset setraises(<ref>DOMException</ref>);</webidl>
        <Type type="DOMString"/>
        <SetRaises>
          <RaiseException name="DOMException"/>
        </SetRaises>
      </Attribute>
      <Attribute name="cue" id="::css::CSS2Properties::cue">
        <webidl>             attribute DOMString        cue setraises(<ref>DOMException</ref>);</webidl>
        <Type type="DOMString"/>
        <SetRaises>
          <RaiseException name="DOMException"/>
        </SetRaises>
      </Attribute>
      <Attribute name="cueAfter" id="::css::CSS2Properties::cueAfter">
        <webidl>             attribute DOMString        cueAfter setraises(<ref>DOMException</ref>);</webidl>
        <Type type="DOMString"/>
        <SetRaises>
          <RaiseException name="DOMException"/>
        </SetRaises>
      </Attribute>
      <Attribute name="cueBefore" id="::css::CSS2Properties::cueBefore">
        <webidl>             attribute DOMString        cueBefore setraises(<ref>DOMException</ref>);</webidl>
        <Type type="DOMString"/>
        <SetRaises>
          <RaiseException name="DOMException"/>
        </SetRaises>
      </Attribute>
      <Attribute name="cursor" id="::css::CSS2Properties::cursor">
        <webidl>             attribute DOMString        cursor setraises(<ref>DOMException</ref>);</webidl>
        <Type type="DOMString"/>
        <SetRaises>
          <RaiseException name="DOMException"/>
        </SetRaises>
      </Attribute>
      <Attribute name="direction" id="::css::CSS2Properties::direction">
        <webidl>             attribute DOMString        direction setraises(<ref>DOMException</ref>);</webidl>
        <Type type="DOMString"/>
        <SetRaises>
          <RaiseException name="DOMException"/>
        </SetRaises>
      </Attribute>
      <Attribute name="display" id="::css::CSS2Properties::display">
        <webidl>             attribute DOMString        display setraises(<ref>DOMException</ref>);</webidl>
        <Type type="DOMString"/>
        <SetRaises>
          <RaiseException name="DOMException"/>
        </SetRaises>
      </Attribute>
      <Attribute name="elevation" id="::css::CSS2Properties::elevation">
        <webidl>             attribute DOMString        elevation setraises(<ref>DOMException</ref>);</webidl>
        <Type type="DOMString"/>
        <SetRaises>
          <RaiseException name="DOMException"/>
        </SetRaises>
      </Attribute>
      <Attribute name="emptyCells" id="::css::CSS2Properties::emptyCells">
        <webidl>             attribute DOMString        emptyCells setraises(<ref>DOMException</ref>);</webidl>
        <Type type="DOMString"/>
        <SetRaises>
          <RaiseException name="DOMException"/>
        </SetRaises>
      </Attribute>
      <Attribute name="cssFloat" id="::css::CSS2Properties::cssFloat">
        <webidl>             attribute DOMString        cssFloat setraises(<ref>DOMException</ref>);</webidl>
        <Type type="DOMString"/>
        <SetRaises>
          <RaiseException name="DOMException"/>
        </SetRaises>
      </Attribute>
      <Attribute name="font" id="::css::CSS2Properties::font">
        <webidl>             attribute DOMString        font setraises(<ref>DOMException</ref>);</webidl>
        <Type type="DOMString"/>
        <SetRaises>
          <RaiseException name="DOMException"/>
        </SetRaises>
      </Attribute>
      <Attribute name="fontFamily" id="::css::CSS2Properties::fontFamily">
        <webidl>             attribute DOMString        fontFamily setraises(<ref>DOMException</ref>);</webidl>
        <Type type="DOMString"/>
        <SetRaises>
          <RaiseException name="DOMException"/>
        </SetRaises>
      </Attribute>
      <Attribute name="fontSize" id="::css::CSS2Properties::fontSize">
        <webidl>             attribute DOMString        fontSize setraises(<ref>DOMException</ref>);</webidl>
        <Type type="DOMString"/>
        <SetRaises>
          <RaiseException name="DOMException"/>
        </SetRaises>
      </Attribute>
      <Attribute name="fontSizeAdjust" id="::css::CSS2Properties::fontSizeAdjust">
        <webidl>             attribute DOMString        fontSizeAdjust setraises(<ref>DOMException</ref>);</webidl>
        <Type type="DOMString"/>
        <SetRaises>
          <RaiseException name="DOMException"/>
        </SetRaises>
      </Attribute>
      <Attribute name="fontStretch" id="::css::CSS2Properties::fontStretch">
        <webidl>             attribute DOMString        fontStretch setraises(<ref>DOMException</ref>);</webidl>
        <Type type="DOMString"/>
        <SetRaises>
          <RaiseException name="DOMException"/>
        </SetRaises>
      </Attribute>
      <Attribute name="fontStyle" id="::css::CSS2Properties::fontStyle">
        <webidl>             attribute DOMString        fontStyle setraises(<ref>DOMException</ref>);</webidl>
        <Type type="DOMString"/>
        <SetRaises>
          <RaiseException name="DOMException"/>
        </SetRaises>
      </Attribute>
      <Attribute name="fontVariant" id="::css::CSS2Properties::fontVariant">
        <webidl>             attribute DOMString        fontVariant setraises(<ref>DOMException</ref>);</webidl>
        <Type type="DOMString"/>
        <SetRaises>
          <RaiseException name="DOMException"/>
        </SetRaises>
      </Attribute>
      <Attribute name="fontWeight" id="::css::CSS2Properties::fontWeight">
        <webidl>             attribute DOMString        fontWeight setraises(<ref>DOMException</ref>);</webidl>
        <Type type="DOMString"/>
        <SetRaises>
          <RaiseException name="DOMException"/>
        </SetRaises>
      </Attribute>
      <Attribute name="height" id="::css::CSS2Properties::height">
        <webidl>             attribute DOMString        height setraises(<ref>DOMException</ref>);</webidl>
        <Type type="DOMString"/>
        <SetRaises>
          <RaiseException name="DOMException"/>
        </SetRaises>
      </Attribute>
      <Attribute name="left" id="::css::CSS2Properties::left">
        <webidl>             attribute DOMString        left setraises(<ref>DOMException</ref>);</webidl>
        <Type type="DOMString"/>
        <SetRaises>
          <RaiseException name="DOMException"/>
        </SetRaises>
      </Attribute>
      <Attribute name="letterSpacing" id="::css::CSS2Properties::letterSpacing">
        <webidl>             attribute DOMString        letterSpacing setraises(<ref>DOMException</ref>);</webidl>
        <Type type="DOMString"/>
        <SetRaises>
          <RaiseException name="DOMException"/>
        </SetRaises>
      </Attribute>
      <Attribute name="lineHeight" id="::css::CSS2Properties::lineHeight">
        <webidl>             attribute DOMString        lineHeight setraises(<ref>DOMException</ref>);</webidl>
        <Type type="DOMString"/>
        <SetRaises>
          <RaiseException name="DOMException"/>
        </SetRaises>
      </Attribute>
      <Attribute name="listStyle" id="::css::CSS2Properties::listStyle">
        <webidl>             attribute DOMString        listStyle setraises(<ref>DOMException</ref>);</webidl>
        <Type type="DOMString"/>
        <SetRaises>
          <RaiseException name="DOMException"/>
        </SetRaises>
      </Attribute>
      <Attribute name="listStyleImage" id="::css::CSS2Properties::listStyleImage">
        <webidl>             attribute DOMString        listStyleImage setraises(<ref>DOMException</ref>);</webidl>
        <Type type="DOMString"/>
        <SetRaises>
          <RaiseException name="DOMException"/>
        </SetRaises>
      </Attribute>
      <Attribute name="listStylePosition" id="::css::CSS2Properties::listStylePosition">
        <webidl>             attribute DOMString        listStylePosition setraises(<ref>DOMException</ref>);</webidl>
        <Type type="DOMString"/>
        <SetRaises>
          <RaiseException name="DOMException"/>
        </SetRaises>
      </Attribute>
      <Attribute name="listStyleType" id="::css::CSS2Properties::listStyleType">
        <webidl>             attribute DOMString        listStyleType setraises(<ref>DOMException</ref>);</webidl>
        <Type type="DOMString"/>
        <SetRaises>
          <RaiseException name="DOMException"/>
        </SetRaises>
      </Attribute>
      <Attribute name="margin" id="::css::CSS2Properties::margin">
        <webidl>             attribute DOMString        margin setraises(<ref>DOMException</ref>);</webidl>
        <Type type="DOMString"/>
        <SetRaises>
          <RaiseException name="DOMException"/>
        </SetRaises>
      </Attribute>
      <Attribute name="marginTop" id="::css::CSS2Properties::marginTop">
        <webidl>             attribute DOMString        marginTop setraises(<ref>DOMException</ref>);</webidl>
        <Type type="DOMString"/>
        <SetRaises>
          <RaiseException name="DOMException"/>
        </SetRaises>
      </Attribute>
      <Attribute name="marginRight" id="::css::CSS2Properties::marginRight">
        <webidl>             attribute DOMString        marginRight setraises(<ref>DOMException</ref>);</webidl>
        <Type type="DOMString"/>
        <SetRaises>
          <RaiseException name="DOMException"/>
        </SetRaises>
      </Attribute>
      <Attribute name="marginBottom" id="::css::CSS2Properties::marginBottom">
        <webidl>             attribute DOMString        marginBottom setraises(<ref>DOMException</ref>);</webidl>
        <Type type="DOMString"/>
        <SetRaises>
          <RaiseException name="DOMException"/>
        </SetRaises>
      </Attribute>
      <Attribute name="marginLeft" id="::css::CSS2Properties::marginLeft">
        <webidl>             attribute DOMString        marginLeft setraises(<ref>DOMException</ref>);</webidl>
        <Type type="DOMString"/>
        <SetRaises>
          <RaiseException name="DOMException"/>
        </SetRaises>
      </Attribute>
      <Attribute name="markerOffset" id="::css::CSS2Properties::markerOffset">
        <webidl>             attribute DOMString        markerOffset setraises(<ref>DOMException</ref>);</webidl>
        <Type type="DOMString"/>
        <SetRaises>
          <RaiseException name="DOMException"/>
        </SetRaises>
      </Attribute>
      <Attribute name="marks" id="::css::CSS2Properties::marks">
        <webidl>             attribute DOMString        marks setraises(<ref>DOMException</ref>);</webidl>
        <Type type="DOMString"/>
        <SetRaises>
          <RaiseException name="DOMException"/>
        </SetRaises>
      </Attribute>
      <Attribute name="maxHeight" id="::css::CSS2Properties::maxHeight">
        <webidl>             attribute DOMString        maxHeight setraises(<ref>DOMException</ref>);</webidl>
        <Type type="DOMString"/>
        <SetRaises>
          <RaiseException name="DOMException"/>
        </SetRaises>
      </Attribute>
      <Attribute name="maxWidth" id="::css::CSS2Properties::maxWidth">
        <webidl>             attribute DOMString        maxWidth setraises(<ref>DOMException</ref>);</webidl>
        <Type type="DOMString"/>
        <SetRaises>
          <RaiseException name="DOMException"/>
        </SetRaises>
      </Attribute>
      <Attribute name="minHeight" id="::css::CSS2Properties::minHeight">
        <webidl>             attribute DOMString        minHeight setraises(<ref>DOMException</ref>);</webidl>
        <Type type="DOMString"/>
        <SetRaises>
          <RaiseException name="DOMException"/>
        </SetRaises>
      </Attribute>
      <Attribute name="minWidth" id="::css::CSS2Properties::minWidth">
        <webidl>             attribute DOMString        minWidth setraises(<ref>DOMException</ref>);</webidl>
        <Type type="DOMString"/>
        <SetRaises>
          <RaiseException name="DOMException"/>
        </SetRaises>
      </Attribute>
      <Attribute name="orphans" id="::css::CSS2Properties::orphans">
        <webidl>             attribute DOMString        orphans setraises(<ref>DOMException</ref>);</webidl>
        <Type type="DOMString"/>
        <SetRaises>
          <RaiseException name="DOMException"/>
        </SetRaises>
      </Attribute>
      <Attribute name="outline" id="::css::CSS2Properties::outline">
        <webidl>             attribute DOMString        outline setraises(<ref>DOMException</ref>);</webidl>
        <Type type="DOMString"/>
        <SetRaises>
          <RaiseException name="DOMException"/>
        </SetRaises>
      </Attribute>
      <Attribute name="outlineColor" id="::css::CSS2Properties::outlineColor">
        <webidl>             attribute DOMString        outlineColor setraises(<ref>DOMException</ref>);</webidl>
        <Type type="DOMString"/>
        <SetRaises>
          <RaiseException name="DOMException"/>
        </SetRaises>
      </Attribute>
      <Attribute name="outlineStyle" id="::css::CSS2Properties::outlineStyle">
        <webidl>             attribute DOMString        outlineStyle setraises(<ref>DOMException</ref>);</webidl>
        <Type type="DOMString"/>
        <SetRaises>
          <RaiseException name="DOMException"/>
        </SetRaises>
      </Attribute>
      <Attribute name="outlineWidth" id="::css::CSS2Properties::outlineWidth">
        <webidl>             attribute DOMString        outlineWidth setraises(<ref>DOMException</ref>);</webidl>
        <Type type="DOMString"/>
        <SetRaises>
          <RaiseException name="DOMException"/>
        </SetRaises>
      </Attribute>
      <Attribute name="overflow" id="::css::CSS2Properties::overflow">
        <webidl>             attribute DOMString        overflow setraises(<ref>DOMException</ref>);</webidl>
        <Type type="DOMString"/>
        <SetRaises>
          <RaiseException name="DOMException"/>
        </SetRaises>
      </Attribute>
      <Attribute name="padding" id="::css::CSS2Properties::padding">
        <webidl>             attribute DOMString        padding setraises(<ref>DOMException</ref>);</webidl>
        <Type type="DOMString"/>
        <SetRaises>
          <RaiseException name="DOMException"/>
        </SetRaises>
      </Attribute>
      <Attribute name="paddingTop" id="::css::CSS2Properties::paddingTop">
        <webidl>             attribute DOMString        paddingTop setraises(<ref>DOMException</ref>);</webidl>
        <Type type="DOMString"/>
        <SetRaises>
          <RaiseException name="DOMException"/>
        </SetRaises>
      </Attribute>
      <Attribute name="paddingRight" id="::css::CSS2Properties::paddingRight">
        <webidl>             attribute DOMString        paddingRight setraises(<ref>DOMException</ref>);</webidl>
        <Type type="DOMString"/>
        <SetRaises>
          <RaiseException name="DOMException"/>
        </SetRaises>
      </Attribute>
      <Attribute name="paddingBottom" id="::css::CSS2Properties::paddingBottom">
        <webidl>             attribute DOMString        paddingBottom setraises(<ref>DOMException</ref>);</webidl>
        <Type type="DOMString"/>
        <SetRaises>
          <RaiseException name="DOMException"/>
        </SetRaises>
      </Attribute>
      <Attribute name="paddingLeft" id="::css::CSS2Properties::paddingLeft">
        <webidl>             attribute DOMString        paddingLeft setraises(<ref>DOMException</ref>);</webidl>
        <Type type="DOMString"/>
        <SetRaises>
          <RaiseException name="DOMException"/>
        </SetRaises>
      </Attribute>
      <Attribute name="page" id="::css::CSS2Properties::page">
        <webidl>             attribute DOMString        page setraises(<ref>DOMException</ref>);</webidl>
        <Type type="DOMString"/>
        <SetRaises>
          <RaiseException name="DOMException"/>
        </SetRaises>
      </Attribute>
      <Attribute name="pageBreakAfter" id="::css::CSS2Properties::pageBreakAfter">
        <webidl>             attribute DOMString        pageBreakAfter setraises(<ref>DOMException</ref>);</webidl>
        <Type type="DOMString"/>
        <SetRaises>
          <RaiseException name="DOMException"/>
        </SetRaises>
      </Attribute>
      <Attribute name="pageBreakBefore" id="::css::CSS2Properties::pageBreakBefore">
        <webidl>             attribute DOMString        pageBreakBefore setraises(<ref>DOMException</ref>);</webidl>
        <Type type="DOMString"/>
        <SetRaises>
          <RaiseException name="DOMException"/>
        </SetRaises>
      </Attribute>
      <Attribute name="pageBreakInside" id="::css::CSS2Properties::pageBreakInside">
        <webidl>             attribute DOMString        pageBreakInside setraises(<ref>DOMException</ref>);</webidl>
        <Type type="DOMString"/>
        <SetRaises>
          <RaiseException name="DOMException"/>
        </SetRaises>
      </Attribute>
      <Attribute name="pause" id="::css::CSS2Properties::pause">
        <webidl>             attribute DOMString        pause setraises(<ref>DOMException</ref>);</webidl>
        <Type type="DOMString"/>
        <SetRaises>
          <RaiseException name="DOMException"/>
        </SetRaises>
      </Attribute>
      <Attribute name="pauseAfter" id="::css::CSS2Properties::pauseAfter">
        <webidl>             attribute DOMString        pauseAfter setraises(<ref>DOMException</ref>);</webidl>
        <Type type="DOMString"/>
        <SetRaises>
          <RaiseException name="DOMException"/>
        </SetRaises>
      </Attribute>
      <Attribute name="pauseBefore" id="::css::CSS2Properties::pauseBefore">
        <webidl>             attribute DOMString        pauseBefore setraises(<ref>DOMException</ref>);</webidl>
        <Type type="DOMString"/>
        <SetRaises>
          <RaiseException name="DOMException"/>
        </SetRaises>
      </Attribute>
      <Attribute name="pitch" id="::css::CSS2Properties::pitch">
        <webidl>             attribute DOMString        pitch setraises(<ref>DOMException</ref>);</webidl>
        <Type type="DOMString"/>
        <SetRaises>
          <RaiseException name="DOMException"/>
        </SetRaises>
      </Attribute>
      <Attribute name="pitchRange" id="::css::CSS2Properties::pitchRange">
        <webidl>             attribute DOMString        pitchRange setraises(<ref>DOMException</ref>);</webidl>
        <Type type="DOMString"/>
        <SetRaises>
          <RaiseException name="DOMException"/>
        </SetRaises>
      </Attribute>
      <Attribute name="playDuring" id="::css::CSS2Properties::playDuring">
        <webidl>             attribute DOMString        playDuring setraises(<ref>DOMException</ref>);</webidl>
        <Type type="DOMString"/>
        <SetRaises>
          <RaiseException name="DOMException"/>
        </SetRaises>
      </Attribute>
      <Attribute name="position" id="::css::CSS2Properties::position">
        <webidl>             attribute DOMString        position setraises(<ref>DOMException</ref>);</webidl>
        <Type type="DOMString"/>
        <SetRaises>
          <RaiseException name="DOMException"/>
        </SetRaises>
      </Attribute>
      <Attribute name="quotes" id="::css::CSS2Properties::quotes">
        <webidl>             attribute DOMString        quotes setraises(<ref>DOMException</ref>);</webidl>
        <Type type="DOMString"/>
        <SetRaises>
          <RaiseException name="DOMException"/>
        </SetRaises>
      </Attribute>
      <Attribute name="richness" id="::css::CSS2Properties::richness">
        <webidl>             attribute DOMString        richness setraises(<ref>DOMException</ref>);</webidl>
        <Type type="DOMString"/>
        <SetRaises>
          <RaiseException name="DOMException"/>
        </SetRaises>
      </Attribute>
      <Attribute name="right" id="::css::CSS2Properties::right">
        <webidl>             attribute DOMString        right setraises(<ref>DOMException</ref>);</webidl>
        <Type type="DOMString"/>
        <SetRaises>
          <RaiseException name="DOMException"/>
        </SetRaises>
      </Attribute>
      <Attribute name="size" id="::css::CSS2Properties::size">
        <webidl>             attribute DOMString        size setraises(<ref>DOMException</ref>);</webidl>
        <Type type="DOMString"/>
        <SetRaises>
          <RaiseException name="DOMException"/>
        </SetRaises>
      </Attribute>
      <Attribute name="speak" id="::css::CSS2Properties::speak">
        <webidl>             attribute DOMString        speak setraises(<ref>DOMException</ref>);</webidl>
        <Type type="DOMString"/>
        <SetRaises>
          <RaiseException name="DOMException"/>
        </SetRaises>
      </Attribute>
      <Attribute name="speakHeader" id="::css::CSS2Properties::speakHeader">
        <webidl>             attribute DOMString        speakHeader setraises(<ref>DOMException</ref>);</webidl>
        <Type type="DOMString"/>
        <SetRaises>
          <RaiseException name="DOMException"/>
        </SetRaises>
      </Attribute>
      <Attribute name="speakNumeral" id="::css::CSS2Properties::speakNumeral">
        <webidl>             attribute DOMString        speakNumeral setraises(<ref>DOMException</ref>);</webidl>
        <Type type="DOMString"/>
        <SetRaises>
          <RaiseException name="DOMException"/>
        </SetRaises>
      </Attribute>
      <Attribute name="speakPunctuation" id="::css::CSS2Properties::speakPunctuation">
        <webidl>             attribute DOMString        speakPunctuation setraises(<ref>DOMException</ref>);</webidl>
        <Type type="DOMString"/>
        <SetRaises>
          <RaiseException name="DOMException"/>
        </SetRaises>
      </Attribute>
      <Attribute name="speechRate" id="::css::CSS2Properties::speechRate">
        <webidl>             attribute DOMString        speechRate setraises(<ref>DOMException</ref>);</webidl>
        <Type type="DOMString"/>
        <SetRaises>
          <RaiseException name="DOMException"/>
        </SetRaises>
      </Attribute>
      <Attribute name="stress" id="::css::CSS2Properties::stress">
        <webidl>             attribute DOMString        stress setraises(<ref>DOMException</ref>);</webidl>
        <Type type="DOMString"/>
        <SetRaises>
          <RaiseException name="DOMException"/>
        </SetRaises>
      </Attribute>
      <Attribute name="tableLayout" id="::css::CSS2Properties::tableLayout">
        <webidl>             attribute DOMString        tableLayout setraises(<ref>DOMException</ref>);</webidl>
        <Type type="DOMString"/>
        <SetRaises>
          <RaiseException name="DOMException"/>
        </SetRaises>
      </Attribute>
      <Attribute name="textAlign" id="::css::CSS2Properties::textAlign">
        <webidl>             attribute DOMString        textAlign setraises(<ref>DOMException</ref>);</webidl>
        <Type type="DOMString"/>
        <SetRaises>
          <RaiseException name="DOMException"/>
        </SetRaises>
      </Attribute>
      <Attribute name="textDecoration" id="::css::CSS2Properties::textDecoration">
        <webidl>             attribute DOMString        textDecoration setraises(<ref>DOMException</ref>);</webidl>
        <Type type="DOMString"/>
        <SetRaises>
          <RaiseException name="DOMException"/>
        </SetRaises>
      </Attribute>
      <Attribute name="textIndent" id="::css::CSS2Properties::textIndent">
        <webidl>             attribute DOMString        textIndent setraises(<ref>DOMException</ref>);</webidl>
        <Type type="DOMString"/>
        <SetRaises>
          <RaiseException name="DOMException"/>
        </SetRaises>
      </Attribute>
      <Attribute name="textShadow" id="::css::CSS2Properties::textShadow">
        <webidl>             attribute DOMString        textShadow setraises(<ref>DOMException</ref>);</webidl>
        <Type type="DOMString"/>
        <SetRaises>
          <RaiseException name="DOMException"/>
        </SetRaises>
      </Attribute>
      <Attribute name="textTransform" id="::css::CSS2Properties::textTransform">
        <webidl>             attribute DOMString        textTransform setraises(<ref>DOMException</ref>);</webidl>
        <Type type="DOMString"/>
        <SetRaises>
          <RaiseException name="DOMException"/>
        </SetRaises>
      </Attribute>
      <Attribute name="top" id="::css::CSS2Properties::top">
        <webidl>             attribute DOMString        top setraises(<ref>DOMException</ref>);</webidl>
        <Type type="DOMString"/>
        <SetRaises>
          <RaiseException name="DOMException"/>
        </SetRaises>
      </Attribute>
      <Attribute name="unicodeBidi" id="::css::CSS2Properties::unicodeBidi">
        <webidl>             attribute DOMString        unicodeBidi setraises(<ref>DOMException</ref>);</webidl>
        <Type type="DOMString"/>
        <SetRaises>
          <RaiseException name="DOMException"/>
        </SetRaises>
      </Attribute>
      <Attribute name="verticalAlign" id="::css::CSS2Properties::verticalAlign">
        <webidl>             attribute DOMString        verticalAlign setraises(<ref>DOMException</ref>);</webidl>
        <Type type="DOMString"/>
        <SetRaises>
          <RaiseException name="DOMException"/>
        </SetRaises>
      </Attribute>
      <Attribute name="visibility" id="::css::CSS2Properties::visibility">
        <webidl>             attribute DOMString        visibility setraises(<ref>DOMException</ref>);</webidl>
        <Type type="DOMString"/>
        <SetRaises>
          <RaiseException name="DOMException"/>
        </SetRaises>
      </Attribute>
      <Attribute name="voiceFamily" id="::css::CSS2Properties::voiceFamily">
        <webidl>             attribute DOMString        voiceFamily setraises(<ref>DOMException</ref>);</webidl>
        <Type type="DOMString"/>
        <SetRaises>
          <RaiseException name="DOMException"/>
        </SetRaises>
      </Attribute>
      <Attribute name="volume" id="::css::CSS2Properties::volume">
        <webidl>             attribute DOMString        volume setraises(<ref>DOMException</ref>);</webidl>
        <Type type="DOMString"/>
        <SetRaises>
          <RaiseException name="DOMException"/>
        </SetRaises>
      </Attribute>
      <Attribute name="whiteSpace" id="::css::CSS2Properties::whiteSpace">
        <webidl>             attribute DOMString        whiteSpace setraises(<ref>DOMException</ref>);</webidl>
        <Type type="DOMString"/>
        <SetRaises>
          <RaiseException name="DOMException"/>
        </SetRaises>
      </Attribute>
      <Attribute name="widows" id="::css::CSS2Properties::widows">
        <webidl>             attribute DOMString        widows setraises(<ref>DOMException</ref>);</webidl>
        <Type type="DOMString"/>
        <SetRaises>
          <RaiseException name="DOMException"/>
        </SetRaises>
      </Attribute>
      <Attribute name="width" id="::css::CSS2Properties::width">
        <webidl>             attribute DOMString        width setraises(<ref>DOMException</ref>);</webidl>
        <Type type="DOMString"/>
        <SetRaises>
          <RaiseException name="DOMException"/>
        </SetRaises>
      </Attribute>
      <Attribute name="wordSpacing" id="::css::CSS2Properties::wordSpacing">
        <webidl>             attribute DOMString        wordSpacing setraises(<ref>DOMException</ref>);</webidl>
        <Type type="DOMString"/>
        <SetRaises>
          <RaiseException name="DOMException"/>
        </SetRaises>
      </Attribute>
      <Attribute name="zIndex" id="::css::CSS2Properties::zIndex">
        <webidl>             attribute DOMString        zIndex setraises(<ref>DOMException</ref>);</webidl>
        <Type type="DOMString"/>
        <SetRaises>
          <RaiseException name="DOMException"/>
        </SetRaises>
      </Attribute>
    </Interface>
    <Interface name="CSSStyleSheet" id="::css::CSSStyleSheet">
      <webidl>  interface CSSStyleSheet : <ref>stylesheets::StyleSheet</ref> {
    readonly attribute <ref>CSSRule</ref>          ownerRule;
    readonly attribute <ref>CSSRuleList</ref>      cssRules;
    unsigned long      insertRule(in DOMString rule, 
                                  in unsigned long index)
                                        raises(<ref>DOMException</ref>);
    void               deleteRule(in unsigned long index)
                                        raises(<ref>DOMException</ref>);
  };</webidl>
      <InterfaceInheritance>
        <Name name="stylesheetsStyleSheet"/>
      </InterfaceInheritance>
      <Attribute readonly="readonly" name="ownerRule" id="::css::CSSStyleSheet::ownerRule">
        <webidl>    readonly attribute <ref>CSSRule</ref>          ownerRule;</webidl>
        <Type name="CSSRule"/>
      </Attribute>
      <Attribute readonly="readonly" name="cssRules" id="::css::CSSStyleSheet::cssRules">
        <webidl>    readonly attribute <ref>CSSRuleList</ref>      cssRules;</webidl>
        <Type name="CSSRuleList"/>
      </Attribute>
      <Operation name="insertRule" id="::css::CSSStyleSheet::insertRule">
        <webidl>    unsigned long      insertRule(in DOMString rule, 
                                  in unsigned long index)
                                        raises(<ref>DOMException</ref>);</webidl>
        <Type type="unsigned long"/>
        <ArgumentList>
          <Argument in="in" name="rule">
            <Type type="DOMString"/>
          </Argument>
          <Argument in="in" name="index">
            <Type type="unsigned long"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="DOMException"/>
        </Raises>
      </Operation>
      <Operation name="deleteRule" id="::css::CSSStyleSheet::deleteRule">
        <webidl>    void               deleteRule(in unsigned long index)
                                        raises(<ref>DOMException</ref>);</webidl>
        <Type type="void"/>
        <ArgumentList>
          <Argument in="in" name="index">
            <Type type="unsigned long"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="DOMException"/>
        </Raises>
      </Operation>
    </Interface>
    <Interface name="ViewCSS" id="::css::ViewCSS">
      <webidl>  interface ViewCSS  {
    <ref>CSSStyleDeclaration</ref> getComputedStyle(in <ref>Element</ref> elt, 
                                         in DOMString? pseudoElt);
  };</webidl>
      <Operation name="getComputedStyle" id="::css::ViewCSS::getComputedStyle">
        <webidl>    <ref>CSSStyleDeclaration</ref> getComputedStyle(in <ref>Element</ref> elt, 
                                         in DOMString? pseudoElt);</webidl>
        <Type name="CSSStyleDeclaration"/>
        <ArgumentList>
          <Argument in="in" name="elt">
            <Type name="Element"/>
          </Argument>
          <Argument in="in" name="pseudoElt">
            <Type type="DOMString" nullable="nullable"/>
          </Argument>
        </ArgumentList>
      </Operation>
    </Interface>
    <Implements name1="AbstractView" name2="ViewCSS">
      <webidl>  <ref>AbstractView</ref> implements <ref>ViewCSS</ref>;</webidl>
    </Implements>
    <Interface name="DocumentCSS" id="::css::DocumentCSS">
      <webidl>  interface DocumentCSS  {
    <ref>CSSStyleDeclaration</ref> getOverrideStyle(in <ref>Element</ref> elt, 
                                         in DOMString? pseudoElt);
  };</webidl>
      <Operation name="getOverrideStyle" id="::css::DocumentCSS::getOverrideStyle">
        <webidl>    <ref>CSSStyleDeclaration</ref> getOverrideStyle(in <ref>Element</ref> elt, 
                                         in DOMString? pseudoElt);</webidl>
        <Type name="CSSStyleDeclaration"/>
        <ArgumentList>
          <Argument in="in" name="elt">
            <Type name="Element"/>
          </Argument>
          <Argument in="in" name="pseudoElt">
            <Type type="DOMString" nullable="nullable"/>
          </Argument>
        </ArgumentList>
      </Operation>
    </Interface>
    <Implements name1="Document" name2="DocumentCSS">
      <webidl>  <ref>Document</ref> implements <ref>DocumentCSS</ref>;</webidl>
    </Implements>
    <Interface name="DOMImplementationCSS" id="::css::DOMImplementationCSS">
      <webidl>  interface DOMImplementationCSS  {
    <ref>CSSStyleSheet</ref>      createCSSStyleSheet(in DOMString title, 
                                           in DOMString media)
                                        raises(<ref>DOMException</ref>);
  };</webidl>
      <Operation name="createCSSStyleSheet" id="::css::DOMImplementationCSS::createCSSStyleSheet">
        <webidl>    <ref>CSSStyleSheet</ref>      createCSSStyleSheet(in DOMString title, 
                                           in DOMString media)
                                        raises(<ref>DOMException</ref>);</webidl>
        <Type name="CSSStyleSheet"/>
        <ArgumentList>
          <Argument in="in" name="title">
            <Type type="DOMString"/>
          </Argument>
          <Argument in="in" name="media">
            <Type type="DOMString"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="DOMException"/>
        </Raises>
      </Operation>
    </Interface>
    <Implements name1="DOMImplementation" name2="DOMImplementationCSS">
      <webidl>  <ref>DOMImplementation</ref> implements <ref>DOMImplementationCSS</ref>;</webidl>
    </Implements>
  </Module>
</Definitions>
<Definitions>
  <Module name="events" id="::events">
    <webidl>module events {

  typedef <ref>dom::DOMTimeStamp</ref> DOMTimeStamp;
  typedef <ref>dom::Node</ref> Node;
  typedef <ref>dom::DOMException</ref> DOMException;

  exception EventException {
    const unsigned short      UNSPECIFIED_EVENT_TYPE_ERR     = 0;

    unsigned short   code;
  };


  interface EventTarget {
    void               addEventListener(in DOMString type, 
                                        in <ref>EventListener</ref> listener, 
                                        in boolean useCapture);
    void               removeEventListener(in DOMString type, 
                                           in <ref>EventListener</ref> listener, 
                                           in boolean useCapture);
    boolean            dispatchEvent(in <ref>Event</ref> evt)
                                        raises(<ref>EventException</ref>);
  };

  <ref>Node</ref> implements <ref>EventTarget</ref>;

  [Callback]
  interface EventListener {
    void               handleEvent(in <ref>Event</ref> evt);
  };

  [PrototypeRoot]
  interface Event {

    const unsigned short      CAPTURING_PHASE                = 1;
    const unsigned short      AT_TARGET                      = 2;
    const unsigned short      BUBBLING_PHASE                 = 3;

    readonly attribute DOMString        type;
    readonly attribute <ref>EventTarget</ref>      target;
    readonly attribute <ref>EventTarget</ref>      currentTarget;
    readonly attribute unsigned short   eventPhase;
    readonly attribute boolean          bubbles;
    readonly attribute boolean          cancelable;
    readonly attribute <ref>DOMTimeStamp</ref>     timeStamp;
    void               stopPropagation();
    void               preventDefault();
    void               initEvent(in DOMString eventTypeArg, 
                                 in boolean canBubbleArg, 
                                 in boolean cancelableArg);
  };

  interface DocumentEvent {
    <ref>Event</ref>              createEvent(in DOMString eventType)
                                        raises(<ref>DOMException</ref>);
  };

  <ref>Document</ref> implements <ref>DocumentEvent</ref>;

  interface UIEvent : <ref>Event</ref> {
    readonly attribute <ref>views::AbstractView</ref>  view;
    readonly attribute long             detail;
    void               initUIEvent(in DOMString typeArg, 
                                   in boolean canBubbleArg, 
                                   in boolean cancelableArg, 
                                   in <ref>views::AbstractView</ref> viewArg, 
                                   in long detailArg);
  };

  interface MouseEvent : <ref>UIEvent</ref> {
    readonly attribute long             screenX;
    readonly attribute long             screenY;
    readonly attribute long             clientX;
    readonly attribute long             clientY;
    readonly attribute boolean          ctrlKey;
    readonly attribute boolean          shiftKey;
    readonly attribute boolean          altKey;
    readonly attribute boolean          metaKey;
    readonly attribute unsigned short   button;
    readonly attribute <ref>EventTarget</ref>      relatedTarget;
    void               initMouseEvent(in DOMString typeArg, 
                                      in boolean canBubbleArg, 
                                      in boolean cancelableArg, 
                                      in <ref>views::AbstractView</ref> viewArg, 
                                      in long detailArg, 
                                      in long screenXArg, 
                                      in long screenYArg, 
                                      in long clientXArg, 
                                      in long clientYArg, 
                                      in boolean ctrlKeyArg, 
                                      in boolean altKeyArg, 
                                      in boolean shiftKeyArg, 
                                      in boolean metaKeyArg, 
                                      in unsigned short buttonArg, 
                                      in <ref>EventTarget</ref> relatedTargetArg);
  };

  interface MutationEvent : <ref>Event</ref> {

    const unsigned short      MODIFICATION                   = 1;
    const unsigned short      ADDITION                       = 2;
    const unsigned short      REMOVAL                        = 3;

    readonly attribute <ref>Node</ref>             relatedNode;
    readonly attribute DOMString?       prevValue;
    readonly attribute DOMString?       newValue;
    readonly attribute DOMString?       attrName;
    readonly attribute unsigned short   attrChange;
    void               initMutationEvent(in DOMString typeArg, 
                                         in boolean canBubbleArg, 
                                         in boolean cancelableArg, 
                                         in <ref>Node</ref> relatedNodeArg, 
                                         in DOMString? prevValueArg, 
                                         in DOMString? newValueArg, 
                                         in DOMString? attrNameArg, 
                                         in unsigned short attrChangeArg);
  };
};</webidl>
    <Typedef name="DOMTimeStamp" id="::events::DOMTimeStamp">
      <webidl>  typedef <ref>dom::DOMTimeStamp</ref> DOMTimeStamp;</webidl>
      <Type name="domDOMTimeStamp"/>
    </Typedef>
    <Typedef name="Node" id="::events::Node">
      <webidl>  typedef <ref>dom::Node</ref> Node;</webidl>
      <Type name="domNode"/>
    </Typedef>
    <Typedef name="DOMException" id="::events::DOMException">
      <webidl>  typedef <ref>dom::DOMException</ref> DOMException;</webidl>
      <Type name="domDOMException"/>
    </Typedef>
    <Exception name="EventException" id="::events::EventException">
      <webidl>  exception EventException {
    const unsigned short      UNSPECIFIED_EVENT_TYPE_ERR     = 0;

    unsigned short   code;
  };</webidl>
      <Const name="UNSPECIFIED_EVENT_TYPE_ERR" value="0" id="::events::EventException::UNSPECIFIED_EVENT_TYPE_ERR">
        <Type type="unsigned short"/>
      </Const>
      <ExceptionField name="code" id="::events::EventException::code">
        <Type type="unsigned short"/>
      </ExceptionField>
    </Exception>
    <Interface name="EventTarget" id="::events::EventTarget">
      <webidl>  interface EventTarget {
    void               addEventListener(in DOMString type, 
                                        in <ref>EventListener</ref> listener, 
                                        in boolean useCapture);
    void               removeEventListener(in DOMString type, 
                                           in <ref>EventListener</ref> listener, 
                                           in boolean useCapture);
    boolean            dispatchEvent(in <ref>Event</ref> evt)
                                        raises(<ref>EventException</ref>);
  };</webidl>
      <Operation name="addEventListener" id="::events::EventTarget::addEventListener">
        <webidl>    void               addEventListener(in DOMString type, 
                                        in <ref>EventListener</ref> listener, 
                                        in boolean useCapture);</webidl>
        <Type type="void"/>
        <ArgumentList>
          <Argument in="in" name="type">
            <Type type="DOMString"/>
          </Argument>
          <Argument in="in" name="listener">
            <Type name="EventListener"/>
          </Argument>
          <Argument in="in" name="useCapture">
            <Type type="boolean"/>
          </Argument>
        </ArgumentList>
      </Operation>
      <Operation name="removeEventListener" id="::events::EventTarget::removeEventListener">
        <webidl>    void               removeEventListener(in DOMString type, 
                                           in <ref>EventListener</ref> listener, 
                                           in boolean useCapture);</webidl>
        <Type type="void"/>
        <ArgumentList>
          <Argument in="in" name="type">
            <Type type="DOMString"/>
          </Argument>
          <Argument in="in" name="listener">
            <Type name="EventListener"/>
          </Argument>
          <Argument in="in" name="useCapture">
            <Type type="boolean"/>
          </Argument>
        </ArgumentList>
      </Operation>
      <Operation name="dispatchEvent" id="::events::EventTarget::dispatchEvent">
        <webidl>    boolean            dispatchEvent(in <ref>Event</ref> evt)
                                        raises(<ref>EventException</ref>);</webidl>
        <Type type="boolean"/>
        <ArgumentList>
          <Argument in="in" name="evt">
            <Type name="Event"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="EventException"/>
        </Raises>
      </Operation>
    </Interface>
    <Implements name1="Node" name2="EventTarget">
      <webidl>  <ref>Node</ref> implements <ref>EventTarget</ref>;</webidl>
    </Implements>
    <Interface name="EventListener" id="::events::EventListener">
      <webidl>  [Callback]
  interface EventListener {
    void               handleEvent(in <ref>Event</ref> evt);
  };</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="Callback"/>
      </ExtendedAttributeList>
      <Operation name="handleEvent" id="::events::EventListener::handleEvent">
        <webidl>    void               handleEvent(in <ref>Event</ref> evt);</webidl>
        <Type type="void"/>
        <ArgumentList>
          <Argument in="in" name="evt">
            <Type name="Event"/>
          </Argument>
        </ArgumentList>
      </Operation>
    </Interface>
    <Interface name="Event" id="::events::Event">
      <webidl>  [PrototypeRoot]
  interface Event {

    const unsigned short      CAPTURING_PHASE                = 1;
    const unsigned short      AT_TARGET                      = 2;
    const unsigned short      BUBBLING_PHASE                 = 3;

    readonly attribute DOMString        type;
    readonly attribute <ref>EventTarget</ref>      target;
    readonly attribute <ref>EventTarget</ref>      currentTarget;
    readonly attribute unsigned short   eventPhase;
    readonly attribute boolean          bubbles;
    readonly attribute boolean          cancelable;
    readonly attribute <ref>DOMTimeStamp</ref>     timeStamp;
    void               stopPropagation();
    void               preventDefault();
    void               initEvent(in DOMString eventTypeArg, 
                                 in boolean canBubbleArg, 
                                 in boolean cancelableArg);
  };</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="PrototypeRoot"/>
      </ExtendedAttributeList>
      <Const name="CAPTURING_PHASE" value="1" id="::events::Event::CAPTURING_PHASE">
        <webidl>    const unsigned short      CAPTURING_PHASE                = 1;</webidl>
        <Type type="unsigned short"/>
      </Const>
      <Const name="AT_TARGET" value="2" id="::events::Event::AT_TARGET">
        <webidl>    const unsigned short      AT_TARGET                      = 2;</webidl>
        <Type type="unsigned short"/>
      </Const>
      <Const name="BUBBLING_PHASE" value="3" id="::events::Event::BUBBLING_PHASE">
        <webidl>    const unsigned short      BUBBLING_PHASE                 = 3;</webidl>
        <Type type="unsigned short"/>
      </Const>
      <Attribute readonly="readonly" name="type" id="::events::Event::type">
        <webidl>    readonly attribute DOMString        type;</webidl>
        <Type type="DOMString"/>
      </Attribute>
      <Attribute readonly="readonly" name="target" id="::events::Event::target">
        <webidl>    readonly attribute <ref>EventTarget</ref>      target;</webidl>
        <Type name="EventTarget"/>
      </Attribute>
      <Attribute readonly="readonly" name="currentTarget" id="::events::Event::currentTarget">
        <webidl>    readonly attribute <ref>EventTarget</ref>      currentTarget;</webidl>
        <Type name="EventTarget"/>
      </Attribute>
      <Attribute readonly="readonly" name="eventPhase" id="::events::Event::eventPhase">
        <webidl>    readonly attribute unsigned short   eventPhase;</webidl>
        <Type type="unsigned short"/>
      </Attribute>
      <Attribute readonly="readonly" name="bubbles" id="::events::Event::bubbles">
        <webidl>    readonly attribute boolean          bubbles;</webidl>
        <Type type="boolean"/>
      </Attribute>
      <Attribute readonly="readonly" name="cancelable" id="::events::Event::cancelable">
        <webidl>    readonly attribute boolean          cancelable;</webidl>
        <Type type="boolean"/>
      </Attribute>
      <Attribute readonly="readonly" name="timeStamp" id="::events::Event::timeStamp">
        <webidl>    readonly attribute <ref>DOMTimeStamp</ref>     timeStamp;</webidl>
        <Type name="DOMTimeStamp"/>
      </Attribute>
      <Operation name="stopPropagation" id="::events::Event::stopPropagation">
        <webidl>    void               stopPropagation();</webidl>
        <Type type="void"/>
        <ArgumentList/>
      </Operation>
      <Operation name="preventDefault" id="::events::Event::preventDefault">
        <webidl>    void               preventDefault();</webidl>
        <Type type="void"/>
        <ArgumentList/>
      </Operation>
      <Operation name="initEvent" id="::events::Event::initEvent">
        <webidl>    void               initEvent(in DOMString eventTypeArg, 
                                 in boolean canBubbleArg, 
                                 in boolean cancelableArg);</webidl>
        <Type type="void"/>
        <ArgumentList>
          <Argument in="in" name="eventTypeArg">
            <Type type="DOMString"/>
          </Argument>
          <Argument in="in" name="canBubbleArg">
            <Type type="boolean"/>
          </Argument>
          <Argument in="in" name="cancelableArg">
            <Type type="boolean"/>
          </Argument>
        </ArgumentList>
      </Operation>
    </Interface>
    <Interface name="DocumentEvent" id="::events::DocumentEvent">
      <webidl>  interface DocumentEvent {
    <ref>Event</ref>              createEvent(in DOMString eventType)
                                        raises(<ref>DOMException</ref>);
  };</webidl>
      <Operation name="createEvent" id="::events::DocumentEvent::createEvent">
        <webidl>    <ref>Event</ref>              createEvent(in DOMString eventType)
                                        raises(<ref>DOMException</ref>);</webidl>
        <Type name="Event"/>
        <ArgumentList>
          <Argument in="in" name="eventType">
            <Type type="DOMString"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="DOMException"/>
        </Raises>
      </Operation>
    </Interface>
    <Implements name1="Document" name2="DocumentEvent">
      <webidl>  <ref>Document</ref> implements <ref>DocumentEvent</ref>;</webidl>
    </Implements>
    <Interface name="UIEvent" id="::events::UIEvent">
      <webidl>  interface UIEvent : <ref>Event</ref> {
    readonly attribute <ref>views::AbstractView</ref>  view;
    readonly attribute long             detail;
    void               initUIEvent(in DOMString typeArg, 
                                   in boolean canBubbleArg, 
                                   in boolean cancelableArg, 
                                   in <ref>views::AbstractView</ref> viewArg, 
                                   in long detailArg);
  };</webidl>
      <InterfaceInheritance>
        <Name name="Event"/>
      </InterfaceInheritance>
      <Attribute readonly="readonly" name="view" id="::events::UIEvent::view">
        <webidl>    readonly attribute <ref>views::AbstractView</ref>  view;</webidl>
        <Type name="viewsAbstractView"/>
      </Attribute>
      <Attribute readonly="readonly" name="detail" id="::events::UIEvent::detail">
        <webidl>    readonly attribute long             detail;</webidl>
        <Type type="long"/>
      </Attribute>
      <Operation name="initUIEvent" id="::events::UIEvent::initUIEvent">
        <webidl>    void               initUIEvent(in DOMString typeArg, 
                                   in boolean canBubbleArg, 
                                   in boolean cancelableArg, 
                                   in <ref>views::AbstractView</ref> viewArg, 
                                   in long detailArg);</webidl>
        <Type type="void"/>
        <ArgumentList>
          <Argument in="in" name="typeArg">
            <Type type="DOMString"/>
          </Argument>
          <Argument in="in" name="canBubbleArg">
            <Type type="boolean"/>
          </Argument>
          <Argument in="in" name="cancelableArg">
            <Type type="boolean"/>
          </Argument>
          <Argument in="in" name="viewArg">
            <Type name="viewsAbstractView"/>
          </Argument>
          <Argument in="in" name="detailArg">
            <Type type="long"/>
          </Argument>
        </ArgumentList>
      </Operation>
    </Interface>
    <Interface name="MouseEvent" id="::events::MouseEvent">
      <webidl>  interface MouseEvent : <ref>UIEvent</ref> {
    readonly attribute long             screenX;
    readonly attribute long             screenY;
    readonly attribute long             clientX;
    readonly attribute long             clientY;
    readonly attribute boolean          ctrlKey;
    readonly attribute boolean          shiftKey;
    readonly attribute boolean          altKey;
    readonly attribute boolean          metaKey;
    readonly attribute unsigned short   button;
    readonly attribute <ref>EventTarget</ref>      relatedTarget;
    void               initMouseEvent(in DOMString typeArg, 
                                      in boolean canBubbleArg, 
                                      in boolean cancelableArg, 
                                      in <ref>views::AbstractView</ref> viewArg, 
                                      in long detailArg, 
                                      in long screenXArg, 
                                      in long screenYArg, 
                                      in long clientXArg, 
                                      in long clientYArg, 
                                      in boolean ctrlKeyArg, 
                                      in boolean altKeyArg, 
                                      in boolean shiftKeyArg, 
                                      in boolean metaKeyArg, 
                                      in unsigned short buttonArg, 
                                      in <ref>EventTarget</ref> relatedTargetArg);
  };</webidl>
      <InterfaceInheritance>
        <Name name="UIEvent"/>
      </InterfaceInheritance>
      <Attribute readonly="readonly" name="screenX" id="::events::MouseEvent::screenX">
        <webidl>    readonly attribute long             screenX;</webidl>
        <Type type="long"/>
      </Attribute>
      <Attribute readonly="readonly" name="screenY" id="::events::MouseEvent::screenY">
        <webidl>    readonly attribute long             screenY;</webidl>
        <Type type="long"/>
      </Attribute>
      <Attribute readonly="readonly" name="clientX" id="::events::MouseEvent::clientX">
        <webidl>    readonly attribute long             clientX;</webidl>
        <Type type="long"/>
      </Attribute>
      <Attribute readonly="readonly" name="clientY" id="::events::MouseEvent::clientY">
        <webidl>    readonly attribute long             clientY;</webidl>
        <Type type="long"/>
      </Attribute>
      <Attribute readonly="readonly" name="ctrlKey" id="::events::MouseEvent::ctrlKey">
        <webidl>    readonly attribute boolean          ctrlKey;</webidl>
        <Type type="boolean"/>
      </Attribute>
      <Attribute readonly="readonly" name="shiftKey" id="::events::MouseEvent::shiftKey">
        <webidl>    readonly attribute boolean          shiftKey;</webidl>
        <Type type="boolean"/>
      </Attribute>
      <Attribute readonly="readonly" name="altKey" id="::events::MouseEvent::altKey">
        <webidl>    readonly attribute boolean          altKey;</webidl>
        <Type type="boolean"/>
      </Attribute>
      <Attribute readonly="readonly" name="metaKey" id="::events::MouseEvent::metaKey">
        <webidl>    readonly attribute boolean          metaKey;</webidl>
        <Type type="boolean"/>
      </Attribute>
      <Attribute readonly="readonly" name="button" id="::events::MouseEvent::button">
        <webidl>    readonly attribute unsigned short   button;</webidl>
        <Type type="unsigned short"/>
      </Attribute>
      <Attribute readonly="readonly" name="relatedTarget" id="::events::MouseEvent::relatedTarget">
        <webidl>    readonly attribute <ref>EventTarget</ref>      relatedTarget;</webidl>
        <Type name="EventTarget"/>
      </Attribute>
      <Operation name="initMouseEvent" id="::events::MouseEvent::initMouseEvent">
        <webidl>    void               initMouseEvent(in DOMString typeArg, 
                                      in boolean canBubbleArg, 
                                      in boolean cancelableArg, 
                                      in <ref>views::AbstractView</ref> viewArg, 
                                      in long detailArg, 
                                      in long screenXArg, 
                                      in long screenYArg, 
                                      in long clientXArg, 
                                      in long clientYArg, 
                                      in boolean ctrlKeyArg, 
                                      in boolean altKeyArg, 
                                      in boolean shiftKeyArg, 
                                      in boolean metaKeyArg, 
                                      in unsigned short buttonArg, 
                                      in <ref>EventTarget</ref> relatedTargetArg);</webidl>
        <Type type="void"/>
        <ArgumentList>
          <Argument in="in" name="typeArg">
            <Type type="DOMString"/>
          </Argument>
          <Argument in="in" name="canBubbleArg">
            <Type type="boolean"/>
          </Argument>
          <Argument in="in" name="cancelableArg">
            <Type type="boolean"/>
          </Argument>
          <Argument in="in" name="viewArg">
            <Type name="viewsAbstractView"/>
          </Argument>
          <Argument in="in" name="detailArg">
            <Type type="long"/>
          </Argument>
          <Argument in="in" name="screenXArg">
            <Type type="long"/>
          </Argument>
          <Argument in="in" name="screenYArg">
            <Type type="long"/>
          </Argument>
          <Argument in="in" name="clientXArg">
            <Type type="long"/>
          </Argument>
          <Argument in="in" name="clientYArg">
            <Type type="long"/>
          </Argument>
          <Argument in="in" name="ctrlKeyArg">
            <Type type="boolean"/>
          </Argument>
          <Argument in="in" name="altKeyArg">
            <Type type="boolean"/>
          </Argument>
          <Argument in="in" name="shiftKeyArg">
            <Type type="boolean"/>
          </Argument>
          <Argument in="in" name="metaKeyArg">
            <Type type="boolean"/>
          </Argument>
          <Argument in="in" name="buttonArg">
            <Type type="unsigned short"/>
          </Argument>
          <Argument in="in" name="relatedTargetArg">
            <Type name="EventTarget"/>
          </Argument>
        </ArgumentList>
      </Operation>
    </Interface>
    <Interface name="MutationEvent" id="::events::MutationEvent">
      <webidl>  interface MutationEvent : <ref>Event</ref> {

    const unsigned short      MODIFICATION                   = 1;
    const unsigned short      ADDITION                       = 2;
    const unsigned short      REMOVAL                        = 3;

    readonly attribute <ref>Node</ref>             relatedNode;
    readonly attribute DOMString?       prevValue;
    readonly attribute DOMString?       newValue;
    readonly attribute DOMString?       attrName;
    readonly attribute unsigned short   attrChange;
    void               initMutationEvent(in DOMString typeArg, 
                                         in boolean canBubbleArg, 
                                         in boolean cancelableArg, 
                                         in <ref>Node</ref> relatedNodeArg, 
                                         in DOMString? prevValueArg, 
                                         in DOMString? newValueArg, 
                                         in DOMString? attrNameArg, 
                                         in unsigned short attrChangeArg);
  };</webidl>
      <InterfaceInheritance>
        <Name name="Event"/>
      </InterfaceInheritance>
      <Const name="MODIFICATION" value="1" id="::events::MutationEvent::MODIFICATION">
        <webidl>    const unsigned short      MODIFICATION                   = 1;</webidl>
        <Type type="unsigned short"/>
      </Const>
      <Const name="ADDITION" value="2" id="::events::MutationEvent::ADDITION">
        <webidl>    const unsigned short      ADDITION                       = 2;</webidl>
        <Type type="unsigned short"/>
      </Const>
      <Const name="REMOVAL" value="3" id="::events::MutationEvent::REMOVAL">
        <webidl>    const unsigned short      REMOVAL                        = 3;</webidl>
        <Type type="unsigned short"/>
      </Const>
      <Attribute readonly="readonly" name="relatedNode" id="::events::MutationEvent::relatedNode">
        <webidl>    readonly attribute <ref>Node</ref>             relatedNode;</webidl>
        <Type name="Node"/>
      </Attribute>
      <Attribute readonly="readonly" name="prevValue" id="::events::MutationEvent::prevValue">
        <webidl>    readonly attribute DOMString?       prevValue;</webidl>
        <Type type="DOMString" nullable="nullable"/>
      </Attribute>
      <Attribute readonly="readonly" name="newValue" id="::events::MutationEvent::newValue">
        <webidl>    readonly attribute DOMString?       newValue;</webidl>
        <Type type="DOMString" nullable="nullable"/>
      </Attribute>
      <Attribute readonly="readonly" name="attrName" id="::events::MutationEvent::attrName">
        <webidl>    readonly attribute DOMString?       attrName;</webidl>
        <Type type="DOMString" nullable="nullable"/>
      </Attribute>
      <Attribute readonly="readonly" name="attrChange" id="::events::MutationEvent::attrChange">
        <webidl>    readonly attribute unsigned short   attrChange;</webidl>
        <Type type="unsigned short"/>
      </Attribute>
      <Operation name="initMutationEvent" id="::events::MutationEvent::initMutationEvent">
        <webidl>    void               initMutationEvent(in DOMString typeArg, 
                                         in boolean canBubbleArg, 
                                         in boolean cancelableArg, 
                                         in <ref>Node</ref> relatedNodeArg, 
                                         in DOMString? prevValueArg, 
                                         in DOMString? newValueArg, 
                                         in DOMString? attrNameArg, 
                                         in unsigned short attrChangeArg);</webidl>
        <Type type="void"/>
        <ArgumentList>
          <Argument in="in" name="typeArg">
            <Type type="DOMString"/>
          </Argument>
          <Argument in="in" name="canBubbleArg">
            <Type type="boolean"/>
          </Argument>
          <Argument in="in" name="cancelableArg">
            <Type type="boolean"/>
          </Argument>
          <Argument in="in" name="relatedNodeArg">
            <Type name="Node"/>
          </Argument>
          <Argument in="in" name="prevValueArg">
            <Type type="DOMString" nullable="nullable"/>
          </Argument>
          <Argument in="in" name="newValueArg">
            <Type type="DOMString" nullable="nullable"/>
          </Argument>
          <Argument in="in" name="attrNameArg">
            <Type type="DOMString" nullable="nullable"/>
          </Argument>
          <Argument in="in" name="attrChangeArg">
            <Type type="unsigned short"/>
          </Argument>
        </ArgumentList>
      </Operation>
    </Interface>
  </Module>
</Definitions>
<Definitions>
  <Module name="ranges" id="::ranges">
    <webidl>module ranges {

  typedef <ref>dom::Node</ref> Node;
  typedef <ref>dom::Document</ref> Document;
  typedef <ref>dom::DOMException</ref> DOMException;
  typedef <ref>dom::DocumentFragment</ref> DocumentFragment;

  exception RangeException {
    const unsigned short      BAD_BOUNDARYPOINTS_ERR         = 1;
    const unsigned short      INVALID_NODE_TYPE_ERR          = 2;

    unsigned short   code;
  };

  interface Range {
    readonly attribute <ref>Node</ref>             startContainer getraises(<ref>DOMException</ref>);

    readonly attribute long             startOffset getraises(<ref>DOMException</ref>);

    readonly attribute <ref>Node</ref>             endContainer getraises(<ref>DOMException</ref>);

    readonly attribute long             endOffset getraises(<ref>DOMException</ref>);

    readonly attribute boolean          collapsed getraises(<ref>DOMException</ref>);

    readonly attribute <ref>Node</ref>             commonAncestorContainer getraises(<ref>DOMException</ref>);

    void               setStart(in <ref>Node</ref> refNode, 
                                in long offset)
                                        raises(<ref>RangeException</ref>, 
                                               <ref>DOMException</ref>);
    void               setEnd(in <ref>Node</ref> refNode, 
                              in long offset)
                                        raises(<ref>RangeException</ref>, 
                                               <ref>DOMException</ref>);
    void               setStartBefore(in <ref>Node</ref> refNode)
                                        raises(<ref>RangeException</ref>, 
                                               <ref>DOMException</ref>);
    void               setStartAfter(in <ref>Node</ref> refNode)
                                        raises(<ref>RangeException</ref>, 
                                               <ref>DOMException</ref>);
    void               setEndBefore(in <ref>Node</ref> refNode)
                                        raises(<ref>RangeException</ref>, 
                                               <ref>DOMException</ref>);
    void               setEndAfter(in <ref>Node</ref> refNode)
                                        raises(<ref>RangeException</ref>, 
                                               <ref>DOMException</ref>);
    void               collapse(in boolean toStart)
                                        raises(<ref>DOMException</ref>);
    void               selectNode(in <ref>Node</ref> refNode)
                                        raises(<ref>RangeException</ref>, 
                                               <ref>DOMException</ref>);
    void               selectNodeContents(in <ref>Node</ref> refNode)
                                        raises(<ref>RangeException</ref>, 
                                               <ref>DOMException</ref>);

    const unsigned short      START_TO_START                 = 0;
    const unsigned short      START_TO_END                   = 1;
    const unsigned short      END_TO_END                     = 2;
    const unsigned short      END_TO_START                   = 3;

    short              compareBoundaryPoints(in unsigned short how, 
                                             in <ref>Range</ref> sourceRange)
                                        raises(<ref>DOMException</ref>);
    void               deleteContents()
                                        raises(<ref>DOMException</ref>);
    <ref>DocumentFragment</ref>   extractContents()
                                        raises(<ref>DOMException</ref>);
    <ref>DocumentFragment</ref>   cloneContents()
                                        raises(<ref>DOMException</ref>);
    void               insertNode(in <ref>Node</ref> newNode)
                                        raises(<ref>DOMException</ref>, 
                                               <ref>RangeException</ref>);
    void               surroundContents(in <ref>Node</ref> newParent)
                                        raises(<ref>DOMException</ref>, 
                                               <ref>RangeException</ref>);
    <ref>Range</ref>              cloneRange()
                                        raises(<ref>DOMException</ref>);
    DOMString          toString()
                                        raises(<ref>DOMException</ref>);
    void               detach()
                                        raises(<ref>DOMException</ref>);
  };

  interface DocumentRange {
    <ref>Range</ref>              createRange();
  };

  <ref>Document</ref> implements <ref>DocumentRange</ref>;
};</webidl>
    <Typedef name="Node" id="::ranges::Node">
      <webidl>  typedef <ref>dom::Node</ref> Node;</webidl>
      <Type name="domNode"/>
    </Typedef>
    <Typedef name="Document" id="::ranges::Document">
      <webidl>  typedef <ref>dom::Document</ref> Document;</webidl>
      <Type name="domDocument"/>
    </Typedef>
    <Typedef name="DOMException" id="::ranges::DOMException">
      <webidl>  typedef <ref>dom::DOMException</ref> DOMException;</webidl>
      <Type name="domDOMException"/>
    </Typedef>
    <Typedef name="DocumentFragment" id="::ranges::DocumentFragment">
      <webidl>  typedef <ref>dom::DocumentFragment</ref> DocumentFragment;</webidl>
      <Type name="domDocumentFragment"/>
    </Typedef>
    <Exception name="RangeException" id="::ranges::RangeException">
      <webidl>  exception RangeException {
    const unsigned short      BAD_BOUNDARYPOINTS_ERR         = 1;
    const unsigned short      INVALID_NODE_TYPE_ERR          = 2;

    unsigned short   code;
  };</webidl>
      <Const name="BAD_BOUNDARYPOINTS_ERR" value="1" id="::ranges::RangeException::BAD_BOUNDARYPOINTS_ERR">
        <Type type="unsigned short"/>
      </Const>
      <Const name="INVALID_NODE_TYPE_ERR" value="2" id="::ranges::RangeException::INVALID_NODE_TYPE_ERR">
        <Type type="unsigned short"/>
      </Const>
      <ExceptionField name="code" id="::ranges::RangeException::code">
        <Type type="unsigned short"/>
      </ExceptionField>
    </Exception>
    <Interface name="Range" id="::ranges::Range">
      <webidl>  interface Range {
    readonly attribute <ref>Node</ref>             startContainer getraises(<ref>DOMException</ref>);

    readonly attribute long             startOffset getraises(<ref>DOMException</ref>);

    readonly attribute <ref>Node</ref>             endContainer getraises(<ref>DOMException</ref>);

    readonly attribute long             endOffset getraises(<ref>DOMException</ref>);

    readonly attribute boolean          collapsed getraises(<ref>DOMException</ref>);

    readonly attribute <ref>Node</ref>             commonAncestorContainer getraises(<ref>DOMException</ref>);

    void               setStart(in <ref>Node</ref> refNode, 
                                in long offset)
                                        raises(<ref>RangeException</ref>, 
                                               <ref>DOMException</ref>);
    void               setEnd(in <ref>Node</ref> refNode, 
                              in long offset)
                                        raises(<ref>RangeException</ref>, 
                                               <ref>DOMException</ref>);
    void               setStartBefore(in <ref>Node</ref> refNode)
                                        raises(<ref>RangeException</ref>, 
                                               <ref>DOMException</ref>);
    void               setStartAfter(in <ref>Node</ref> refNode)
                                        raises(<ref>RangeException</ref>, 
                                               <ref>DOMException</ref>);
    void               setEndBefore(in <ref>Node</ref> refNode)
                                        raises(<ref>RangeException</ref>, 
                                               <ref>DOMException</ref>);
    void               setEndAfter(in <ref>Node</ref> refNode)
                                        raises(<ref>RangeException</ref>, 
                                               <ref>DOMException</ref>);
    void               collapse(in boolean toStart)
                                        raises(<ref>DOMException</ref>);
    void               selectNode(in <ref>Node</ref> refNode)
                                        raises(<ref>RangeException</ref>, 
                                               <ref>DOMException</ref>);
    void               selectNodeContents(in <ref>Node</ref> refNode)
                                        raises(<ref>RangeException</ref>, 
                                               <ref>DOMException</ref>);

    const unsigned short      START_TO_START                 = 0;
    const unsigned short      START_TO_END                   = 1;
    const unsigned short      END_TO_END                     = 2;
    const unsigned short      END_TO_START                   = 3;

    short              compareBoundaryPoints(in unsigned short how, 
                                             in <ref>Range</ref> sourceRange)
                                        raises(<ref>DOMException</ref>);
    void               deleteContents()
                                        raises(<ref>DOMException</ref>);
    <ref>DocumentFragment</ref>   extractContents()
                                        raises(<ref>DOMException</ref>);
    <ref>DocumentFragment</ref>   cloneContents()
                                        raises(<ref>DOMException</ref>);
    void               insertNode(in <ref>Node</ref> newNode)
                                        raises(<ref>DOMException</ref>, 
                                               <ref>RangeException</ref>);
    void               surroundContents(in <ref>Node</ref> newParent)
                                        raises(<ref>DOMException</ref>, 
                                               <ref>RangeException</ref>);
    <ref>Range</ref>              cloneRange()
                                        raises(<ref>DOMException</ref>);
    DOMString          toString()
                                        raises(<ref>DOMException</ref>);
    void               detach()
                                        raises(<ref>DOMException</ref>);
  };</webidl>
      <Attribute readonly="readonly" name="startContainer" id="::ranges::Range::startContainer">
        <webidl>    readonly attribute <ref>Node</ref>             startContainer getraises(<ref>DOMException</ref>);</webidl>
        <Type name="Node"/>
        <GetRaises>
          <RaiseException name="DOMException"/>
        </GetRaises>
      </Attribute>
      <Attribute readonly="readonly" name="startOffset" id="::ranges::Range::startOffset">
        <webidl>    readonly attribute long             startOffset getraises(<ref>DOMException</ref>);</webidl>
        <Type type="long"/>
        <GetRaises>
          <RaiseException name="DOMException"/>
        </GetRaises>
      </Attribute>
      <Attribute readonly="readonly" name="endContainer" id="::ranges::Range::endContainer">
        <webidl>    readonly attribute <ref>Node</ref>             endContainer getraises(<ref>DOMException</ref>);</webidl>
        <Type name="Node"/>
        <GetRaises>
          <RaiseException name="DOMException"/>
        </GetRaises>
      </Attribute>
      <Attribute readonly="readonly" name="endOffset" id="::ranges::Range::endOffset">
        <webidl>    readonly attribute long             endOffset getraises(<ref>DOMException</ref>);</webidl>
        <Type type="long"/>
        <GetRaises>
          <RaiseException name="DOMException"/>
        </GetRaises>
      </Attribute>
      <Attribute readonly="readonly" name="collapsed" id="::ranges::Range::collapsed">
        <webidl>    readonly attribute boolean          collapsed getraises(<ref>DOMException</ref>);</webidl>
        <Type type="boolean"/>
        <GetRaises>
          <RaiseException name="DOMException"/>
        </GetRaises>
      </Attribute>
      <Attribute readonly="readonly" name="commonAncestorContainer" id="::ranges::Range::commonAncestorContainer">
        <webidl>    readonly attribute <ref>Node</ref>             commonAncestorContainer getraises(<ref>DOMException</ref>);</webidl>
        <Type name="Node"/>
        <GetRaises>
          <RaiseException name="DOMException"/>
        </GetRaises>
      </Attribute>
      <Operation name="setStart" id="::ranges::Range::setStart">
        <webidl>    void               setStart(in <ref>Node</ref> refNode, 
                                in long offset)
                                        raises(<ref>RangeException</ref>, 
                                               <ref>DOMException</ref>);</webidl>
        <Type type="void"/>
        <ArgumentList>
          <Argument in="in" name="refNode">
            <Type name="Node"/>
          </Argument>
          <Argument in="in" name="offset">
            <Type type="long"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="RangeException"/>
          <RaiseException name="DOMException"/>
        </Raises>
      </Operation>
      <Operation name="setEnd" id="::ranges::Range::setEnd">
        <webidl>    void               setEnd(in <ref>Node</ref> refNode, 
                              in long offset)
                                        raises(<ref>RangeException</ref>, 
                                               <ref>DOMException</ref>);</webidl>
        <Type type="void"/>
        <ArgumentList>
          <Argument in="in" name="refNode">
            <Type name="Node"/>
          </Argument>
          <Argument in="in" name="offset">
            <Type type="long"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="RangeException"/>
          <RaiseException name="DOMException"/>
        </Raises>
      </Operation>
      <Operation name="setStartBefore" id="::ranges::Range::setStartBefore">
        <webidl>    void               setStartBefore(in <ref>Node</ref> refNode)
                                        raises(<ref>RangeException</ref>, 
                                               <ref>DOMException</ref>);</webidl>
        <Type type="void"/>
        <ArgumentList>
          <Argument in="in" name="refNode">
            <Type name="Node"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="RangeException"/>
          <RaiseException name="DOMException"/>
        </Raises>
      </Operation>
      <Operation name="setStartAfter" id="::ranges::Range::setStartAfter">
        <webidl>    void               setStartAfter(in <ref>Node</ref> refNode)
                                        raises(<ref>RangeException</ref>, 
                                               <ref>DOMException</ref>);</webidl>
        <Type type="void"/>
        <ArgumentList>
          <Argument in="in" name="refNode">
            <Type name="Node"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="RangeException"/>
          <RaiseException name="DOMException"/>
        </Raises>
      </Operation>
      <Operation name="setEndBefore" id="::ranges::Range::setEndBefore">
        <webidl>    void               setEndBefore(in <ref>Node</ref> refNode)
                                        raises(<ref>RangeException</ref>, 
                                               <ref>DOMException</ref>);</webidl>
        <Type type="void"/>
        <ArgumentList>
          <Argument in="in" name="refNode">
            <Type name="Node"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="RangeException"/>
          <RaiseException name="DOMException"/>
        </Raises>
      </Operation>
      <Operation name="setEndAfter" id="::ranges::Range::setEndAfter">
        <webidl>    void               setEndAfter(in <ref>Node</ref> refNode)
                                        raises(<ref>RangeException</ref>, 
                                               <ref>DOMException</ref>);</webidl>
        <Type type="void"/>
        <ArgumentList>
          <Argument in="in" name="refNode">
            <Type name="Node"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="RangeException"/>
          <RaiseException name="DOMException"/>
        </Raises>
      </Operation>
      <Operation name="collapse" id="::ranges::Range::collapse">
        <webidl>    void               collapse(in boolean toStart)
                                        raises(<ref>DOMException</ref>);</webidl>
        <Type type="void"/>
        <ArgumentList>
          <Argument in="in" name="toStart">
            <Type type="boolean"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="DOMException"/>
        </Raises>
      </Operation>
      <Operation name="selectNode" id="::ranges::Range::selectNode">
        <webidl>    void               selectNode(in <ref>Node</ref> refNode)
                                        raises(<ref>RangeException</ref>, 
                                               <ref>DOMException</ref>);</webidl>
        <Type type="void"/>
        <ArgumentList>
          <Argument in="in" name="refNode">
            <Type name="Node"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="RangeException"/>
          <RaiseException name="DOMException"/>
        </Raises>
      </Operation>
      <Operation name="selectNodeContents" id="::ranges::Range::selectNodeContents">
        <webidl>    void               selectNodeContents(in <ref>Node</ref> refNode)
                                        raises(<ref>RangeException</ref>, 
                                               <ref>DOMException</ref>);</webidl>
        <Type type="void"/>
        <ArgumentList>
          <Argument in="in" name="refNode">
            <Type name="Node"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="RangeException"/>
          <RaiseException name="DOMException"/>
        </Raises>
      </Operation>
      <Const name="START_TO_START" value="0" id="::ranges::Range::START_TO_START">
        <webidl>    const unsigned short      START_TO_START                 = 0;</webidl>
        <Type type="unsigned short"/>
      </Const>
      <Const name="START_TO_END" value="1" id="::ranges::Range::START_TO_END">
        <webidl>    const unsigned short      START_TO_END                   = 1;</webidl>
        <Type type="unsigned short"/>
      </Const>
      <Const name="END_TO_END" value="2" id="::ranges::Range::END_TO_END">
        <webidl>    const unsigned short      END_TO_END                     = 2;</webidl>
        <Type type="unsigned short"/>
      </Const>
      <Const name="END_TO_START" value="3" id="::ranges::Range::END_TO_START">
        <webidl>    const unsigned short      END_TO_START                   = 3;</webidl>
        <Type type="unsigned short"/>
      </Const>
      <Operation name="compareBoundaryPoints" id="::ranges::Range::compareBoundaryPoints">
        <webidl>    short              compareBoundaryPoints(in unsigned short how, 
                                             in <ref>Range</ref> sourceRange)
                                        raises(<ref>DOMException</ref>);</webidl>
        <Type type="short"/>
        <ArgumentList>
          <Argument in="in" name="how">
            <Type type="unsigned short"/>
          </Argument>
          <Argument in="in" name="sourceRange">
            <Type name="Range"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="DOMException"/>
        </Raises>
      </Operation>
      <Operation name="deleteContents" id="::ranges::Range::deleteContents">
        <webidl>    void               deleteContents()
                                        raises(<ref>DOMException</ref>);</webidl>
        <Type type="void"/>
        <ArgumentList/>
        <Raises>
          <RaiseException name="DOMException"/>
        </Raises>
      </Operation>
      <Operation name="extractContents" id="::ranges::Range::extractContents">
        <webidl>    <ref>DocumentFragment</ref>   extractContents()
                                        raises(<ref>DOMException</ref>);</webidl>
        <Type name="DocumentFragment"/>
        <ArgumentList/>
        <Raises>
          <RaiseException name="DOMException"/>
        </Raises>
      </Operation>
      <Operation name="cloneContents" id="::ranges::Range::cloneContents">
        <webidl>    <ref>DocumentFragment</ref>   cloneContents()
                                        raises(<ref>DOMException</ref>);</webidl>
        <Type name="DocumentFragment"/>
        <ArgumentList/>
        <Raises>
          <RaiseException name="DOMException"/>
        </Raises>
      </Operation>
      <Operation name="insertNode" id="::ranges::Range::insertNode">
        <webidl>    void               insertNode(in <ref>Node</ref> newNode)
                                        raises(<ref>DOMException</ref>, 
                                               <ref>RangeException</ref>);</webidl>
        <Type type="void"/>
        <ArgumentList>
          <Argument in="in" name="newNode">
            <Type name="Node"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="DOMException"/>
          <RaiseException name="RangeException"/>
        </Raises>
      </Operation>
      <Operation name="surroundContents" id="::ranges::Range::surroundContents">
        <webidl>    void               surroundContents(in <ref>Node</ref> newParent)
                                        raises(<ref>DOMException</ref>, 
                                               <ref>RangeException</ref>);</webidl>
        <Type type="void"/>
        <ArgumentList>
          <Argument in="in" name="newParent">
            <Type name="Node"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="DOMException"/>
          <RaiseException name="RangeException"/>
        </Raises>
      </Operation>
      <Operation name="cloneRange" id="::ranges::Range::cloneRange">
        <webidl>    <ref>Range</ref>              cloneRange()
                                        raises(<ref>DOMException</ref>);</webidl>
        <Type name="Range"/>
        <ArgumentList/>
        <Raises>
          <RaiseException name="DOMException"/>
        </Raises>
      </Operation>
      <Operation name="toString" id="::ranges::Range::toString">
        <webidl>    DOMString          toString()
                                        raises(<ref>DOMException</ref>);</webidl>
        <Type type="DOMString"/>
        <ArgumentList/>
        <Raises>
          <RaiseException name="DOMException"/>
        </Raises>
      </Operation>
      <Operation name="detach" id="::ranges::Range::detach">
        <webidl>    void               detach()
                                        raises(<ref>DOMException</ref>);</webidl>
        <Type type="void"/>
        <ArgumentList/>
        <Raises>
          <RaiseException name="DOMException"/>
        </Raises>
      </Operation>
    </Interface>
    <Interface name="DocumentRange" id="::ranges::DocumentRange">
      <webidl>  interface DocumentRange {
    <ref>Range</ref>              createRange();
  };</webidl>
      <Operation name="createRange" id="::ranges::DocumentRange::createRange">
        <webidl>    <ref>Range</ref>              createRange();</webidl>
        <Type name="Range"/>
        <ArgumentList/>
      </Operation>
    </Interface>
    <Implements name1="Document" name2="DocumentRange">
      <webidl>  <ref>Document</ref> implements <ref>DocumentRange</ref>;</webidl>
    </Implements>
  </Module>
</Definitions>
<Definitions>
  <Module name="stylesheets" id="::stylesheets">
    <webidl>module stylesheets {

  typedef <ref>dom::Node</ref> Node;
  typedef <ref>dom::Document</ref> Document;
  typedef <ref>dom::ProcessingInstruction</ref> ProcessingInstruction;
  typedef <ref>dom::DOMException</ref> DOMException;

  [PrototypeRoot]
  interface StyleSheet {
    readonly attribute DOMString        type;
             attribute boolean          disabled;
    readonly attribute <ref>Node</ref>             ownerNode;
    readonly attribute <ref>StyleSheet</ref>       parentStyleSheet;
    readonly attribute DOMString?       href;
    readonly attribute DOMString        title;
    readonly attribute <ref>MediaList</ref>        media;
  };

  interface StyleSheetList {
    readonly attribute unsigned long length;
    getter <ref>StyleSheet</ref> item(in unsigned long index);
  };

  interface MediaList {
             attribute DOMString        mediaText setraises(<ref>DOMException</ref>);

    readonly attribute unsigned long    length;
    getter DOMString? item(in unsigned long index);
    void               deleteMedium(in DOMString oldMedium)
                                        raises(<ref>DOMException</ref>);
    void               appendMedium(in DOMString newMedium)
                                        raises(<ref>DOMException</ref>);
  };

  interface LinkStyle {
    readonly attribute <ref>StyleSheet</ref>       sheet;
  };

  <ref>ProcessingInstruction</ref> implements <ref>LinkStyle</ref>;

  interface DocumentStyle {
    readonly attribute <ref>StyleSheetList</ref>   styleSheets;
  };

  <ref>Document</ref> implements <ref>DocumentStyle</ref>;
};</webidl>
    <Typedef name="Node" id="::stylesheets::Node">
      <webidl>  typedef <ref>dom::Node</ref> Node;</webidl>
      <Type name="domNode"/>
    </Typedef>
    <Typedef name="Document" id="::stylesheets::Document">
      <webidl>  typedef <ref>dom::Document</ref> Document;</webidl>
      <Type name="domDocument"/>
    </Typedef>
    <Typedef name="ProcessingInstruction" id="::stylesheets::ProcessingInstruction">
      <webidl>  typedef <ref>dom::ProcessingInstruction</ref> ProcessingInstruction;</webidl>
      <Type name="domProcessingInstruction"/>
    </Typedef>
    <Typedef name="DOMException" id="::stylesheets::DOMException">
      <webidl>  typedef <ref>dom::DOMException</ref> DOMException;</webidl>
      <Type name="domDOMException"/>
    </Typedef>
    <Interface name="StyleSheet" id="::stylesheets::StyleSheet">
      <webidl>  [PrototypeRoot]
  interface StyleSheet {
    readonly attribute DOMString        type;
             attribute boolean          disabled;
    readonly attribute <ref>Node</ref>             ownerNode;
    readonly attribute <ref>StyleSheet</ref>       parentStyleSheet;
    readonly attribute DOMString?       href;
    readonly attribute DOMString        title;
    readonly attribute <ref>MediaList</ref>        media;
  };</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="PrototypeRoot"/>
      </ExtendedAttributeList>
      <Attribute readonly="readonly" name="type" id="::stylesheets::StyleSheet::type">
        <webidl>    readonly attribute DOMString        type;</webidl>
        <Type type="DOMString"/>
      </Attribute>
      <Attribute name="disabled" id="::stylesheets::StyleSheet::disabled">
        <webidl>             attribute boolean          disabled;</webidl>
        <Type type="boolean"/>
      </Attribute>
      <Attribute readonly="readonly" name="ownerNode" id="::stylesheets::StyleSheet::ownerNode">
        <webidl>    readonly attribute <ref>Node</ref>             ownerNode;</webidl>
        <Type name="Node"/>
      </Attribute>
      <Attribute readonly="readonly" name="parentStyleSheet" id="::stylesheets::StyleSheet::parentStyleSheet">
        <webidl>    readonly attribute <ref>StyleSheet</ref>       parentStyleSheet;</webidl>
        <Type name="StyleSheet"/>
      </Attribute>
      <Attribute readonly="readonly" name="href" id="::stylesheets::StyleSheet::href">
        <webidl>    readonly attribute DOMString?       href;</webidl>
        <Type type="DOMString" nullable="nullable"/>
      </Attribute>
      <Attribute readonly="readonly" name="title" id="::stylesheets::StyleSheet::title">
        <webidl>    readonly attribute DOMString        title;</webidl>
        <Type type="DOMString"/>
      </Attribute>
      <Attribute readonly="readonly" name="media" id="::stylesheets::StyleSheet::media">
        <webidl>    readonly attribute <ref>MediaList</ref>        media;</webidl>
        <Type name="MediaList"/>
      </Attribute>
    </Interface>
    <Interface name="StyleSheetList" id="::stylesheets::StyleSheetList">
      <webidl>  interface StyleSheetList {
    readonly attribute unsigned long length;
    getter <ref>StyleSheet</ref> item(in unsigned long index);
  };</webidl>
      <Attribute readonly="readonly" name="length" id="::stylesheets::StyleSheetList::length">
        <webidl>    readonly attribute unsigned long length;</webidl>
        <Type type="unsigned long"/>
      </Attribute>
      <Operation getter="getter" name="item" id="::stylesheets::StyleSheetList::item">
        <webidl>    getter <ref>StyleSheet</ref> item(in unsigned long index);</webidl>
        <Type name="StyleSheet"/>
        <ArgumentList>
          <Argument in="in" name="index">
            <Type type="unsigned long"/>
          </Argument>
        </ArgumentList>
      </Operation>
    </Interface>
    <Interface name="MediaList" id="::stylesheets::MediaList">
      <webidl>  interface MediaList {
             attribute DOMString        mediaText setraises(<ref>DOMException</ref>);

    readonly attribute unsigned long    length;
    getter DOMString? item(in unsigned long index);
    void               deleteMedium(in DOMString oldMedium)
                                        raises(<ref>DOMException</ref>);
    void               appendMedium(in DOMString newMedium)
                                        raises(<ref>DOMException</ref>);
  };</webidl>
      <Attribute name="mediaText" id="::stylesheets::MediaList::mediaText">
        <webidl>             attribute DOMString        mediaText setraises(<ref>DOMException</ref>);</webidl>
        <Type type="DOMString"/>
        <SetRaises>
          <RaiseException name="DOMException"/>
        </SetRaises>
      </Attribute>
      <Attribute readonly="readonly" name="length" id="::stylesheets::MediaList::length">
        <webidl>    readonly attribute unsigned long    length;</webidl>
        <Type type="unsigned long"/>
      </Attribute>
      <Operation getter="getter" name="item" id="::stylesheets::MediaList::item">
        <webidl>    getter DOMString? item(in unsigned long index);</webidl>
        <Type type="DOMString" nullable="nullable"/>
        <ArgumentList>
          <Argument in="in" name="index">
            <Type type="unsigned long"/>
          </Argument>
        </ArgumentList>
      </Operation>
      <Operation name="deleteMedium" id="::stylesheets::MediaList::deleteMedium">
        <webidl>    void               deleteMedium(in DOMString oldMedium)
                                        raises(<ref>DOMException</ref>);</webidl>
        <Type type="void"/>
        <ArgumentList>
          <Argument in="in" name="oldMedium">
            <Type type="DOMString"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="DOMException"/>
        </Raises>
      </Operation>
      <Operation name="appendMedium" id="::stylesheets::MediaList::appendMedium">
        <webidl>    void               appendMedium(in DOMString newMedium)
                                        raises(<ref>DOMException</ref>);</webidl>
        <Type type="void"/>
        <ArgumentList>
          <Argument in="in" name="newMedium">
            <Type type="DOMString"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="DOMException"/>
        </Raises>
      </Operation>
    </Interface>
    <Interface name="LinkStyle" id="::stylesheets::LinkStyle">
      <webidl>  interface LinkStyle {
    readonly attribute <ref>StyleSheet</ref>       sheet;
  };</webidl>
      <Attribute readonly="readonly" name="sheet" id="::stylesheets::LinkStyle::sheet">
        <webidl>    readonly attribute <ref>StyleSheet</ref>       sheet;</webidl>
        <Type name="StyleSheet"/>
      </Attribute>
    </Interface>
    <Implements name1="ProcessingInstruction" name2="LinkStyle">
      <webidl>  <ref>ProcessingInstruction</ref> implements <ref>LinkStyle</ref>;</webidl>
    </Implements>
    <Interface name="DocumentStyle" id="::stylesheets::DocumentStyle">
      <webidl>  interface DocumentStyle {
    readonly attribute <ref>StyleSheetList</ref>   styleSheets;
  };</webidl>
      <Attribute readonly="readonly" name="styleSheets" id="::stylesheets::DocumentStyle::styleSheets">
        <webidl>    readonly attribute <ref>StyleSheetList</ref>   styleSheets;</webidl>
        <Type name="StyleSheetList"/>
      </Attribute>
    </Interface>
    <Implements name1="Document" name2="DocumentStyle">
      <webidl>  <ref>Document</ref> implements <ref>DocumentStyle</ref>;</webidl>
    </Implements>
  </Module>
</Definitions>
<Definitions>
  <Module name="traversal" id="::traversal">
    <webidl>module traversal {

  typedef <ref>dom::Node</ref> Node;
  typedef <ref>dom::DOMException</ref> DOMException;

  interface NodeFilter {};

  interface NodeIterator {
    readonly attribute <ref>Node</ref>             root;
    readonly attribute unsigned long    whatToShow;
    readonly attribute <ref>NodeFilter</ref>       filter;
    readonly attribute boolean          expandEntityReferences;
    <ref>Node</ref>               nextNode()
                                        raises(<ref>DOMException</ref>);
    <ref>Node</ref>               previousNode()
                                        raises(<ref>DOMException</ref>);
    void               detach();
  };

  [Callback]
  interface NodeFilter {

    const short               FILTER_ACCEPT                  = 1;
    const short               FILTER_REJECT                  = 2;
    const short               FILTER_SKIP                    = 3;


    const unsigned long       SHOW_ALL                       = 0xFFFFFFFF;
    const unsigned long       SHOW_ELEMENT                   = 0x00000001;
    const unsigned long       SHOW_ATTRIBUTE                 = 0x00000002;
    const unsigned long       SHOW_TEXT                      = 0x00000004;
    const unsigned long       SHOW_CDATA_SECTION             = 0x00000008;
    const unsigned long       SHOW_ENTITY_REFERENCE          = 0x00000010;
    const unsigned long       SHOW_ENTITY                    = 0x00000020;
    const unsigned long       SHOW_PROCESSING_INSTRUCTION    = 0x00000040;
    const unsigned long       SHOW_COMMENT                   = 0x00000080;
    const unsigned long       SHOW_DOCUMENT                  = 0x00000100;
    const unsigned long       SHOW_DOCUMENT_TYPE             = 0x00000200;
    const unsigned long       SHOW_DOCUMENT_FRAGMENT         = 0x00000400;
    const unsigned long       SHOW_NOTATION                  = 0x00000800;

    short              acceptNode(in <ref>Node</ref> n);
  };

  interface TreeWalker {
    readonly attribute <ref>Node</ref>             root;
    readonly attribute unsigned long    whatToShow;
    readonly attribute <ref>NodeFilter</ref>       filter;
    readonly attribute boolean          expandEntityReferences;
             attribute <ref>Node</ref>             currentNode setraises(<ref>DOMException</ref>);

    <ref>Node</ref>               parentNode();
    <ref>Node</ref>               firstChild();
    <ref>Node</ref>               lastChild();
    <ref>Node</ref>               previousSibling();
    <ref>Node</ref>               nextSibling();
    <ref>Node</ref>               previousNode();
    <ref>Node</ref>               nextNode();
  };

  interface DocumentTraversal {
    <ref>NodeIterator</ref>       createNodeIterator(in <ref>Node</ref> root, 
                                          in unsigned long whatToShow, 
                                          in <ref>NodeFilter</ref> filter, 
                                          in boolean entityReferenceExpansion)
                                        raises(<ref>DOMException</ref>);
    <ref>TreeWalker</ref>         createTreeWalker(in <ref>Node</ref> root, 
                                        in unsigned long whatToShow, 
                                        in <ref>NodeFilter</ref> filter, 
                                        in boolean entityReferenceExpansion)
                                        raises(<ref>DOMException</ref>);
  };

  <ref>Document</ref> implements <ref>DocumentTraversal</ref>;
};</webidl>
    <Typedef name="Node" id="::traversal::Node">
      <webidl>  typedef <ref>dom::Node</ref> Node;</webidl>
      <Type name="domNode"/>
    </Typedef>
    <Typedef name="DOMException" id="::traversal::DOMException">
      <webidl>  typedef <ref>dom::DOMException</ref> DOMException;</webidl>
      <Type name="domDOMException"/>
    </Typedef>
    <Interface name="NodeFilter" id="::traversal::NodeFilter">
      <webidl>  interface NodeFilter {};</webidl>
    </Interface>
    <Interface name="NodeIterator" id="::traversal::NodeIterator">
      <webidl>  interface NodeIterator {
    readonly attribute <ref>Node</ref>             root;
    readonly attribute unsigned long    whatToShow;
    readonly attribute <ref>NodeFilter</ref>       filter;
    readonly attribute boolean          expandEntityReferences;
    <ref>Node</ref>               nextNode()
                                        raises(<ref>DOMException</ref>);
    <ref>Node</ref>               previousNode()
                                        raises(<ref>DOMException</ref>);
    void               detach();
  };</webidl>
      <Attribute readonly="readonly" name="root" id="::traversal::NodeIterator::root">
        <webidl>    readonly attribute <ref>Node</ref>             root;</webidl>
        <Type name="Node"/>
      </Attribute>
      <Attribute readonly="readonly" name="whatToShow" id="::traversal::NodeIterator::whatToShow">
        <webidl>    readonly attribute unsigned long    whatToShow;</webidl>
        <Type type="unsigned long"/>
      </Attribute>
      <Attribute readonly="readonly" name="filter" id="::traversal::NodeIterator::filter">
        <webidl>    readonly attribute <ref>NodeFilter</ref>       filter;</webidl>
        <Type name="NodeFilter"/>
      </Attribute>
      <Attribute readonly="readonly" name="expandEntityReferences" id="::traversal::NodeIterator::expandEntityReferences">
        <webidl>    readonly attribute boolean          expandEntityReferences;</webidl>
        <Type type="boolean"/>
      </Attribute>
      <Operation name="nextNode" id="::traversal::NodeIterator::nextNode">
        <webidl>    <ref>Node</ref>               nextNode()
                                        raises(<ref>DOMException</ref>);</webidl>
        <Type name="Node"/>
        <ArgumentList/>
        <Raises>
          <RaiseException name="DOMException"/>
        </Raises>
      </Operation>
      <Operation name="previousNode" id="::traversal::NodeIterator::previousNode">
        <webidl>    <ref>Node</ref>               previousNode()
                                        raises(<ref>DOMException</ref>);</webidl>
        <Type name="Node"/>
        <ArgumentList/>
        <Raises>
          <RaiseException name="DOMException"/>
        </Raises>
      </Operation>
      <Operation name="detach" id="::traversal::NodeIterator::detach">
        <webidl>    void               detach();</webidl>
        <Type type="void"/>
        <ArgumentList/>
      </Operation>
    </Interface>
    <Interface name="NodeFilter" id="::traversal::NodeFilter">
      <webidl>  [Callback]
  interface NodeFilter {

    const short               FILTER_ACCEPT                  = 1;
    const short               FILTER_REJECT                  = 2;
    const short               FILTER_SKIP                    = 3;


    const unsigned long       SHOW_ALL                       = 0xFFFFFFFF;
    const unsigned long       SHOW_ELEMENT                   = 0x00000001;
    const unsigned long       SHOW_ATTRIBUTE                 = 0x00000002;
    const unsigned long       SHOW_TEXT                      = 0x00000004;
    const unsigned long       SHOW_CDATA_SECTION             = 0x00000008;
    const unsigned long       SHOW_ENTITY_REFERENCE          = 0x00000010;
    const unsigned long       SHOW_ENTITY                    = 0x00000020;
    const unsigned long       SHOW_PROCESSING_INSTRUCTION    = 0x00000040;
    const unsigned long       SHOW_COMMENT                   = 0x00000080;
    const unsigned long       SHOW_DOCUMENT                  = 0x00000100;
    const unsigned long       SHOW_DOCUMENT_TYPE             = 0x00000200;
    const unsigned long       SHOW_DOCUMENT_FRAGMENT         = 0x00000400;
    const unsigned long       SHOW_NOTATION                  = 0x00000800;

    short              acceptNode(in <ref>Node</ref> n);
  };</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="Callback"/>
      </ExtendedAttributeList>
      <Const name="FILTER_ACCEPT" value="1" id="::traversal::NodeFilter::FILTER_ACCEPT">
        <webidl>    const short               FILTER_ACCEPT                  = 1;</webidl>
        <Type type="short"/>
      </Const>
      <Const name="FILTER_REJECT" value="2" id="::traversal::NodeFilter::FILTER_REJECT">
        <webidl>    const short               FILTER_REJECT                  = 2;</webidl>
        <Type type="short"/>
      </Const>
      <Const name="FILTER_SKIP" value="3" id="::traversal::NodeFilter::FILTER_SKIP">
        <webidl>    const short               FILTER_SKIP                    = 3;</webidl>
        <Type type="short"/>
      </Const>
      <Const name="SHOW_ALL" value="0xFFFFFFFF" id="::traversal::NodeFilter::SHOW_ALL">
        <webidl>    const unsigned long       SHOW_ALL                       = 0xFFFFFFFF;</webidl>
        <Type type="unsigned long"/>
      </Const>
      <Const name="SHOW_ELEMENT" value="0x00000001" id="::traversal::NodeFilter::SHOW_ELEMENT">
        <webidl>    const unsigned long       SHOW_ELEMENT                   = 0x00000001;</webidl>
        <Type type="unsigned long"/>
      </Const>
      <Const name="SHOW_ATTRIBUTE" value="0x00000002" id="::traversal::NodeFilter::SHOW_ATTRIBUTE">
        <webidl>    const unsigned long       SHOW_ATTRIBUTE                 = 0x00000002;</webidl>
        <Type type="unsigned long"/>
      </Const>
      <Const name="SHOW_TEXT" value="0x00000004" id="::traversal::NodeFilter::SHOW_TEXT">
        <webidl>    const unsigned long       SHOW_TEXT                      = 0x00000004;</webidl>
        <Type type="unsigned long"/>
      </Const>
      <Const name="SHOW_CDATA_SECTION" value="0x00000008" id="::traversal::NodeFilter::SHOW_CDATA_SECTION">
        <webidl>    const unsigned long       SHOW_CDATA_SECTION             = 0x00000008;</webidl>
        <Type type="unsigned long"/>
      </Const>
      <Const name="SHOW_ENTITY_REFERENCE" value="0x00000010" id="::traversal::NodeFilter::SHOW_ENTITY_REFERENCE">
        <webidl>    const unsigned long       SHOW_ENTITY_REFERENCE          = 0x00000010;</webidl>
        <Type type="unsigned long"/>
      </Const>
      <Const name="SHOW_ENTITY" value="0x00000020" id="::traversal::NodeFilter::SHOW_ENTITY">
        <webidl>    const unsigned long       SHOW_ENTITY                    = 0x00000020;</webidl>
        <Type type="unsigned long"/>
      </Const>
      <Const name="SHOW_PROCESSING_INSTRUCTION" value="0x00000040" id="::traversal::NodeFilter::SHOW_PROCESSING_INSTRUCTION">
        <webidl>    const unsigned long       SHOW_PROCESSING_INSTRUCTION    = 0x00000040;</webidl>
        <Type type="unsigned long"/>
      </Const>
      <Const name="SHOW_COMMENT" value="0x00000080" id="::traversal::NodeFilter::SHOW_COMMENT">
        <webidl>    const unsigned long       SHOW_COMMENT                   = 0x00000080;</webidl>
        <Type type="unsigned long"/>
      </Const>
      <Const name="SHOW_DOCUMENT" value="0x00000100" id="::traversal::NodeFilter::SHOW_DOCUMENT">
        <webidl>    const unsigned long       SHOW_DOCUMENT                  = 0x00000100;</webidl>
        <Type type="unsigned long"/>
      </Const>
      <Const name="SHOW_DOCUMENT_TYPE" value="0x00000200" id="::traversal::NodeFilter::SHOW_DOCUMENT_TYPE">
        <webidl>    const unsigned long       SHOW_DOCUMENT_TYPE             = 0x00000200;</webidl>
        <Type type="unsigned long"/>
      </Const>
      <Const name="SHOW_DOCUMENT_FRAGMENT" value="0x00000400" id="::traversal::NodeFilter::SHOW_DOCUMENT_FRAGMENT">
        <webidl>    const unsigned long       SHOW_DOCUMENT_FRAGMENT         = 0x00000400;</webidl>
        <Type type="unsigned long"/>
      </Const>
      <Const name="SHOW_NOTATION" value="0x00000800" id="::traversal::NodeFilter::SHOW_NOTATION">
        <webidl>    const unsigned long       SHOW_NOTATION                  = 0x00000800;</webidl>
        <Type type="unsigned long"/>
      </Const>
      <Operation name="acceptNode" id="::traversal::NodeFilter::acceptNode">
        <webidl>    short              acceptNode(in <ref>Node</ref> n);</webidl>
        <Type type="short"/>
        <ArgumentList>
          <Argument in="in" name="n">
            <Type name="Node"/>
          </Argument>
        </ArgumentList>
      </Operation>
    </Interface>
    <Interface name="TreeWalker" id="::traversal::TreeWalker">
      <webidl>  interface TreeWalker {
    readonly attribute <ref>Node</ref>             root;
    readonly attribute unsigned long    whatToShow;
    readonly attribute <ref>NodeFilter</ref>       filter;
    readonly attribute boolean          expandEntityReferences;
             attribute <ref>Node</ref>             currentNode setraises(<ref>DOMException</ref>);

    <ref>Node</ref>               parentNode();
    <ref>Node</ref>               firstChild();
    <ref>Node</ref>               lastChild();
    <ref>Node</ref>               previousSibling();
    <ref>Node</ref>               nextSibling();
    <ref>Node</ref>               previousNode();
    <ref>Node</ref>               nextNode();
  };</webidl>
      <Attribute readonly="readonly" name="root" id="::traversal::TreeWalker::root">
        <webidl>    readonly attribute <ref>Node</ref>             root;</webidl>
        <Type name="Node"/>
      </Attribute>
      <Attribute readonly="readonly" name="whatToShow" id="::traversal::TreeWalker::whatToShow">
        <webidl>    readonly attribute unsigned long    whatToShow;</webidl>
        <Type type="unsigned long"/>
      </Attribute>
      <Attribute readonly="readonly" name="filter" id="::traversal::TreeWalker::filter">
        <webidl>    readonly attribute <ref>NodeFilter</ref>       filter;</webidl>
        <Type name="NodeFilter"/>
      </Attribute>
      <Attribute readonly="readonly" name="expandEntityReferences" id="::traversal::TreeWalker::expandEntityReferences">
        <webidl>    readonly attribute boolean          expandEntityReferences;</webidl>
        <Type type="boolean"/>
      </Attribute>
      <Attribute name="currentNode" id="::traversal::TreeWalker::currentNode">
        <webidl>             attribute <ref>Node</ref>             currentNode setraises(<ref>DOMException</ref>);</webidl>
        <Type name="Node"/>
        <SetRaises>
          <RaiseException name="DOMException"/>
        </SetRaises>
      </Attribute>
      <Operation name="parentNode" id="::traversal::TreeWalker::parentNode">
        <webidl>    <ref>Node</ref>               parentNode();</webidl>
        <Type name="Node"/>
        <ArgumentList/>
      </Operation>
      <Operation name="firstChild" id="::traversal::TreeWalker::firstChild">
        <webidl>    <ref>Node</ref>               firstChild();</webidl>
        <Type name="Node"/>
        <ArgumentList/>
      </Operation>
      <Operation name="lastChild" id="::traversal::TreeWalker::lastChild">
        <webidl>    <ref>Node</ref>               lastChild();</webidl>
        <Type name="Node"/>
        <ArgumentList/>
      </Operation>
      <Operation name="previousSibling" id="::traversal::TreeWalker::previousSibling">
        <webidl>    <ref>Node</ref>               previousSibling();</webidl>
        <Type name="Node"/>
        <ArgumentList/>
      </Operation>
      <Operation name="nextSibling" id="::traversal::TreeWalker::nextSibling">
        <webidl>    <ref>Node</ref>               nextSibling();</webidl>
        <Type name="Node"/>
        <ArgumentList/>
      </Operation>
      <Operation name="previousNode" id="::traversal::TreeWalker::previousNode">
        <webidl>    <ref>Node</ref>               previousNode();</webidl>
        <Type name="Node"/>
        <ArgumentList/>
      </Operation>
      <Operation name="nextNode" id="::traversal::TreeWalker::nextNode">
        <webidl>    <ref>Node</ref>               nextNode();</webidl>
        <Type name="Node"/>
        <ArgumentList/>
      </Operation>
    </Interface>
    <Interface name="DocumentTraversal" id="::traversal::DocumentTraversal">
      <webidl>  interface DocumentTraversal {
    <ref>NodeIterator</ref>       createNodeIterator(in <ref>Node</ref> root, 
                                          in unsigned long whatToShow, 
                                          in <ref>NodeFilter</ref> filter, 
                                          in boolean entityReferenceExpansion)
                                        raises(<ref>DOMException</ref>);
    <ref>TreeWalker</ref>         createTreeWalker(in <ref>Node</ref> root, 
                                        in unsigned long whatToShow, 
                                        in <ref>NodeFilter</ref> filter, 
                                        in boolean entityReferenceExpansion)
                                        raises(<ref>DOMException</ref>);
  };</webidl>
      <Operation name="createNodeIterator" id="::traversal::DocumentTraversal::createNodeIterator">
        <webidl>    <ref>NodeIterator</ref>       createNodeIterator(in <ref>Node</ref> root, 
                                          in unsigned long whatToShow, 
                                          in <ref>NodeFilter</ref> filter, 
                                          in boolean entityReferenceExpansion)
                                        raises(<ref>DOMException</ref>);</webidl>
        <Type name="NodeIterator"/>
        <ArgumentList>
          <Argument in="in" name="root">
            <Type name="Node"/>
          </Argument>
          <Argument in="in" name="whatToShow">
            <Type type="unsigned long"/>
          </Argument>
          <Argument in="in" name="filter">
            <Type name="NodeFilter"/>
          </Argument>
          <Argument in="in" name="entityReferenceExpansion">
            <Type type="boolean"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="DOMException"/>
        </Raises>
      </Operation>
      <Operation name="createTreeWalker" id="::traversal::DocumentTraversal::createTreeWalker">
        <webidl>    <ref>TreeWalker</ref>         createTreeWalker(in <ref>Node</ref> root, 
                                        in unsigned long whatToShow, 
                                        in <ref>NodeFilter</ref> filter, 
                                        in boolean entityReferenceExpansion)
                                        raises(<ref>DOMException</ref>);</webidl>
        <Type name="TreeWalker"/>
        <ArgumentList>
          <Argument in="in" name="root">
            <Type name="Node"/>
          </Argument>
          <Argument in="in" name="whatToShow">
            <Type type="unsigned long"/>
          </Argument>
          <Argument in="in" name="filter">
            <Type name="NodeFilter"/>
          </Argument>
          <Argument in="in" name="entityReferenceExpansion">
            <Type type="boolean"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="DOMException"/>
        </Raises>
      </Operation>
    </Interface>
    <Implements name1="Document" name2="DocumentTraversal">
      <webidl>  <ref>Document</ref> implements <ref>DocumentTraversal</ref>;</webidl>
    </Implements>
  </Module>
</Definitions>
<Definitions>
  <Module name="views" id="::views">
    <webidl>module views {

  typedef <ref>dom::Document</ref> Document;

  [PrototypeRoot]
  interface AbstractView {
    readonly attribute <ref>DocumentView</ref>     document;
  };

  interface DocumentView {
    readonly attribute <ref>AbstractView</ref>     defaultView;
  };

  <ref>Document</ref> implements <ref>DocumentView</ref>;
};</webidl>
    <Typedef name="Document" id="::views::Document">
      <webidl>  typedef <ref>dom::Document</ref> Document;</webidl>
      <Type name="domDocument"/>
    </Typedef>
    <Interface name="AbstractView" id="::views::AbstractView">
      <webidl>  [PrototypeRoot]
  interface AbstractView {
    readonly attribute <ref>DocumentView</ref>     document;
  };</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="PrototypeRoot"/>
      </ExtendedAttributeList>
      <Attribute readonly="readonly" name="document" id="::views::AbstractView::document">
        <webidl>    readonly attribute <ref>DocumentView</ref>     document;</webidl>
        <Type name="DocumentView"/>
      </Attribute>
    </Interface>
    <Interface name="DocumentView" id="::views::DocumentView">
      <webidl>  interface DocumentView {
    readonly attribute <ref>AbstractView</ref>     defaultView;
  };</webidl>
      <Attribute readonly="readonly" name="defaultView" id="::views::DocumentView::defaultView">
        <webidl>    readonly attribute <ref>AbstractView</ref>     defaultView;</webidl>
        <Type name="AbstractView"/>
      </Attribute>
    </Interface>
    <Implements name1="Document" name2="DocumentView">
      <webidl>  <ref>Document</ref> implements <ref>DocumentView</ref>;</webidl>
    </Implements>
  </Module>
</Definitions>
<Definitions>
  <Module name="dom" id="::dom">
    <webidl>module dom {

  typedef   unsigned long long DOMTimeStamp;

  typedef   any DOMUserData;

  typedef   object DOMObject;

  exception DOMException {

    const unsigned short INDEX_SIZE_ERR              = 1;
    const unsigned short DOMSTRING_SIZE_ERR          = 2;
    const unsigned short HIERARCHY_REQUEST_ERR       = 3;
    const unsigned short WRONG_DOCUMENT_ERR          = 4;
    const unsigned short INVALID_CHARACTER_ERR       = 5;
    const unsigned short NO_DATA_ALLOWED_ERR         = 6;
    const unsigned short NO_MODIFICATION_ALLOWED_ERR = 7;
    const unsigned short NOT_FOUND_ERR               = 8;
    const unsigned short NOT_SUPPORTED_ERR           = 9;
    const unsigned short INUSE_ATTRIBUTE_ERR         = 10;
    const unsigned short INVALID_STATE_ERR           = 11;
    const unsigned short SYNTAX_ERR                  = 12;
    const unsigned short INVALID_MODIFICATION_ERR    = 13;
    const unsigned short NAMESPACE_ERR               = 14;
    const unsigned short INVALID_ACCESS_ERR          = 15;
    const unsigned short VALIDATION_ERR              = 16;
    const unsigned short TYPE_MISMATCH_ERR           = 17;

    unsigned short code;
  };

  interface DOMStringList {
    getter DOMString? item(in unsigned long index);
    readonly attribute unsigned long length;
    boolean contains(in DOMString? str);
  };

  interface NameList {
    DOMString?          getName(in unsigned long index);
    DOMString?          getNamespaceURI(in unsigned long index);
    readonly attribute unsigned long   length;
    boolean            contains(in DOMString? str);
    boolean            containsNS(in DOMString? namespaceURI, 
                                  in DOMString? name);
  };

  interface DOMImplementationList {
    getter <ref>DOMImplementation</ref> item(in unsigned long index);
    readonly attribute unsigned long length;
  };

  interface DOMImplementationSource {
    <ref>DOMImplementation</ref>  getDOMImplementation(in DOMString features);
    <ref>DOMImplementationList</ref> getDOMImplementationList(in DOMString features);
  };

  interface DOMImplementation {
    boolean            hasFeature(in DOMString feature, 
                                  in DOMString version);
    <ref>DocumentType</ref>       createDocumentType(in DOMString qualifiedName, 
                                          in DOMString? publicId, 
                                          in DOMString? systemId)
                                        raises(<ref>DOMException</ref>);
    <ref>Document</ref>           createDocument(in DOMString? namespaceURI, 
                                      in DOMString? qualifiedName, 
                                      in <ref>DocumentType</ref> doctype)
                                        raises(<ref>DOMException</ref>);
    <ref>DOMObject</ref>          getFeature(in DOMString feature, 
                                  in DOMString version);
  };

  [PrototypeRoot]
  interface Node {

    const unsigned short ELEMENT_NODE                   = 1;
    const unsigned short ATTRIBUTE_NODE                 = 2;
    const unsigned short TEXT_NODE                      = 3;
    const unsigned short CDATA_SECTION_NODE             = 4;
    const unsigned short ENTITY_REFERENCE_NODE          = 5;
    const unsigned short ENTITY_NODE                    = 6;
    const unsigned short PROCESSING_INSTRUCTION_NODE    = 7;
    const unsigned short COMMENT_NODE                   = 8;
    const unsigned short DOCUMENT_NODE                  = 9;
    const unsigned short DOCUMENT_TYPE_NODE             = 10;
    const unsigned short DOCUMENT_FRAGMENT_NODE         = 11;
    const unsigned short NOTATION_NODE                  = 12;

    readonly attribute DOMString       nodeName;
             attribute DOMString?      nodeValue getraises(<ref>DOMException</ref>) setraises(<ref>DOMException</ref>);

    readonly attribute unsigned short  nodeType;
    readonly attribute <ref>Node</ref>            parentNode;
    readonly attribute <ref>NodeList</ref>        childNodes;
    readonly attribute <ref>Node</ref>            firstChild;
    readonly attribute <ref>Node</ref>            lastChild;
    readonly attribute <ref>Node</ref>            previousSibling;
    readonly attribute <ref>Node</ref>            nextSibling;
    readonly attribute <ref>NamedNodeMap</ref>    attributes;
    readonly attribute <ref>Document</ref>        ownerDocument;
    <ref>Node</ref>               insertBefore(in <ref>Node</ref> newChild, 
                                    in <ref>Node</ref> refChild)
                                        raises(<ref>DOMException</ref>);
    <ref>Node</ref>               replaceChild(in <ref>Node</ref> newChild, 
                                    in <ref>Node</ref> oldChild)
                                        raises(<ref>DOMException</ref>);
    <ref>Node</ref>               removeChild(in <ref>Node</ref> oldChild)
                                        raises(<ref>DOMException</ref>);
    <ref>Node</ref>               appendChild(in <ref>Node</ref> newChild)
                                        raises(<ref>DOMException</ref>);
    boolean            hasChildNodes();
    <ref>Node</ref>               cloneNode(in boolean deep);
    void               normalize();
    boolean            isSupported(in DOMString feature, 
                                   in DOMString version);
    readonly attribute DOMString?      namespaceURI;
             attribute DOMString?      prefix setraises(<ref>DOMException</ref>);

    readonly attribute DOMString?      localName;
    boolean            hasAttributes();
    readonly attribute DOMString?      baseURI;

    const unsigned short      DOCUMENT_POSITION_DISCONNECTED = 0x01;
    const unsigned short      DOCUMENT_POSITION_PRECEDING    = 0x02;
    const unsigned short      DOCUMENT_POSITION_FOLLOWING    = 0x04;
    const unsigned short      DOCUMENT_POSITION_CONTAINS     = 0x08;
    const unsigned short      DOCUMENT_POSITION_CONTAINED_BY = 0x10;
    const unsigned short      DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC = 0x20;

    unsigned short     compareDocumentPosition(in <ref>Node</ref> other)
                                        raises(<ref>DOMException</ref>);
             attribute DOMString?      textContent getraises(<ref>DOMException</ref>) setraises(<ref>DOMException</ref>);

    boolean            isSameNode(in <ref>Node</ref> other);
    DOMString?         lookupPrefix(in DOMString? namespaceURI);
    boolean            isDefaultNamespace(in DOMString? namespaceURI);
    DOMString?         lookupNamespaceURI(in DOMString? prefix);
    boolean            isEqualNode(in <ref>Node</ref> arg);
    <ref>DOMObject</ref>          getFeature(in DOMString feature, 
                                  in DOMString version);
    <ref>DOMUserData</ref>        setUserData(in DOMString key, 
                                   in <ref>DOMUserData</ref> data, 
                                   in <ref>UserDataHandler</ref> handler);
    <ref>DOMUserData</ref>        getUserData(in DOMString key);
  };

  interface NodeList {
    getter <ref>Node</ref> item(in unsigned long index);
    readonly attribute unsigned long length;
  };

  interface NamedNodeMap {
    <ref>Node</ref>               getNamedItem(in DOMString name);
    <ref>Node</ref>               setNamedItem(in <ref>Node</ref> arg)
                                        raises(<ref>DOMException</ref>);
    <ref>Node</ref>               removeNamedItem(in DOMString name)
                                        raises(<ref>DOMException</ref>);
    getter <ref>Node</ref>        item(in unsigned long index);
    readonly attribute unsigned long   length;
    <ref>Node</ref>               getNamedItemNS(in DOMString? namespaceURI, 
                                      in DOMString? localName)
                                        raises(<ref>DOMException</ref>);
    <ref>Node</ref>               setNamedItemNS(in <ref>Node</ref> arg)
                                        raises(<ref>DOMException</ref>);
    <ref>Node</ref>               removeNamedItemNS(in DOMString? namespaceURI, 
                                         in DOMString? localName)
                                        raises(<ref>DOMException</ref>);
  };

  interface CharacterData : <ref>Node</ref> {
             attribute DOMString       data getraises(<ref>DOMException</ref>) setraises(<ref>DOMException</ref>);

    readonly attribute unsigned long   length;
    DOMString          substringData(in unsigned long offset, 
                                     in unsigned long count)
                                        raises(<ref>DOMException</ref>);
    void               appendData(in DOMString arg)
                                        raises(<ref>DOMException</ref>);
    void               insertData(in unsigned long offset, 
                                  in DOMString arg)
                                        raises(<ref>DOMException</ref>);
    void               deleteData(in unsigned long offset, 
                                  in unsigned long count)
                                        raises(<ref>DOMException</ref>);
    void               replaceData(in unsigned long offset, 
                                   in unsigned long count, 
                                   in DOMString arg)
                                        raises(<ref>DOMException</ref>);
  };

  interface Attr : <ref>Node</ref> {
    readonly attribute DOMString       name;
    readonly attribute boolean         specified;
             attribute DOMString       value setraises(<ref>DOMException</ref>);

    readonly attribute <ref>Element</ref>         ownerElement;
    readonly attribute <ref>TypeInfo</ref>        schemaTypeInfo;
    readonly attribute boolean         isId;
  };

  interface Element : <ref>Node</ref> {
    readonly attribute DOMString       tagName;
    DOMString          getAttribute(in DOMString name);
    void               setAttribute(in DOMString name, 
                                    in DOMString value)
                                        raises(<ref>DOMException</ref>);
    void               removeAttribute(in DOMString name)
                                        raises(<ref>DOMException</ref>);
    <ref>Attr</ref>               getAttributeNode(in DOMString name);
    <ref>Attr</ref>               setAttributeNode(in <ref>Attr</ref> newAttr)
                                        raises(<ref>DOMException</ref>);
    <ref>Attr</ref>               removeAttributeNode(in <ref>Attr</ref> oldAttr)
                                        raises(<ref>DOMException</ref>);
    <ref>NodeList</ref>           getElementsByTagName(in DOMString name);
    DOMString          getAttributeNS(in DOMString? namespaceURI, 
                                      in DOMString localName)
                                        raises(<ref>DOMException</ref>);
    void               setAttributeNS(in DOMString? namespaceURI, 
                                      in DOMString qualifiedName, 
                                      in DOMString value)
                                        raises(<ref>DOMException</ref>);
    void               removeAttributeNS(in DOMString? namespaceURI, 
                                         in DOMString localName)
                                        raises(<ref>DOMException</ref>);
    <ref>Attr</ref>               getAttributeNodeNS(in DOMString? namespaceURI, 
                                          in DOMString localName)
                                        raises(<ref>DOMException</ref>);
    <ref>Attr</ref>               setAttributeNodeNS(in <ref>Attr</ref> newAttr)
                                        raises(<ref>DOMException</ref>);
    <ref>NodeList</ref>           getElementsByTagNameNS(in DOMString? namespaceURI, 
                                              in DOMString localName)
                                        raises(<ref>DOMException</ref>);
    boolean            hasAttribute(in DOMString name);
    boolean            hasAttributeNS(in DOMString? namespaceURI, 
                                      in DOMString localName)
                                        raises(<ref>DOMException</ref>);
    readonly attribute <ref>TypeInfo</ref>        schemaTypeInfo;
    void               setIdAttribute(in DOMString name, 
                                      in boolean isId)
                                        raises(<ref>DOMException</ref>);
    void               setIdAttributeNS(in DOMString? namespaceURI, 
                                        in DOMString localName, 
                                        in boolean isId)
                                        raises(<ref>DOMException</ref>);
    void               setIdAttributeNode(in <ref>Attr</ref> idAttr, 
                                          in boolean isId)
                                        raises(<ref>DOMException</ref>);
  };

  interface Text : <ref>CharacterData</ref> {
    <ref>Text</ref>               splitText(in unsigned long offset)
                                        raises(<ref>DOMException</ref>);
    readonly attribute boolean         isElementContentWhitespace;
    readonly attribute DOMString       wholeText;
    <ref>Text</ref>               replaceWholeText(in DOMString content)
                                        raises(<ref>DOMException</ref>);
  };

  interface Comment : <ref>CharacterData</ref> {
  };

  interface TypeInfo {
    readonly attribute DOMString?      typeName;
    readonly attribute DOMString?      typeNamespace;

    const unsigned long       DERIVATION_RESTRICTION         = 0x00000001;
    const unsigned long       DERIVATION_EXTENSION           = 0x00000002;
    const unsigned long       DERIVATION_UNION               = 0x00000004;
    const unsigned long       DERIVATION_LIST                = 0x00000008;

    boolean            isDerivedFrom(in DOMString? typeNamespaceArg, 
                                     in DOMString typeNameArg, 
                                     in unsigned long derivationMethod);
  };

  [Callback]
  interface UserDataHandler {

    const unsigned short      NODE_CLONED                    = 1;
    const unsigned short      NODE_IMPORTED                  = 2;
    const unsigned short      NODE_DELETED                   = 3;
    const unsigned short      NODE_RENAMED                   = 4;
    const unsigned short      NODE_ADOPTED                   = 5;

    void               handle(in unsigned short operation, 
                              in DOMString key, 
                              in <ref>DOMUserData</ref> data, 
                              in <ref>Node</ref> src, 
                              in <ref>Node</ref> dst);
  };

  interface DOMError {

    const unsigned short      SEVERITY_WARNING               = 1;
    const unsigned short      SEVERITY_ERROR                 = 2;
    const unsigned short      SEVERITY_FATAL_ERROR           = 3;

    readonly attribute unsigned short  severity;
    readonly attribute DOMString       message;
    readonly attribute DOMString       type;
    readonly attribute <ref>DOMObject</ref>       relatedException;
    readonly attribute <ref>DOMObject</ref>       relatedData;
    readonly attribute <ref>DOMLocator</ref>      location;
  };

  interface DOMErrorHandler {
    boolean            handleError(in <ref>DOMError</ref> error);
  };

  interface DOMLocator {
    readonly attribute long            lineNumber;
    readonly attribute long            columnNumber;
    readonly attribute long            byteOffset;
    readonly attribute long            utf16Offset;
    readonly attribute <ref>Node</ref>            relatedNode;
    readonly attribute DOMString?      uri;
  };

  interface DOMConfiguration {
    void               setParameter(in DOMString name, 
                                    in <ref>DOMUserData</ref> value)
                                        raises(<ref>DOMException</ref>);
    <ref>DOMUserData</ref>        getParameter(in DOMString name)
                                        raises(<ref>DOMException</ref>);
    boolean            canSetParameter(in DOMString name, 
                                       in <ref>DOMUserData</ref> value);
    readonly attribute <ref>DOMStringList</ref>   parameterNames;
  };

  interface CDATASection : <ref>Text</ref> {
  };

  interface DocumentType : <ref>Node</ref> {
    readonly attribute DOMString       name;
    readonly attribute <ref>NamedNodeMap</ref>    entities;
    readonly attribute <ref>NamedNodeMap</ref>    notations;
    readonly attribute DOMString?      publicId;
    readonly attribute DOMString?      systemId;
    readonly attribute DOMString?      internalSubset;
  };

  interface Notation : <ref>Node</ref> {
    readonly attribute DOMString?      publicId;
    readonly attribute DOMString?      systemId;
  };

  interface Entity : <ref>Node</ref> {
    readonly attribute DOMString?      publicId;
    readonly attribute DOMString?      systemId;
    readonly attribute DOMString?      notationName;
    readonly attribute DOMString?      inputEncoding;
    readonly attribute DOMString?      xmlEncoding;
    readonly attribute DOMString?      xmlVersion;
  };

  interface EntityReference : <ref>Node</ref> {
  };

  interface ProcessingInstruction : <ref>Node</ref> {
    readonly attribute DOMString       target;
             attribute DOMString       data setraises(<ref>DOMException</ref>);

  };

  interface DocumentFragment : <ref>Node</ref> {
  };

  interface Document : <ref>Node</ref> {
    readonly attribute <ref>DocumentType</ref>    doctype;
    readonly attribute <ref>DOMImplementation</ref> implementation;
    readonly attribute <ref>Element</ref>         documentElement;
    <ref>Element</ref>            createElement(in DOMString tagName)
                                        raises(<ref>DOMException</ref>);
    <ref>DocumentFragment</ref>   createDocumentFragment();
    <ref>Text</ref>               createTextNode(in DOMString data);
    <ref>Comment</ref>            createComment(in DOMString data);
    <ref>CDATASection</ref>       createCDATASection(in DOMString data)
                                        raises(<ref>DOMException</ref>);
    <ref>ProcessingInstruction</ref> createProcessingInstruction(in DOMString target, 
                                                      in DOMString data)
                                        raises(<ref>DOMException</ref>);
    <ref>Attr</ref>               createAttribute(in DOMString name)
                                        raises(<ref>DOMException</ref>);
    <ref>EntityReference</ref>    createEntityReference(in DOMString name)
                                        raises(<ref>DOMException</ref>);
    <ref>NodeList</ref>           getElementsByTagName(in DOMString tagname);
    <ref>Node</ref>               importNode(in <ref>Node</ref> importedNode, 
                                  in boolean deep)
                                        raises(<ref>DOMException</ref>);
    <ref>Element</ref>            createElementNS(in DOMString? namespaceURI, 
                                       in DOMString qualifiedName)
                                        raises(<ref>DOMException</ref>);
    <ref>Attr</ref>               createAttributeNS(in DOMString? namespaceURI, 
                                         in DOMString qualifiedName)
                                        raises(<ref>DOMException</ref>);
    <ref>NodeList</ref>           getElementsByTagNameNS(in DOMString? namespaceURI, 
                                              in DOMString localName);
    <ref>Element</ref>            getElementById(in DOMString elementId);
    readonly attribute DOMString?      inputEncoding;
    readonly attribute DOMString?      xmlEncoding;
             attribute boolean         xmlStandalone setraises(<ref>DOMException</ref>);

             attribute DOMString?      xmlVersion setraises(<ref>DOMException</ref>);

             attribute boolean         strictErrorChecking;
             attribute DOMString?      documentURI;
    <ref>Node</ref>               adoptNode(in <ref>Node</ref> source)
                                        raises(<ref>DOMException</ref>);
    readonly attribute <ref>DOMConfiguration</ref> domConfig;
    void               normalizeDocument();
    <ref>Node</ref>               renameNode(in <ref>Node</ref> n, 
                                  in DOMString? namespaceURI, 
                                  in DOMString qualifiedName)
                                        raises(<ref>DOMException</ref>);
  };
};</webidl>
    <Typedef name="DOMTimeStamp" id="::dom::DOMTimeStamp">
      <webidl>  typedef   unsigned long long DOMTimeStamp;</webidl>
      <Type type="unsigned long long"/>
    </Typedef>
    <Typedef name="DOMUserData" id="::dom::DOMUserData">
      <webidl>  typedef   any DOMUserData;</webidl>
      <Type type="any"/>
    </Typedef>
    <Typedef name="DOMObject" id="::dom::DOMObject">
      <webidl>  typedef   object DOMObject;</webidl>
      <Type type="object"/>
    </Typedef>
    <Exception name="DOMException" id="::dom::DOMException">
      <webidl>  exception DOMException {

    const unsigned short INDEX_SIZE_ERR              = 1;
    const unsigned short DOMSTRING_SIZE_ERR          = 2;
    const unsigned short HIERARCHY_REQUEST_ERR       = 3;
    const unsigned short WRONG_DOCUMENT_ERR          = 4;
    const unsigned short INVALID_CHARACTER_ERR       = 5;
    const unsigned short NO_DATA_ALLOWED_ERR         = 6;
    const unsigned short NO_MODIFICATION_ALLOWED_ERR = 7;
    const unsigned short NOT_FOUND_ERR               = 8;
    const unsigned short NOT_SUPPORTED_ERR           = 9;
    const unsigned short INUSE_ATTRIBUTE_ERR         = 10;
    const unsigned short INVALID_STATE_ERR           = 11;
    const unsigned short SYNTAX_ERR                  = 12;
    const unsigned short INVALID_MODIFICATION_ERR    = 13;
    const unsigned short NAMESPACE_ERR               = 14;
    const unsigned short INVALID_ACCESS_ERR          = 15;
    const unsigned short VALIDATION_ERR              = 16;
    const unsigned short TYPE_MISMATCH_ERR           = 17;

    unsigned short code;
  };</webidl>
      <Const name="INDEX_SIZE_ERR" value="1" id="::dom::DOMException::INDEX_SIZE_ERR">
        <Type type="unsigned short"/>
      </Const>
      <Const name="DOMSTRING_SIZE_ERR" value="2" id="::dom::DOMException::DOMSTRING_SIZE_ERR">
        <Type type="unsigned short"/>
      </Const>
      <Const name="HIERARCHY_REQUEST_ERR" value="3" id="::dom::DOMException::HIERARCHY_REQUEST_ERR">
        <Type type="unsigned short"/>
      </Const>
      <Const name="WRONG_DOCUMENT_ERR" value="4" id="::dom::DOMException::WRONG_DOCUMENT_ERR">
        <Type type="unsigned short"/>
      </Const>
      <Const name="INVALID_CHARACTER_ERR" value="5" id="::dom::DOMException::INVALID_CHARACTER_ERR">
        <Type type="unsigned short"/>
      </Const>
      <Const name="NO_DATA_ALLOWED_ERR" value="6" id="::dom::DOMException::NO_DATA_ALLOWED_ERR">
        <Type type="unsigned short"/>
      </Const>
      <Const name="NO_MODIFICATION_ALLOWED_ERR" value="7" id="::dom::DOMException::NO_MODIFICATION_ALLOWED_ERR">
        <Type type="unsigned short"/>
      </Const>
      <Const name="NOT_FOUND_ERR" value="8" id="::dom::DOMException::NOT_FOUND_ERR">
        <Type type="unsigned short"/>
      </Const>
      <Const name="NOT_SUPPORTED_ERR" value="9" id="::dom::DOMException::NOT_SUPPORTED_ERR">
        <Type type="unsigned short"/>
      </Const>
      <Const name="INUSE_ATTRIBUTE_ERR" value="10" id="::dom::DOMException::INUSE_ATTRIBUTE_ERR">
        <Type type="unsigned short"/>
      </Const>
      <Const name="INVALID_STATE_ERR" value="11" id="::dom::DOMException::INVALID_STATE_ERR">
        <Type type="unsigned short"/>
      </Const>
      <Const name="SYNTAX_ERR" value="12" id="::dom::DOMException::SYNTAX_ERR">
        <Type type="unsigned short"/>
      </Const>
      <Const name="INVALID_MODIFICATION_ERR" value="13" id="::dom::DOMException::INVALID_MODIFICATION_ERR">
        <Type type="unsigned short"/>
      </Const>
      <Const name="NAMESPACE_ERR" value="14" id="::dom::DOMException::NAMESPACE_ERR">
        <Type type="unsigned short"/>
      </Const>
      <Const name="INVALID_ACCESS_ERR" value="15" id="::dom::DOMException::INVALID_ACCESS_ERR">
        <Type type="unsigned short"/>
      </Const>
      <Const name="VALIDATION_ERR" value="16" id="::dom::DOMException::VALIDATION_ERR">
        <Type type="unsigned short"/>
      </Const>
      <Const name="TYPE_MISMATCH_ERR" value="17" id="::dom::DOMException::TYPE_MISMATCH_ERR">
        <Type type="unsigned short"/>
      </Const>
      <ExceptionField name="code" id="::dom::DOMException::code">
        <Type type="unsigned short"/>
      </ExceptionField>
    </Exception>
    <Interface name="DOMStringList" id="::dom::DOMStringList">
      <webidl>  interface DOMStringList {
    getter DOMString? item(in unsigned long index);
    readonly attribute unsigned long length;
    boolean contains(in DOMString? str);
  };</webidl>
      <Operation getter="getter" name="item" id="::dom::DOMStringList::item">
        <webidl>    getter DOMString? item(in unsigned long index);</webidl>
        <Type type="DOMString" nullable="nullable"/>
        <ArgumentList>
          <Argument in="in" name="index">
            <Type type="unsigned long"/>
          </Argument>
        </ArgumentList>
      </Operation>
      <Attribute readonly="readonly" name="length" id="::dom::DOMStringList::length">
        <webidl>    readonly attribute unsigned long length;</webidl>
        <Type type="unsigned long"/>
      </Attribute>
      <Operation name="contains" id="::dom::DOMStringList::contains">
        <webidl>    boolean contains(in DOMString? str);</webidl>
        <Type type="boolean"/>
        <ArgumentList>
          <Argument in="in" name="str">
            <Type type="DOMString" nullable="nullable"/>
          </Argument>
        </ArgumentList>
      </Operation>
    </Interface>
    <Interface name="NameList" id="::dom::NameList">
      <webidl>  interface NameList {
    DOMString?          getName(in unsigned long index);
    DOMString?          getNamespaceURI(in unsigned long index);
    readonly attribute unsigned long   length;
    boolean            contains(in DOMString? str);
    boolean            containsNS(in DOMString? namespaceURI, 
                                  in DOMString? name);
  };</webidl>
      <Operation name="getName" id="::dom::NameList::getName">
        <webidl>    DOMString?          getName(in unsigned long index);</webidl>
        <Type type="DOMString" nullable="nullable"/>
        <ArgumentList>
          <Argument in="in" name="index">
            <Type type="unsigned long"/>
          </Argument>
        </ArgumentList>
      </Operation>
      <Operation name="getNamespaceURI" id="::dom::NameList::getNamespaceURI">
        <webidl>    DOMString?          getNamespaceURI(in unsigned long index);</webidl>
        <Type type="DOMString" nullable="nullable"/>
        <ArgumentList>
          <Argument in="in" name="index">
            <Type type="unsigned long"/>
          </Argument>
        </ArgumentList>
      </Operation>
      <Attribute readonly="readonly" name="length" id="::dom::NameList::length">
        <webidl>    readonly attribute unsigned long   length;</webidl>
        <Type type="unsigned long"/>
      </Attribute>
      <Operation name="contains" id="::dom::NameList::contains">
        <webidl>    boolean            contains(in DOMString? str);</webidl>
        <Type type="boolean"/>
        <ArgumentList>
          <Argument in="in" name="str">
            <Type type="DOMString" nullable="nullable"/>
          </Argument>
        </ArgumentList>
      </Operation>
      <Operation name="containsNS" id="::dom::NameList::containsNS">
        <webidl>    boolean            containsNS(in DOMString? namespaceURI, 
                                  in DOMString? name);</webidl>
        <Type type="boolean"/>
        <ArgumentList>
          <Argument in="in" name="namespaceURI">
            <Type type="DOMString" nullable="nullable"/>
          </Argument>
          <Argument in="in" name="name">
            <Type type="DOMString" nullable="nullable"/>
          </Argument>
        </ArgumentList>
      </Operation>
    </Interface>
    <Interface name="DOMImplementationList" id="::dom::DOMImplementationList">
      <webidl>  interface DOMImplementationList {
    getter <ref>DOMImplementation</ref> item(in unsigned long index);
    readonly attribute unsigned long length;
  };</webidl>
      <Operation getter="getter" name="item" id="::dom::DOMImplementationList::item">
        <webidl>    getter <ref>DOMImplementation</ref> item(in unsigned long index);</webidl>
        <Type name="DOMImplementation"/>
        <ArgumentList>
          <Argument in="in" name="index">
            <Type type="unsigned long"/>
          </Argument>
        </ArgumentList>
      </Operation>
      <Attribute readonly="readonly" name="length" id="::dom::DOMImplementationList::length">
        <webidl>    readonly attribute unsigned long length;</webidl>
        <Type type="unsigned long"/>
      </Attribute>
    </Interface>
    <Interface name="DOMImplementationSource" id="::dom::DOMImplementationSource">
      <webidl>  interface DOMImplementationSource {
    <ref>DOMImplementation</ref>  getDOMImplementation(in DOMString features);
    <ref>DOMImplementationList</ref> getDOMImplementationList(in DOMString features);
  };</webidl>
      <Operation name="getDOMImplementation" id="::dom::DOMImplementationSource::getDOMImplementation">
        <webidl>    <ref>DOMImplementation</ref>  getDOMImplementation(in DOMString features);</webidl>
        <Type name="DOMImplementation"/>
        <ArgumentList>
          <Argument in="in" name="features">
            <Type type="DOMString"/>
          </Argument>
        </ArgumentList>
      </Operation>
      <Operation name="getDOMImplementationList" id="::dom::DOMImplementationSource::getDOMImplementationList">
        <webidl>    <ref>DOMImplementationList</ref> getDOMImplementationList(in DOMString features);</webidl>
        <Type name="DOMImplementationList"/>
        <ArgumentList>
          <Argument in="in" name="features">
            <Type type="DOMString"/>
          </Argument>
        </ArgumentList>
      </Operation>
    </Interface>
    <Interface name="DOMImplementation" id="::dom::DOMImplementation">
      <webidl>  interface DOMImplementation {
    boolean            hasFeature(in DOMString feature, 
                                  in DOMString version);
    <ref>DocumentType</ref>       createDocumentType(in DOMString qualifiedName, 
                                          in DOMString? publicId, 
                                          in DOMString? systemId)
                                        raises(<ref>DOMException</ref>);
    <ref>Document</ref>           createDocument(in DOMString? namespaceURI, 
                                      in DOMString? qualifiedName, 
                                      in <ref>DocumentType</ref> doctype)
                                        raises(<ref>DOMException</ref>);
    <ref>DOMObject</ref>          getFeature(in DOMString feature, 
                                  in DOMString version);
  };</webidl>
      <Operation name="hasFeature" id="::dom::DOMImplementation::hasFeature">
        <webidl>    boolean            hasFeature(in DOMString feature, 
                                  in DOMString version);</webidl>
        <Type type="boolean"/>
        <ArgumentList>
          <Argument in="in" name="feature">
            <Type type="DOMString"/>
          </Argument>
          <Argument in="in" name="version">
            <Type type="DOMString"/>
          </Argument>
        </ArgumentList>
      </Operation>
      <Operation name="createDocumentType" id="::dom::DOMImplementation::createDocumentType">
        <webidl>    <ref>DocumentType</ref>       createDocumentType(in DOMString qualifiedName, 
                                          in DOMString? publicId, 
                                          in DOMString? systemId)
                                        raises(<ref>DOMException</ref>);</webidl>
        <Type name="DocumentType"/>
        <ArgumentList>
          <Argument in="in" name="qualifiedName">
            <Type type="DOMString"/>
          </Argument>
          <Argument in="in" name="publicId">
            <Type type="DOMString" nullable="nullable"/>
          </Argument>
          <Argument in="in" name="systemId">
            <Type type="DOMString" nullable="nullable"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="DOMException"/>
        </Raises>
      </Operation>
      <Operation name="createDocument" id="::dom::DOMImplementation::createDocument">
        <webidl>    <ref>Document</ref>           createDocument(in DOMString? namespaceURI, 
                                      in DOMString? qualifiedName, 
                                      in <ref>DocumentType</ref> doctype)
                                        raises(<ref>DOMException</ref>);</webidl>
        <Type name="Document"/>
        <ArgumentList>
          <Argument in="in" name="namespaceURI">
            <Type type="DOMString" nullable="nullable"/>
          </Argument>
          <Argument in="in" name="qualifiedName">
            <Type type="DOMString" nullable="nullable"/>
          </Argument>
          <Argument in="in" name="doctype">
            <Type name="DocumentType"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="DOMException"/>
        </Raises>
      </Operation>
      <Operation name="getFeature" id="::dom::DOMImplementation::getFeature">
        <webidl>    <ref>DOMObject</ref>          getFeature(in DOMString feature, 
                                  in DOMString version);</webidl>
        <Type name="DOMObject"/>
        <ArgumentList>
          <Argument in="in" name="feature">
            <Type type="DOMString"/>
          </Argument>
          <Argument in="in" name="version">
            <Type type="DOMString"/>
          </Argument>
        </ArgumentList>
      </Operation>
    </Interface>
    <Interface name="Node" id="::dom::Node">
      <webidl>  [PrototypeRoot]
  interface Node {

    const unsigned short ELEMENT_NODE                   = 1;
    const unsigned short ATTRIBUTE_NODE                 = 2;
    const unsigned short TEXT_NODE                      = 3;
    const unsigned short CDATA_SECTION_NODE             = 4;
    const unsigned short ENTITY_REFERENCE_NODE          = 5;
    const unsigned short ENTITY_NODE                    = 6;
    const unsigned short PROCESSING_INSTRUCTION_NODE    = 7;
    const unsigned short COMMENT_NODE                   = 8;
    const unsigned short DOCUMENT_NODE                  = 9;
    const unsigned short DOCUMENT_TYPE_NODE             = 10;
    const unsigned short DOCUMENT_FRAGMENT_NODE         = 11;
    const unsigned short NOTATION_NODE                  = 12;

    readonly attribute DOMString       nodeName;
             attribute DOMString?      nodeValue getraises(<ref>DOMException</ref>) setraises(<ref>DOMException</ref>);

    readonly attribute unsigned short  nodeType;
    readonly attribute <ref>Node</ref>            parentNode;
    readonly attribute <ref>NodeList</ref>        childNodes;
    readonly attribute <ref>Node</ref>            firstChild;
    readonly attribute <ref>Node</ref>            lastChild;
    readonly attribute <ref>Node</ref>            previousSibling;
    readonly attribute <ref>Node</ref>            nextSibling;
    readonly attribute <ref>NamedNodeMap</ref>    attributes;
    readonly attribute <ref>Document</ref>        ownerDocument;
    <ref>Node</ref>               insertBefore(in <ref>Node</ref> newChild, 
                                    in <ref>Node</ref> refChild)
                                        raises(<ref>DOMException</ref>);
    <ref>Node</ref>               replaceChild(in <ref>Node</ref> newChild, 
                                    in <ref>Node</ref> oldChild)
                                        raises(<ref>DOMException</ref>);
    <ref>Node</ref>               removeChild(in <ref>Node</ref> oldChild)
                                        raises(<ref>DOMException</ref>);
    <ref>Node</ref>               appendChild(in <ref>Node</ref> newChild)
                                        raises(<ref>DOMException</ref>);
    boolean            hasChildNodes();
    <ref>Node</ref>               cloneNode(in boolean deep);
    void               normalize();
    boolean            isSupported(in DOMString feature, 
                                   in DOMString version);
    readonly attribute DOMString?      namespaceURI;
             attribute DOMString?      prefix setraises(<ref>DOMException</ref>);

    readonly attribute DOMString?      localName;
    boolean            hasAttributes();
    readonly attribute DOMString?      baseURI;

    const unsigned short      DOCUMENT_POSITION_DISCONNECTED = 0x01;
    const unsigned short      DOCUMENT_POSITION_PRECEDING    = 0x02;
    const unsigned short      DOCUMENT_POSITION_FOLLOWING    = 0x04;
    const unsigned short      DOCUMENT_POSITION_CONTAINS     = 0x08;
    const unsigned short      DOCUMENT_POSITION_CONTAINED_BY = 0x10;
    const unsigned short      DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC = 0x20;

    unsigned short     compareDocumentPosition(in <ref>Node</ref> other)
                                        raises(<ref>DOMException</ref>);
             attribute DOMString?      textContent getraises(<ref>DOMException</ref>) setraises(<ref>DOMException</ref>);

    boolean            isSameNode(in <ref>Node</ref> other);
    DOMString?         lookupPrefix(in DOMString? namespaceURI);
    boolean            isDefaultNamespace(in DOMString? namespaceURI);
    DOMString?         lookupNamespaceURI(in DOMString? prefix);
    boolean            isEqualNode(in <ref>Node</ref> arg);
    <ref>DOMObject</ref>          getFeature(in DOMString feature, 
                                  in DOMString version);
    <ref>DOMUserData</ref>        setUserData(in DOMString key, 
                                   in <ref>DOMUserData</ref> data, 
                                   in <ref>UserDataHandler</ref> handler);
    <ref>DOMUserData</ref>        getUserData(in DOMString key);
  };</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="PrototypeRoot"/>
      </ExtendedAttributeList>
      <Const name="ELEMENT_NODE" value="1" id="::dom::Node::ELEMENT_NODE">
        <webidl>    const unsigned short ELEMENT_NODE                   = 1;</webidl>
        <Type type="unsigned short"/>
      </Const>
      <Const name="ATTRIBUTE_NODE" value="2" id="::dom::Node::ATTRIBUTE_NODE">
        <webidl>    const unsigned short ATTRIBUTE_NODE                 = 2;</webidl>
        <Type type="unsigned short"/>
      </Const>
      <Const name="TEXT_NODE" value="3" id="::dom::Node::TEXT_NODE">
        <webidl>    const unsigned short TEXT_NODE                      = 3;</webidl>
        <Type type="unsigned short"/>
      </Const>
      <Const name="CDATA_SECTION_NODE" value="4" id="::dom::Node::CDATA_SECTION_NODE">
        <webidl>    const unsigned short CDATA_SECTION_NODE             = 4;</webidl>
        <Type type="unsigned short"/>
      </Const>
      <Const name="ENTITY_REFERENCE_NODE" value="5" id="::dom::Node::ENTITY_REFERENCE_NODE">
        <webidl>    const unsigned short ENTITY_REFERENCE_NODE          = 5;</webidl>
        <Type type="unsigned short"/>
      </Const>
      <Const name="ENTITY_NODE" value="6" id="::dom::Node::ENTITY_NODE">
        <webidl>    const unsigned short ENTITY_NODE                    = 6;</webidl>
        <Type type="unsigned short"/>
      </Const>
      <Const name="PROCESSING_INSTRUCTION_NODE" value="7" id="::dom::Node::PROCESSING_INSTRUCTION_NODE">
        <webidl>    const unsigned short PROCESSING_INSTRUCTION_NODE    = 7;</webidl>
        <Type type="unsigned short"/>
      </Const>
      <Const name="COMMENT_NODE" value="8" id="::dom::Node::COMMENT_NODE">
        <webidl>    const unsigned short COMMENT_NODE                   = 8;</webidl>
        <Type type="unsigned short"/>
      </Const>
      <Const name="DOCUMENT_NODE" value="9" id="::dom::Node::DOCUMENT_NODE">
        <webidl>    const unsigned short DOCUMENT_NODE                  = 9;</webidl>
        <Type type="unsigned short"/>
      </Const>
      <Const name="DOCUMENT_TYPE_NODE" value="10" id="::dom::Node::DOCUMENT_TYPE_NODE">
        <webidl>    const unsigned short DOCUMENT_TYPE_NODE             = 10;</webidl>
        <Type type="unsigned short"/>
      </Const>
      <Const name="DOCUMENT_FRAGMENT_NODE" value="11" id="::dom::Node::DOCUMENT_FRAGMENT_NODE">
        <webidl>    const unsigned short DOCUMENT_FRAGMENT_NODE         = 11;</webidl>
        <Type type="unsigned short"/>
      </Const>
      <Const name="NOTATION_NODE" value="12" id="::dom::Node::NOTATION_NODE">
        <webidl>    const unsigned short NOTATION_NODE                  = 12;</webidl>
        <Type type="unsigned short"/>
      </Const>
      <Attribute readonly="readonly" name="nodeName" id="::dom::Node::nodeName">
        <webidl>    readonly attribute DOMString       nodeName;</webidl>
        <Type type="DOMString"/>
      </Attribute>
      <Attribute name="nodeValue" id="::dom::Node::nodeValue">
        <webidl>             attribute DOMString?      nodeValue getraises(<ref>DOMException</ref>) setraises(<ref>DOMException</ref>);</webidl>
        <Type type="DOMString" nullable="nullable"/>
        <GetRaises>
          <RaiseException name="DOMException"/>
        </GetRaises>
        <SetRaises>
          <RaiseException name="DOMException"/>
        </SetRaises>
      </Attribute>
      <Attribute readonly="readonly" name="nodeType" id="::dom::Node::nodeType">
        <webidl>    readonly attribute unsigned short  nodeType;</webidl>
        <Type type="unsigned short"/>
      </Attribute>
      <Attribute readonly="readonly" name="parentNode" id="::dom::Node::parentNode">
        <webidl>    readonly attribute <ref>Node</ref>            parentNode;</webidl>
        <Type name="Node"/>
      </Attribute>
      <Attribute readonly="readonly" name="childNodes" id="::dom::Node::childNodes">
        <webidl>    readonly attribute <ref>NodeList</ref>        childNodes;</webidl>
        <Type name="NodeList"/>
      </Attribute>
      <Attribute readonly="readonly" name="firstChild" id="::dom::Node::firstChild">
        <webidl>    readonly attribute <ref>Node</ref>            firstChild;</webidl>
        <Type name="Node"/>
      </Attribute>
      <Attribute readonly="readonly" name="lastChild" id="::dom::Node::lastChild">
        <webidl>    readonly attribute <ref>Node</ref>            lastChild;</webidl>
        <Type name="Node"/>
      </Attribute>
      <Attribute readonly="readonly" name="previousSibling" id="::dom::Node::previousSibling">
        <webidl>    readonly attribute <ref>Node</ref>            previousSibling;</webidl>
        <Type name="Node"/>
      </Attribute>
      <Attribute readonly="readonly" name="nextSibling" id="::dom::Node::nextSibling">
        <webidl>    readonly attribute <ref>Node</ref>            nextSibling;</webidl>
        <Type name="Node"/>
      </Attribute>
      <Attribute readonly="readonly" name="attributes" id="::dom::Node::attributes">
        <webidl>    readonly attribute <ref>NamedNodeMap</ref>    attributes;</webidl>
        <Type name="NamedNodeMap"/>
      </Attribute>
      <Attribute readonly="readonly" name="ownerDocument" id="::dom::Node::ownerDocument">
        <webidl>    readonly attribute <ref>Document</ref>        ownerDocument;</webidl>
        <Type name="Document"/>
      </Attribute>
      <Operation name="insertBefore" id="::dom::Node::insertBefore">
        <webidl>    <ref>Node</ref>               insertBefore(in <ref>Node</ref> newChild, 
                                    in <ref>Node</ref> refChild)
                                        raises(<ref>DOMException</ref>);</webidl>
        <Type name="Node"/>
        <ArgumentList>
          <Argument in="in" name="newChild">
            <Type name="Node"/>
          </Argument>
          <Argument in="in" name="refChild">
            <Type name="Node"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="DOMException"/>
        </Raises>
      </Operation>
      <Operation name="replaceChild" id="::dom::Node::replaceChild">
        <webidl>    <ref>Node</ref>               replaceChild(in <ref>Node</ref> newChild, 
                                    in <ref>Node</ref> oldChild)
                                        raises(<ref>DOMException</ref>);</webidl>
        <Type name="Node"/>
        <ArgumentList>
          <Argument in="in" name="newChild">
            <Type name="Node"/>
          </Argument>
          <Argument in="in" name="oldChild">
            <Type name="Node"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="DOMException"/>
        </Raises>
      </Operation>
      <Operation name="removeChild" id="::dom::Node::removeChild">
        <webidl>    <ref>Node</ref>               removeChild(in <ref>Node</ref> oldChild)
                                        raises(<ref>DOMException</ref>);</webidl>
        <Type name="Node"/>
        <ArgumentList>
          <Argument in="in" name="oldChild">
            <Type name="Node"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="DOMException"/>
        </Raises>
      </Operation>
      <Operation name="appendChild" id="::dom::Node::appendChild">
        <webidl>    <ref>Node</ref>               appendChild(in <ref>Node</ref> newChild)
                                        raises(<ref>DOMException</ref>);</webidl>
        <Type name="Node"/>
        <ArgumentList>
          <Argument in="in" name="newChild">
            <Type name="Node"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="DOMException"/>
        </Raises>
      </Operation>
      <Operation name="hasChildNodes" id="::dom::Node::hasChildNodes">
        <webidl>    boolean            hasChildNodes();</webidl>
        <Type type="boolean"/>
        <ArgumentList/>
      </Operation>
      <Operation name="cloneNode" id="::dom::Node::cloneNode">
        <webidl>    <ref>Node</ref>               cloneNode(in boolean deep);</webidl>
        <Type name="Node"/>
        <ArgumentList>
          <Argument in="in" name="deep">
            <Type type="boolean"/>
          </Argument>
        </ArgumentList>
      </Operation>
      <Operation name="normalize" id="::dom::Node::normalize">
        <webidl>    void               normalize();</webidl>
        <Type type="void"/>
        <ArgumentList/>
      </Operation>
      <Operation name="isSupported" id="::dom::Node::isSupported">
        <webidl>    boolean            isSupported(in DOMString feature, 
                                   in DOMString version);</webidl>
        <Type type="boolean"/>
        <ArgumentList>
          <Argument in="in" name="feature">
            <Type type="DOMString"/>
          </Argument>
          <Argument in="in" name="version">
            <Type type="DOMString"/>
          </Argument>
        </ArgumentList>
      </Operation>
      <Attribute readonly="readonly" name="namespaceURI" id="::dom::Node::namespaceURI">
        <webidl>    readonly attribute DOMString?      namespaceURI;</webidl>
        <Type type="DOMString" nullable="nullable"/>
      </Attribute>
      <Attribute name="prefix" id="::dom::Node::prefix">
        <webidl>             attribute DOMString?      prefix setraises(<ref>DOMException</ref>);</webidl>
        <Type type="DOMString" nullable="nullable"/>
        <SetRaises>
          <RaiseException name="DOMException"/>
        </SetRaises>
      </Attribute>
      <Attribute readonly="readonly" name="localName" id="::dom::Node::localName">
        <webidl>    readonly attribute DOMString?      localName;</webidl>
        <Type type="DOMString" nullable="nullable"/>
      </Attribute>
      <Operation name="hasAttributes" id="::dom::Node::hasAttributes">
        <webidl>    boolean            hasAttributes();</webidl>
        <Type type="boolean"/>
        <ArgumentList/>
      </Operation>
      <Attribute readonly="readonly" name="baseURI" id="::dom::Node::baseURI">
        <webidl>    readonly attribute DOMString?      baseURI;</webidl>
        <Type type="DOMString" nullable="nullable"/>
      </Attribute>
      <Const name="DOCUMENT_POSITION_DISCONNECTED" value="0x01" id="::dom::Node::DOCUMENT_POSITION_DISCONNECTED">
        <webidl>    const unsigned short      DOCUMENT_POSITION_DISCONNECTED = 0x01;</webidl>
        <Type type="unsigned short"/>
      </Const>
      <Const name="DOCUMENT_POSITION_PRECEDING" value="0x02" id="::dom::Node::DOCUMENT_POSITION_PRECEDING">
        <webidl>    const unsigned short      DOCUMENT_POSITION_PRECEDING    = 0x02;</webidl>
        <Type type="unsigned short"/>
      </Const>
      <Const name="DOCUMENT_POSITION_FOLLOWING" value="0x04" id="::dom::Node::DOCUMENT_POSITION_FOLLOWING">
        <webidl>    const unsigned short      DOCUMENT_POSITION_FOLLOWING    = 0x04;</webidl>
        <Type type="unsigned short"/>
      </Const>
      <Const name="DOCUMENT_POSITION_CONTAINS" value="0x08" id="::dom::Node::DOCUMENT_POSITION_CONTAINS">
        <webidl>    const unsigned short      DOCUMENT_POSITION_CONTAINS     = 0x08;</webidl>
        <Type type="unsigned short"/>
      </Const>
      <Const name="DOCUMENT_POSITION_CONTAINED_BY" value="0x10" id="::dom::Node::DOCUMENT_POSITION_CONTAINED_BY">
        <webidl>    const unsigned short      DOCUMENT_POSITION_CONTAINED_BY = 0x10;</webidl>
        <Type type="unsigned short"/>
      </Const>
      <Const name="DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC" value="0x20" id="::dom::Node::DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC">
        <webidl>    const unsigned short      DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC = 0x20;</webidl>
        <Type type="unsigned short"/>
      </Const>
      <Operation name="compareDocumentPosition" id="::dom::Node::compareDocumentPosition">
        <webidl>    unsigned short     compareDocumentPosition(in <ref>Node</ref> other)
                                        raises(<ref>DOMException</ref>);</webidl>
        <Type type="unsigned short"/>
        <ArgumentList>
          <Argument in="in" name="other">
            <Type name="Node"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="DOMException"/>
        </Raises>
      </Operation>
      <Attribute name="textContent" id="::dom::Node::textContent">
        <webidl>             attribute DOMString?      textContent getraises(<ref>DOMException</ref>) setraises(<ref>DOMException</ref>);</webidl>
        <Type type="DOMString" nullable="nullable"/>
        <GetRaises>
          <RaiseException name="DOMException"/>
        </GetRaises>
        <SetRaises>
          <RaiseException name="DOMException"/>
        </SetRaises>
      </Attribute>
      <Operation name="isSameNode" id="::dom::Node::isSameNode">
        <webidl>    boolean            isSameNode(in <ref>Node</ref> other);</webidl>
        <Type type="boolean"/>
        <ArgumentList>
          <Argument in="in" name="other">
            <Type name="Node"/>
          </Argument>
        </ArgumentList>
      </Operation>
      <Operation name="lookupPrefix" id="::dom::Node::lookupPrefix">
        <webidl>    DOMString?         lookupPrefix(in DOMString? namespaceURI);</webidl>
        <Type type="DOMString" nullable="nullable"/>
        <ArgumentList>
          <Argument in="in" name="namespaceURI">
            <Type type="DOMString" nullable="nullable"/>
          </Argument>
        </ArgumentList>
      </Operation>
      <Operation name="isDefaultNamespace" id="::dom::Node::isDefaultNamespace">
        <webidl>    boolean            isDefaultNamespace(in DOMString? namespaceURI);</webidl>
        <Type type="boolean"/>
        <ArgumentList>
          <Argument in="in" name="namespaceURI">
            <Type type="DOMString" nullable="nullable"/>
          </Argument>
        </ArgumentList>
      </Operation>
      <Operation name="lookupNamespaceURI" id="::dom::Node::lookupNamespaceURI">
        <webidl>    DOMString?         lookupNamespaceURI(in DOMString? prefix);</webidl>
        <Type type="DOMString" nullable="nullable"/>
        <ArgumentList>
          <Argument in="in" name="prefix">
            <Type type="DOMString" nullable="nullable"/>
          </Argument>
        </ArgumentList>
      </Operation>
      <Operation name="isEqualNode" id="::dom::Node::isEqualNode">
        <webidl>    boolean            isEqualNode(in <ref>Node</ref> arg);</webidl>
        <Type type="boolean"/>
        <ArgumentList>
          <Argument in="in" name="arg">
            <Type name="Node"/>
          </Argument>
        </ArgumentList>
      </Operation>
      <Operation name="getFeature" id="::dom::Node::getFeature">
        <webidl>    <ref>DOMObject</ref>          getFeature(in DOMString feature, 
                                  in DOMString version);</webidl>
        <Type name="DOMObject"/>
        <ArgumentList>
          <Argument in="in" name="feature">
            <Type type="DOMString"/>
          </Argument>
          <Argument in="in" name="version">
            <Type type="DOMString"/>
          </Argument>
        </ArgumentList>
      </Operation>
      <Operation name="setUserData" id="::dom::Node::setUserData">
        <webidl>    <ref>DOMUserData</ref>        setUserData(in DOMString key, 
                                   in <ref>DOMUserData</ref> data, 
                                   in <ref>UserDataHandler</ref> handler);</webidl>
        <Type name="DOMUserData"/>
        <ArgumentList>
          <Argument in="in" name="key">
            <Type type="DOMString"/>
          </Argument>
          <Argument in="in" name="data">
            <Type name="DOMUserData"/>
          </Argument>
          <Argument in="in" name="handler">
            <Type name="UserDataHandler"/>
          </Argument>
        </ArgumentList>
      </Operation>
      <Operation name="getUserData" id="::dom::Node::getUserData">
        <webidl>    <ref>DOMUserData</ref>        getUserData(in DOMString key);</webidl>
        <Type name="DOMUserData"/>
        <ArgumentList>
          <Argument in="in" name="key">
            <Type type="DOMString"/>
          </Argument>
        </ArgumentList>
      </Operation>
    </Interface>
    <Interface name="NodeList" id="::dom::NodeList">
      <webidl>  interface NodeList {
    getter <ref>Node</ref> item(in unsigned long index);
    readonly attribute unsigned long length;
  };</webidl>
      <Operation getter="getter" name="item" id="::dom::NodeList::item">
        <webidl>    getter <ref>Node</ref> item(in unsigned long index);</webidl>
        <Type name="Node"/>
        <ArgumentList>
          <Argument in="in" name="index">
            <Type type="unsigned long"/>
          </Argument>
        </ArgumentList>
      </Operation>
      <Attribute readonly="readonly" name="length" id="::dom::NodeList::length">
        <webidl>    readonly attribute unsigned long length;</webidl>
        <Type type="unsigned long"/>
      </Attribute>
    </Interface>
    <Interface name="NamedNodeMap" id="::dom::NamedNodeMap">
      <webidl>  interface NamedNodeMap {
    <ref>Node</ref>               getNamedItem(in DOMString name);
    <ref>Node</ref>               setNamedItem(in <ref>Node</ref> arg)
                                        raises(<ref>DOMException</ref>);
    <ref>Node</ref>               removeNamedItem(in DOMString name)
                                        raises(<ref>DOMException</ref>);
    getter <ref>Node</ref>        item(in unsigned long index);
    readonly attribute unsigned long   length;
    <ref>Node</ref>               getNamedItemNS(in DOMString? namespaceURI, 
                                      in DOMString? localName)
                                        raises(<ref>DOMException</ref>);
    <ref>Node</ref>               setNamedItemNS(in <ref>Node</ref> arg)
                                        raises(<ref>DOMException</ref>);
    <ref>Node</ref>               removeNamedItemNS(in DOMString? namespaceURI, 
                                         in DOMString? localName)
                                        raises(<ref>DOMException</ref>);
  };</webidl>
      <Operation name="getNamedItem" id="::dom::NamedNodeMap::getNamedItem">
        <webidl>    <ref>Node</ref>               getNamedItem(in DOMString name);</webidl>
        <Type name="Node"/>
        <ArgumentList>
          <Argument in="in" name="name">
            <Type type="DOMString"/>
          </Argument>
        </ArgumentList>
      </Operation>
      <Operation name="setNamedItem" id="::dom::NamedNodeMap::setNamedItem">
        <webidl>    <ref>Node</ref>               setNamedItem(in <ref>Node</ref> arg)
                                        raises(<ref>DOMException</ref>);</webidl>
        <Type name="Node"/>
        <ArgumentList>
          <Argument in="in" name="arg">
            <Type name="Node"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="DOMException"/>
        </Raises>
      </Operation>
      <Operation name="removeNamedItem" id="::dom::NamedNodeMap::removeNamedItem">
        <webidl>    <ref>Node</ref>               removeNamedItem(in DOMString name)
                                        raises(<ref>DOMException</ref>);</webidl>
        <Type name="Node"/>
        <ArgumentList>
          <Argument in="in" name="name">
            <Type type="DOMString"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="DOMException"/>
        </Raises>
      </Operation>
      <Operation getter="getter" name="item" id="::dom::NamedNodeMap::item">
        <webidl>    getter <ref>Node</ref>        item(in unsigned long index);</webidl>
        <Type name="Node"/>
        <ArgumentList>
          <Argument in="in" name="index">
            <Type type="unsigned long"/>
          </Argument>
        </ArgumentList>
      </Operation>
      <Attribute readonly="readonly" name="length" id="::dom::NamedNodeMap::length">
        <webidl>    readonly attribute unsigned long   length;</webidl>
        <Type type="unsigned long"/>
      </Attribute>
      <Operation name="getNamedItemNS" id="::dom::NamedNodeMap::getNamedItemNS">
        <webidl>    <ref>Node</ref>               getNamedItemNS(in DOMString? namespaceURI, 
                                      in DOMString? localName)
                                        raises(<ref>DOMException</ref>);</webidl>
        <Type name="Node"/>
        <ArgumentList>
          <Argument in="in" name="namespaceURI">
            <Type type="DOMString" nullable="nullable"/>
          </Argument>
          <Argument in="in" name="localName">
            <Type type="DOMString" nullable="nullable"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="DOMException"/>
        </Raises>
      </Operation>
      <Operation name="setNamedItemNS" id="::dom::NamedNodeMap::setNamedItemNS">
        <webidl>    <ref>Node</ref>               setNamedItemNS(in <ref>Node</ref> arg)
                                        raises(<ref>DOMException</ref>);</webidl>
        <Type name="Node"/>
        <ArgumentList>
          <Argument in="in" name="arg">
            <Type name="Node"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="DOMException"/>
        </Raises>
      </Operation>
      <Operation name="removeNamedItemNS" id="::dom::NamedNodeMap::removeNamedItemNS">
        <webidl>    <ref>Node</ref>               removeNamedItemNS(in DOMString? namespaceURI, 
                                         in DOMString? localName)
                                        raises(<ref>DOMException</ref>);</webidl>
        <Type name="Node"/>
        <ArgumentList>
          <Argument in="in" name="namespaceURI">
            <Type type="DOMString" nullable="nullable"/>
          </Argument>
          <Argument in="in" name="localName">
            <Type type="DOMString" nullable="nullable"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="DOMException"/>
        </Raises>
      </Operation>
    </Interface>
    <Interface name="CharacterData" id="::dom::CharacterData">
      <webidl>  interface CharacterData : <ref>Node</ref> {
             attribute DOMString       data getraises(<ref>DOMException</ref>) setraises(<ref>DOMException</ref>);

    readonly attribute unsigned long   length;
    DOMString          substringData(in unsigned long offset, 
                                     in unsigned long count)
                                        raises(<ref>DOMException</ref>);
    void               appendData(in DOMString arg)
                                        raises(<ref>DOMException</ref>);
    void               insertData(in unsigned long offset, 
                                  in DOMString arg)
                                        raises(<ref>DOMException</ref>);
    void               deleteData(in unsigned long offset, 
                                  in unsigned long count)
                                        raises(<ref>DOMException</ref>);
    void               replaceData(in unsigned long offset, 
                                   in unsigned long count, 
                                   in DOMString arg)
                                        raises(<ref>DOMException</ref>);
  };</webidl>
      <InterfaceInheritance>
        <Name name="Node"/>
      </InterfaceInheritance>
      <Attribute name="data" id="::dom::CharacterData::data">
        <webidl>             attribute DOMString       data getraises(<ref>DOMException</ref>) setraises(<ref>DOMException</ref>);</webidl>
        <Type type="DOMString"/>
        <GetRaises>
          <RaiseException name="DOMException"/>
        </GetRaises>
        <SetRaises>
          <RaiseException name="DOMException"/>
        </SetRaises>
      </Attribute>
      <Attribute readonly="readonly" name="length" id="::dom::CharacterData::length">
        <webidl>    readonly attribute unsigned long   length;</webidl>
        <Type type="unsigned long"/>
      </Attribute>
      <Operation name="substringData" id="::dom::CharacterData::substringData">
        <webidl>    DOMString          substringData(in unsigned long offset, 
                                     in unsigned long count)
                                        raises(<ref>DOMException</ref>);</webidl>
        <Type type="DOMString"/>
        <ArgumentList>
          <Argument in="in" name="offset">
            <Type type="unsigned long"/>
          </Argument>
          <Argument in="in" name="count">
            <Type type="unsigned long"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="DOMException"/>
        </Raises>
      </Operation>
      <Operation name="appendData" id="::dom::CharacterData::appendData">
        <webidl>    void               appendData(in DOMString arg)
                                        raises(<ref>DOMException</ref>);</webidl>
        <Type type="void"/>
        <ArgumentList>
          <Argument in="in" name="arg">
            <Type type="DOMString"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="DOMException"/>
        </Raises>
      </Operation>
      <Operation name="insertData" id="::dom::CharacterData::insertData">
        <webidl>    void               insertData(in unsigned long offset, 
                                  in DOMString arg)
                                        raises(<ref>DOMException</ref>);</webidl>
        <Type type="void"/>
        <ArgumentList>
          <Argument in="in" name="offset">
            <Type type="unsigned long"/>
          </Argument>
          <Argument in="in" name="arg">
            <Type type="DOMString"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="DOMException"/>
        </Raises>
      </Operation>
      <Operation name="deleteData" id="::dom::CharacterData::deleteData">
        <webidl>    void               deleteData(in unsigned long offset, 
                                  in unsigned long count)
                                        raises(<ref>DOMException</ref>);</webidl>
        <Type type="void"/>
        <ArgumentList>
          <Argument in="in" name="offset">
            <Type type="unsigned long"/>
          </Argument>
          <Argument in="in" name="count">
            <Type type="unsigned long"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="DOMException"/>
        </Raises>
      </Operation>
      <Operation name="replaceData" id="::dom::CharacterData::replaceData">
        <webidl>    void               replaceData(in unsigned long offset, 
                                   in unsigned long count, 
                                   in DOMString arg)
                                        raises(<ref>DOMException</ref>);</webidl>
        <Type type="void"/>
        <ArgumentList>
          <Argument in="in" name="offset">
            <Type type="unsigned long"/>
          </Argument>
          <Argument in="in" name="count">
            <Type type="unsigned long"/>
          </Argument>
          <Argument in="in" name="arg">
            <Type type="DOMString"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="DOMException"/>
        </Raises>
      </Operation>
    </Interface>
    <Interface name="Attr" id="::dom::Attr">
      <webidl>  interface Attr : <ref>Node</ref> {
    readonly attribute DOMString       name;
    readonly attribute boolean         specified;
             attribute DOMString       value setraises(<ref>DOMException</ref>);

    readonly attribute <ref>Element</ref>         ownerElement;
    readonly attribute <ref>TypeInfo</ref>        schemaTypeInfo;
    readonly attribute boolean         isId;
  };</webidl>
      <InterfaceInheritance>
        <Name name="Node"/>
      </InterfaceInheritance>
      <Attribute readonly="readonly" name="name" id="::dom::Attr::name">
        <webidl>    readonly attribute DOMString       name;</webidl>
        <Type type="DOMString"/>
      </Attribute>
      <Attribute readonly="readonly" name="specified" id="::dom::Attr::specified">
        <webidl>    readonly attribute boolean         specified;</webidl>
        <Type type="boolean"/>
      </Attribute>
      <Attribute name="value" id="::dom::Attr::value">
        <webidl>             attribute DOMString       value setraises(<ref>DOMException</ref>);</webidl>
        <Type type="DOMString"/>
        <SetRaises>
          <RaiseException name="DOMException"/>
        </SetRaises>
      </Attribute>
      <Attribute readonly="readonly" name="ownerElement" id="::dom::Attr::ownerElement">
        <webidl>    readonly attribute <ref>Element</ref>         ownerElement;</webidl>
        <Type name="Element"/>
      </Attribute>
      <Attribute readonly="readonly" name="schemaTypeInfo" id="::dom::Attr::schemaTypeInfo">
        <webidl>    readonly attribute <ref>TypeInfo</ref>        schemaTypeInfo;</webidl>
        <Type name="TypeInfo"/>
      </Attribute>
      <Attribute readonly="readonly" name="isId" id="::dom::Attr::isId">
        <webidl>    readonly attribute boolean         isId;</webidl>
        <Type type="boolean"/>
      </Attribute>
    </Interface>
    <Interface name="Element" id="::dom::Element">
      <webidl>  interface Element : <ref>Node</ref> {
    readonly attribute DOMString       tagName;
    DOMString          getAttribute(in DOMString name);
    void               setAttribute(in DOMString name, 
                                    in DOMString value)
                                        raises(<ref>DOMException</ref>);
    void               removeAttribute(in DOMString name)
                                        raises(<ref>DOMException</ref>);
    <ref>Attr</ref>               getAttributeNode(in DOMString name);
    <ref>Attr</ref>               setAttributeNode(in <ref>Attr</ref> newAttr)
                                        raises(<ref>DOMException</ref>);
    <ref>Attr</ref>               removeAttributeNode(in <ref>Attr</ref> oldAttr)
                                        raises(<ref>DOMException</ref>);
    <ref>NodeList</ref>           getElementsByTagName(in DOMString name);
    DOMString          getAttributeNS(in DOMString? namespaceURI, 
                                      in DOMString localName)
                                        raises(<ref>DOMException</ref>);
    void               setAttributeNS(in DOMString? namespaceURI, 
                                      in DOMString qualifiedName, 
                                      in DOMString value)
                                        raises(<ref>DOMException</ref>);
    void               removeAttributeNS(in DOMString? namespaceURI, 
                                         in DOMString localName)
                                        raises(<ref>DOMException</ref>);
    <ref>Attr</ref>               getAttributeNodeNS(in DOMString? namespaceURI, 
                                          in DOMString localName)
                                        raises(<ref>DOMException</ref>);
    <ref>Attr</ref>               setAttributeNodeNS(in <ref>Attr</ref> newAttr)
                                        raises(<ref>DOMException</ref>);
    <ref>NodeList</ref>           getElementsByTagNameNS(in DOMString? namespaceURI, 
                                              in DOMString localName)
                                        raises(<ref>DOMException</ref>);
    boolean            hasAttribute(in DOMString name);
    boolean            hasAttributeNS(in DOMString? namespaceURI, 
                                      in DOMString localName)
                                        raises(<ref>DOMException</ref>);
    readonly attribute <ref>TypeInfo</ref>        schemaTypeInfo;
    void               setIdAttribute(in DOMString name, 
                                      in boolean isId)
                                        raises(<ref>DOMException</ref>);
    void               setIdAttributeNS(in DOMString? namespaceURI, 
                                        in DOMString localName, 
                                        in boolean isId)
                                        raises(<ref>DOMException</ref>);
    void               setIdAttributeNode(in <ref>Attr</ref> idAttr, 
                                          in boolean isId)
                                        raises(<ref>DOMException</ref>);
  };</webidl>
      <InterfaceInheritance>
        <Name name="Node"/>
      </InterfaceInheritance>
      <Attribute readonly="readonly" name="tagName" id="::dom::Element::tagName">
        <webidl>    readonly attribute DOMString       tagName;</webidl>
        <Type type="DOMString"/>
      </Attribute>
      <Operation name="getAttribute" id="::dom::Element::getAttribute">
        <webidl>    DOMString          getAttribute(in DOMString name);</webidl>
        <Type type="DOMString"/>
        <ArgumentList>
          <Argument in="in" name="name">
            <Type type="DOMString"/>
          </Argument>
        </ArgumentList>
      </Operation>
      <Operation name="setAttribute" id="::dom::Element::setAttribute">
        <webidl>    void               setAttribute(in DOMString name, 
                                    in DOMString value)
                                        raises(<ref>DOMException</ref>);</webidl>
        <Type type="void"/>
        <ArgumentList>
          <Argument in="in" name="name">
            <Type type="DOMString"/>
          </Argument>
          <Argument in="in" name="value">
            <Type type="DOMString"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="DOMException"/>
        </Raises>
      </Operation>
      <Operation name="removeAttribute" id="::dom::Element::removeAttribute">
        <webidl>    void               removeAttribute(in DOMString name)
                                        raises(<ref>DOMException</ref>);</webidl>
        <Type type="void"/>
        <ArgumentList>
          <Argument in="in" name="name">
            <Type type="DOMString"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="DOMException"/>
        </Raises>
      </Operation>
      <Operation name="getAttributeNode" id="::dom::Element::getAttributeNode">
        <webidl>    <ref>Attr</ref>               getAttributeNode(in DOMString name);</webidl>
        <Type name="Attr"/>
        <ArgumentList>
          <Argument in="in" name="name">
            <Type type="DOMString"/>
          </Argument>
        </ArgumentList>
      </Operation>
      <Operation name="setAttributeNode" id="::dom::Element::setAttributeNode">
        <webidl>    <ref>Attr</ref>               setAttributeNode(in <ref>Attr</ref> newAttr)
                                        raises(<ref>DOMException</ref>);</webidl>
        <Type name="Attr"/>
        <ArgumentList>
          <Argument in="in" name="newAttr">
            <Type name="Attr"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="DOMException"/>
        </Raises>
      </Operation>
      <Operation name="removeAttributeNode" id="::dom::Element::removeAttributeNode">
        <webidl>    <ref>Attr</ref>               removeAttributeNode(in <ref>Attr</ref> oldAttr)
                                        raises(<ref>DOMException</ref>);</webidl>
        <Type name="Attr"/>
        <ArgumentList>
          <Argument in="in" name="oldAttr">
            <Type name="Attr"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="DOMException"/>
        </Raises>
      </Operation>
      <Operation name="getElementsByTagName" id="::dom::Element::getElementsByTagName">
        <webidl>    <ref>NodeList</ref>           getElementsByTagName(in DOMString name);</webidl>
        <Type name="NodeList"/>
        <ArgumentList>
          <Argument in="in" name="name">
            <Type type="DOMString"/>
          </Argument>
        </ArgumentList>
      </Operation>
      <Operation name="getAttributeNS" id="::dom::Element::getAttributeNS">
        <webidl>    DOMString          getAttributeNS(in DOMString? namespaceURI, 
                                      in DOMString localName)
                                        raises(<ref>DOMException</ref>);</webidl>
        <Type type="DOMString"/>
        <ArgumentList>
          <Argument in="in" name="namespaceURI">
            <Type type="DOMString" nullable="nullable"/>
          </Argument>
          <Argument in="in" name="localName">
            <Type type="DOMString"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="DOMException"/>
        </Raises>
      </Operation>
      <Operation name="setAttributeNS" id="::dom::Element::setAttributeNS">
        <webidl>    void               setAttributeNS(in DOMString? namespaceURI, 
                                      in DOMString qualifiedName, 
                                      in DOMString value)
                                        raises(<ref>DOMException</ref>);</webidl>
        <Type type="void"/>
        <ArgumentList>
          <Argument in="in" name="namespaceURI">
            <Type type="DOMString" nullable="nullable"/>
          </Argument>
          <Argument in="in" name="qualifiedName">
            <Type type="DOMString"/>
          </Argument>
          <Argument in="in" name="value">
            <Type type="DOMString"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="DOMException"/>
        </Raises>
      </Operation>
      <Operation name="removeAttributeNS" id="::dom::Element::removeAttributeNS">
        <webidl>    void               removeAttributeNS(in DOMString? namespaceURI, 
                                         in DOMString localName)
                                        raises(<ref>DOMException</ref>);</webidl>
        <Type type="void"/>
        <ArgumentList>
          <Argument in="in" name="namespaceURI">
            <Type type="DOMString" nullable="nullable"/>
          </Argument>
          <Argument in="in" name="localName">
            <Type type="DOMString"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="DOMException"/>
        </Raises>
      </Operation>
      <Operation name="getAttributeNodeNS" id="::dom::Element::getAttributeNodeNS">
        <webidl>    <ref>Attr</ref>               getAttributeNodeNS(in DOMString? namespaceURI, 
                                          in DOMString localName)
                                        raises(<ref>DOMException</ref>);</webidl>
        <Type name="Attr"/>
        <ArgumentList>
          <Argument in="in" name="namespaceURI">
            <Type type="DOMString" nullable="nullable"/>
          </Argument>
          <Argument in="in" name="localName">
            <Type type="DOMString"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="DOMException"/>
        </Raises>
      </Operation>
      <Operation name="setAttributeNodeNS" id="::dom::Element::setAttributeNodeNS">
        <webidl>    <ref>Attr</ref>               setAttributeNodeNS(in <ref>Attr</ref> newAttr)
                                        raises(<ref>DOMException</ref>);</webidl>
        <Type name="Attr"/>
        <ArgumentList>
          <Argument in="in" name="newAttr">
            <Type name="Attr"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="DOMException"/>
        </Raises>
      </Operation>
      <Operation name="getElementsByTagNameNS" id="::dom::Element::getElementsByTagNameNS">
        <webidl>    <ref>NodeList</ref>           getElementsByTagNameNS(in DOMString? namespaceURI, 
                                              in DOMString localName)
                                        raises(<ref>DOMException</ref>);</webidl>
        <Type name="NodeList"/>
        <ArgumentList>
          <Argument in="in" name="namespaceURI">
            <Type type="DOMString" nullable="nullable"/>
          </Argument>
          <Argument in="in" name="localName">
            <Type type="DOMString"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="DOMException"/>
        </Raises>
      </Operation>
      <Operation name="hasAttribute" id="::dom::Element::hasAttribute">
        <webidl>    boolean            hasAttribute(in DOMString name);</webidl>
        <Type type="boolean"/>
        <ArgumentList>
          <Argument in="in" name="name">
            <Type type="DOMString"/>
          </Argument>
        </ArgumentList>
      </Operation>
      <Operation name="hasAttributeNS" id="::dom::Element::hasAttributeNS">
        <webidl>    boolean            hasAttributeNS(in DOMString? namespaceURI, 
                                      in DOMString localName)
                                        raises(<ref>DOMException</ref>);</webidl>
        <Type type="boolean"/>
        <ArgumentList>
          <Argument in="in" name="namespaceURI">
            <Type type="DOMString" nullable="nullable"/>
          </Argument>
          <Argument in="in" name="localName">
            <Type type="DOMString"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="DOMException"/>
        </Raises>
      </Operation>
      <Attribute readonly="readonly" name="schemaTypeInfo" id="::dom::Element::schemaTypeInfo">
        <webidl>    readonly attribute <ref>TypeInfo</ref>        schemaTypeInfo;</webidl>
        <Type name="TypeInfo"/>
      </Attribute>
      <Operation name="setIdAttribute" id="::dom::Element::setIdAttribute">
        <webidl>    void               setIdAttribute(in DOMString name, 
                                      in boolean isId)
                                        raises(<ref>DOMException</ref>);</webidl>
        <Type type="void"/>
        <ArgumentList>
          <Argument in="in" name="name">
            <Type type="DOMString"/>
          </Argument>
          <Argument in="in" name="isId">
            <Type type="boolean"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="DOMException"/>
        </Raises>
      </Operation>
      <Operation name="setIdAttributeNS" id="::dom::Element::setIdAttributeNS">
        <webidl>    void               setIdAttributeNS(in DOMString? namespaceURI, 
                                        in DOMString localName, 
                                        in boolean isId)
                                        raises(<ref>DOMException</ref>);</webidl>
        <Type type="void"/>
        <ArgumentList>
          <Argument in="in" name="namespaceURI">
            <Type type="DOMString" nullable="nullable"/>
          </Argument>
          <Argument in="in" name="localName">
            <Type type="DOMString"/>
          </Argument>
          <Argument in="in" name="isId">
            <Type type="boolean"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="DOMException"/>
        </Raises>
      </Operation>
      <Operation name="setIdAttributeNode" id="::dom::Element::setIdAttributeNode">
        <webidl>    void               setIdAttributeNode(in <ref>Attr</ref> idAttr, 
                                          in boolean isId)
                                        raises(<ref>DOMException</ref>);</webidl>
        <Type type="void"/>
        <ArgumentList>
          <Argument in="in" name="idAttr">
            <Type name="Attr"/>
          </Argument>
          <Argument in="in" name="isId">
            <Type type="boolean"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="DOMException"/>
        </Raises>
      </Operation>
    </Interface>
    <Interface name="Text" id="::dom::Text">
      <webidl>  interface Text : <ref>CharacterData</ref> {
    <ref>Text</ref>               splitText(in unsigned long offset)
                                        raises(<ref>DOMException</ref>);
    readonly attribute boolean         isElementContentWhitespace;
    readonly attribute DOMString       wholeText;
    <ref>Text</ref>               replaceWholeText(in DOMString content)
                                        raises(<ref>DOMException</ref>);
  };</webidl>
      <InterfaceInheritance>
        <Name name="CharacterData"/>
      </InterfaceInheritance>
      <Operation name="splitText" id="::dom::Text::splitText">
        <webidl>    <ref>Text</ref>               splitText(in unsigned long offset)
                                        raises(<ref>DOMException</ref>);</webidl>
        <Type name="Text"/>
        <ArgumentList>
          <Argument in="in" name="offset">
            <Type type="unsigned long"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="DOMException"/>
        </Raises>
      </Operation>
      <Attribute readonly="readonly" name="isElementContentWhitespace" id="::dom::Text::isElementContentWhitespace">
        <webidl>    readonly attribute boolean         isElementContentWhitespace;</webidl>
        <Type type="boolean"/>
      </Attribute>
      <Attribute readonly="readonly" name="wholeText" id="::dom::Text::wholeText">
        <webidl>    readonly attribute DOMString       wholeText;</webidl>
        <Type type="DOMString"/>
      </Attribute>
      <Operation name="replaceWholeText" id="::dom::Text::replaceWholeText">
        <webidl>    <ref>Text</ref>               replaceWholeText(in DOMString content)
                                        raises(<ref>DOMException</ref>);</webidl>
        <Type name="Text"/>
        <ArgumentList>
          <Argument in="in" name="content">
            <Type type="DOMString"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="DOMException"/>
        </Raises>
      </Operation>
    </Interface>
    <Interface name="Comment" id="::dom::Comment">
      <webidl>  interface Comment : <ref>CharacterData</ref> {
  };</webidl>
      <InterfaceInheritance>
        <Name name="CharacterData"/>
      </InterfaceInheritance>
    </Interface>
    <Interface name="TypeInfo" id="::dom::TypeInfo">
      <webidl>  interface TypeInfo {
    readonly attribute DOMString?      typeName;
    readonly attribute DOMString?      typeNamespace;

    const unsigned long       DERIVATION_RESTRICTION         = 0x00000001;
    const unsigned long       DERIVATION_EXTENSION           = 0x00000002;
    const unsigned long       DERIVATION_UNION               = 0x00000004;
    const unsigned long       DERIVATION_LIST                = 0x00000008;

    boolean            isDerivedFrom(in DOMString? typeNamespaceArg, 
                                     in DOMString typeNameArg, 
                                     in unsigned long derivationMethod);
  };</webidl>
      <Attribute readonly="readonly" name="typeName" id="::dom::TypeInfo::typeName">
        <webidl>    readonly attribute DOMString?      typeName;</webidl>
        <Type type="DOMString" nullable="nullable"/>
      </Attribute>
      <Attribute readonly="readonly" name="typeNamespace" id="::dom::TypeInfo::typeNamespace">
        <webidl>    readonly attribute DOMString?      typeNamespace;</webidl>
        <Type type="DOMString" nullable="nullable"/>
      </Attribute>
      <Const name="DERIVATION_RESTRICTION" value="0x00000001" id="::dom::TypeInfo::DERIVATION_RESTRICTION">
        <webidl>    const unsigned long       DERIVATION_RESTRICTION         = 0x00000001;</webidl>
        <Type type="unsigned long"/>
      </Const>
      <Const name="DERIVATION_EXTENSION" value="0x00000002" id="::dom::TypeInfo::DERIVATION_EXTENSION">
        <webidl>    const unsigned long       DERIVATION_EXTENSION           = 0x00000002;</webidl>
        <Type type="unsigned long"/>
      </Const>
      <Const name="DERIVATION_UNION" value="0x00000004" id="::dom::TypeInfo::DERIVATION_UNION">
        <webidl>    const unsigned long       DERIVATION_UNION               = 0x00000004;</webidl>
        <Type type="unsigned long"/>
      </Const>
      <Const name="DERIVATION_LIST" value="0x00000008" id="::dom::TypeInfo::DERIVATION_LIST">
        <webidl>    const unsigned long       DERIVATION_LIST                = 0x00000008;</webidl>
        <Type type="unsigned long"/>
      </Const>
      <Operation name="isDerivedFrom" id="::dom::TypeInfo::isDerivedFrom">
        <webidl>    boolean            isDerivedFrom(in DOMString? typeNamespaceArg, 
                                     in DOMString typeNameArg, 
                                     in unsigned long derivationMethod);</webidl>
        <Type type="boolean"/>
        <ArgumentList>
          <Argument in="in" name="typeNamespaceArg">
            <Type type="DOMString" nullable="nullable"/>
          </Argument>
          <Argument in="in" name="typeNameArg">
            <Type type="DOMString"/>
          </Argument>
          <Argument in="in" name="derivationMethod">
            <Type type="unsigned long"/>
          </Argument>
        </ArgumentList>
      </Operation>
    </Interface>
    <Interface name="UserDataHandler" id="::dom::UserDataHandler">
      <webidl>  [Callback]
  interface UserDataHandler {

    const unsigned short      NODE_CLONED                    = 1;
    const unsigned short      NODE_IMPORTED                  = 2;
    const unsigned short      NODE_DELETED                   = 3;
    const unsigned short      NODE_RENAMED                   = 4;
    const unsigned short      NODE_ADOPTED                   = 5;

    void               handle(in unsigned short operation, 
                              in DOMString key, 
                              in <ref>DOMUserData</ref> data, 
                              in <ref>Node</ref> src, 
                              in <ref>Node</ref> dst);
  };</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="Callback"/>
      </ExtendedAttributeList>
      <Const name="NODE_CLONED" value="1" id="::dom::UserDataHandler::NODE_CLONED">
        <webidl>    const unsigned short      NODE_CLONED                    = 1;</webidl>
        <Type type="unsigned short"/>
      </Const>
      <Const name="NODE_IMPORTED" value="2" id="::dom::UserDataHandler::NODE_IMPORTED">
        <webidl>    const unsigned short      NODE_IMPORTED                  = 2;</webidl>
        <Type type="unsigned short"/>
      </Const>
      <Const name="NODE_DELETED" value="3" id="::dom::UserDataHandler::NODE_DELETED">
        <webidl>    const unsigned short      NODE_DELETED                   = 3;</webidl>
        <Type type="unsigned short"/>
      </Const>
      <Const name="NODE_RENAMED" value="4" id="::dom::UserDataHandler::NODE_RENAMED">
        <webidl>    const unsigned short      NODE_RENAMED                   = 4;</webidl>
        <Type type="unsigned short"/>
      </Const>
      <Const name="NODE_ADOPTED" value="5" id="::dom::UserDataHandler::NODE_ADOPTED">
        <webidl>    const unsigned short      NODE_ADOPTED                   = 5;</webidl>
        <Type type="unsigned short"/>
      </Const>
      <Operation name="handle" id="::dom::UserDataHandler::handle">
        <webidl>    void               handle(in unsigned short operation, 
                              in DOMString key, 
                              in <ref>DOMUserData</ref> data, 
                              in <ref>Node</ref> src, 
                              in <ref>Node</ref> dst);</webidl>
        <Type type="void"/>
        <ArgumentList>
          <Argument in="in" name="operation">
            <Type type="unsigned short"/>
          </Argument>
          <Argument in="in" name="key">
            <Type type="DOMString"/>
          </Argument>
          <Argument in="in" name="data">
            <Type name="DOMUserData"/>
          </Argument>
          <Argument in="in" name="src">
            <Type name="Node"/>
          </Argument>
          <Argument in="in" name="dst">
            <Type name="Node"/>
          </Argument>
        </ArgumentList>
      </Operation>
    </Interface>
    <Interface name="DOMError" id="::dom::DOMError">
      <webidl>  interface DOMError {

    const unsigned short      SEVERITY_WARNING               = 1;
    const unsigned short      SEVERITY_ERROR                 = 2;
    const unsigned short      SEVERITY_FATAL_ERROR           = 3;

    readonly attribute unsigned short  severity;
    readonly attribute DOMString       message;
    readonly attribute DOMString       type;
    readonly attribute <ref>DOMObject</ref>       relatedException;
    readonly attribute <ref>DOMObject</ref>       relatedData;
    readonly attribute <ref>DOMLocator</ref>      location;
  };</webidl>
      <Const name="SEVERITY_WARNING" value="1" id="::dom::DOMError::SEVERITY_WARNING">
        <webidl>    const unsigned short      SEVERITY_WARNING               = 1;</webidl>
        <Type type="unsigned short"/>
      </Const>
      <Const name="SEVERITY_ERROR" value="2" id="::dom::DOMError::SEVERITY_ERROR">
        <webidl>    const unsigned short      SEVERITY_ERROR                 = 2;</webidl>
        <Type type="unsigned short"/>
      </Const>
      <Const name="SEVERITY_FATAL_ERROR" value="3" id="::dom::DOMError::SEVERITY_FATAL_ERROR">
        <webidl>    const unsigned short      SEVERITY_FATAL_ERROR           = 3;</webidl>
        <Type type="unsigned short"/>
      </Const>
      <Attribute readonly="readonly" name="severity" id="::dom::DOMError::severity">
        <webidl>    readonly attribute unsigned short  severity;</webidl>
        <Type type="unsigned short"/>
      </Attribute>
      <Attribute readonly="readonly" name="message" id="::dom::DOMError::message">
        <webidl>    readonly attribute DOMString       message;</webidl>
        <Type type="DOMString"/>
      </Attribute>
      <Attribute readonly="readonly" name="type" id="::dom::DOMError::type">
        <webidl>    readonly attribute DOMString       type;</webidl>
        <Type type="DOMString"/>
      </Attribute>
      <Attribute readonly="readonly" name="relatedException" id="::dom::DOMError::relatedException">
        <webidl>    readonly attribute <ref>DOMObject</ref>       relatedException;</webidl>
        <Type name="DOMObject"/>
      </Attribute>
      <Attribute readonly="readonly" name="relatedData" id="::dom::DOMError::relatedData">
        <webidl>    readonly attribute <ref>DOMObject</ref>       relatedData;</webidl>
        <Type name="DOMObject"/>
      </Attribute>
      <Attribute readonly="readonly" name="location" id="::dom::DOMError::location">
        <webidl>    readonly attribute <ref>DOMLocator</ref>      location;</webidl>
        <Type name="DOMLocator"/>
      </Attribute>
    </Interface>
    <Interface name="DOMErrorHandler" id="::dom::DOMErrorHandler">
      <webidl>  interface DOMErrorHandler {
    boolean            handleError(in <ref>DOMError</ref> error);
  };</webidl>
      <Operation name="handleError" id="::dom::DOMErrorHandler::handleError">
        <webidl>    boolean            handleError(in <ref>DOMError</ref> error);</webidl>
        <Type type="boolean"/>
        <ArgumentList>
          <Argument in="in" name="error">
            <Type name="DOMError"/>
          </Argument>
        </ArgumentList>
      </Operation>
    </Interface>
    <Interface name="DOMLocator" id="::dom::DOMLocator">
      <webidl>  interface DOMLocator {
    readonly attribute long            lineNumber;
    readonly attribute long            columnNumber;
    readonly attribute long            byteOffset;
    readonly attribute long            utf16Offset;
    readonly attribute <ref>Node</ref>            relatedNode;
    readonly attribute DOMString?      uri;
  };</webidl>
      <Attribute readonly="readonly" name="lineNumber" id="::dom::DOMLocator::lineNumber">
        <webidl>    readonly attribute long            lineNumber;</webidl>
        <Type type="long"/>
      </Attribute>
      <Attribute readonly="readonly" name="columnNumber" id="::dom::DOMLocator::columnNumber">
        <webidl>    readonly attribute long            columnNumber;</webidl>
        <Type type="long"/>
      </Attribute>
      <Attribute readonly="readonly" name="byteOffset" id="::dom::DOMLocator::byteOffset">
        <webidl>    readonly attribute long            byteOffset;</webidl>
        <Type type="long"/>
      </Attribute>
      <Attribute readonly="readonly" name="utf16Offset" id="::dom::DOMLocator::utf16Offset">
        <webidl>    readonly attribute long            utf16Offset;</webidl>
        <Type type="long"/>
      </Attribute>
      <Attribute readonly="readonly" name="relatedNode" id="::dom::DOMLocator::relatedNode">
        <webidl>    readonly attribute <ref>Node</ref>            relatedNode;</webidl>
        <Type name="Node"/>
      </Attribute>
      <Attribute readonly="readonly" name="uri" id="::dom::DOMLocator::uri">
        <webidl>    readonly attribute DOMString?      uri;</webidl>
        <Type type="DOMString" nullable="nullable"/>
      </Attribute>
    </Interface>
    <Interface name="DOMConfiguration" id="::dom::DOMConfiguration">
      <webidl>  interface DOMConfiguration {
    void               setParameter(in DOMString name, 
                                    in <ref>DOMUserData</ref> value)
                                        raises(<ref>DOMException</ref>);
    <ref>DOMUserData</ref>        getParameter(in DOMString name)
                                        raises(<ref>DOMException</ref>);
    boolean            canSetParameter(in DOMString name, 
                                       in <ref>DOMUserData</ref> value);
    readonly attribute <ref>DOMStringList</ref>   parameterNames;
  };</webidl>
      <Operation name="setParameter" id="::dom::DOMConfiguration::setParameter">
        <webidl>    void               setParameter(in DOMString name, 
                                    in <ref>DOMUserData</ref> value)
                                        raises(<ref>DOMException</ref>);</webidl>
        <Type type="void"/>
        <ArgumentList>
          <Argument in="in" name="name">
            <Type type="DOMString"/>
          </Argument>
          <Argument in="in" name="value">
            <Type name="DOMUserData"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="DOMException"/>
        </Raises>
      </Operation>
      <Operation name="getParameter" id="::dom::DOMConfiguration::getParameter">
        <webidl>    <ref>DOMUserData</ref>        getParameter(in DOMString name)
                                        raises(<ref>DOMException</ref>);</webidl>
        <Type name="DOMUserData"/>
        <ArgumentList>
          <Argument in="in" name="name">
            <Type type="DOMString"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="DOMException"/>
        </Raises>
      </Operation>
      <Operation name="canSetParameter" id="::dom::DOMConfiguration::canSetParameter">
        <webidl>    boolean            canSetParameter(in DOMString name, 
                                       in <ref>DOMUserData</ref> value);</webidl>
        <Type type="boolean"/>
        <ArgumentList>
          <Argument in="in" name="name">
            <Type type="DOMString"/>
          </Argument>
          <Argument in="in" name="value">
            <Type name="DOMUserData"/>
          </Argument>
        </ArgumentList>
      </Operation>
      <Attribute readonly="readonly" name="parameterNames" id="::dom::DOMConfiguration::parameterNames">
        <webidl>    readonly attribute <ref>DOMStringList</ref>   parameterNames;</webidl>
        <Type name="DOMStringList"/>
      </Attribute>
    </Interface>
    <Interface name="CDATASection" id="::dom::CDATASection">
      <webidl>  interface CDATASection : <ref>Text</ref> {
  };</webidl>
      <InterfaceInheritance>
        <Name name="Text"/>
      </InterfaceInheritance>
    </Interface>
    <Interface name="DocumentType" id="::dom::DocumentType">
      <webidl>  interface DocumentType : <ref>Node</ref> {
    readonly attribute DOMString       name;
    readonly attribute <ref>NamedNodeMap</ref>    entities;
    readonly attribute <ref>NamedNodeMap</ref>    notations;
    readonly attribute DOMString?      publicId;
    readonly attribute DOMString?      systemId;
    readonly attribute DOMString?      internalSubset;
  };</webidl>
      <InterfaceInheritance>
        <Name name="Node"/>
      </InterfaceInheritance>
      <Attribute readonly="readonly" name="name" id="::dom::DocumentType::name">
        <webidl>    readonly attribute DOMString       name;</webidl>
        <Type type="DOMString"/>
      </Attribute>
      <Attribute readonly="readonly" name="entities" id="::dom::DocumentType::entities">
        <webidl>    readonly attribute <ref>NamedNodeMap</ref>    entities;</webidl>
        <Type name="NamedNodeMap"/>
      </Attribute>
      <Attribute readonly="readonly" name="notations" id="::dom::DocumentType::notations">
        <webidl>    readonly attribute <ref>NamedNodeMap</ref>    notations;</webidl>
        <Type name="NamedNodeMap"/>
      </Attribute>
      <Attribute readonly="readonly" name="publicId" id="::dom::DocumentType::publicId">
        <webidl>    readonly attribute DOMString?      publicId;</webidl>
        <Type type="DOMString" nullable="nullable"/>
      </Attribute>
      <Attribute readonly="readonly" name="systemId" id="::dom::DocumentType::systemId">
        <webidl>    readonly attribute DOMString?      systemId;</webidl>
        <Type type="DOMString" nullable="nullable"/>
      </Attribute>
      <Attribute readonly="readonly" name="internalSubset" id="::dom::DocumentType::internalSubset">
        <webidl>    readonly attribute DOMString?      internalSubset;</webidl>
        <Type type="DOMString" nullable="nullable"/>
      </Attribute>
    </Interface>
    <Interface name="Notation" id="::dom::Notation">
      <webidl>  interface Notation : <ref>Node</ref> {
    readonly attribute DOMString?      publicId;
    readonly attribute DOMString?      systemId;
  };</webidl>
      <InterfaceInheritance>
        <Name name="Node"/>
      </InterfaceInheritance>
      <Attribute readonly="readonly" name="publicId" id="::dom::Notation::publicId">
        <webidl>    readonly attribute DOMString?      publicId;</webidl>
        <Type type="DOMString" nullable="nullable"/>
      </Attribute>
      <Attribute readonly="readonly" name="systemId" id="::dom::Notation::systemId">
        <webidl>    readonly attribute DOMString?      systemId;</webidl>
        <Type type="DOMString" nullable="nullable"/>
      </Attribute>
    </Interface>
    <Interface name="Entity" id="::dom::Entity">
      <webidl>  interface Entity : <ref>Node</ref> {
    readonly attribute DOMString?      publicId;
    readonly attribute DOMString?      systemId;
    readonly attribute DOMString?      notationName;
    readonly attribute DOMString?      inputEncoding;
    readonly attribute DOMString?      xmlEncoding;
    readonly attribute DOMString?      xmlVersion;
  };</webidl>
      <InterfaceInheritance>
        <Name name="Node"/>
      </InterfaceInheritance>
      <Attribute readonly="readonly" name="publicId" id="::dom::Entity::publicId">
        <webidl>    readonly attribute DOMString?      publicId;</webidl>
        <Type type="DOMString" nullable="nullable"/>
      </Attribute>
      <Attribute readonly="readonly" name="systemId" id="::dom::Entity::systemId">
        <webidl>    readonly attribute DOMString?      systemId;</webidl>
        <Type type="DOMString" nullable="nullable"/>
      </Attribute>
      <Attribute readonly="readonly" name="notationName" id="::dom::Entity::notationName">
        <webidl>    readonly attribute DOMString?      notationName;</webidl>
        <Type type="DOMString" nullable="nullable"/>
      </Attribute>
      <Attribute readonly="readonly" name="inputEncoding" id="::dom::Entity::inputEncoding">
        <webidl>    readonly attribute DOMString?      inputEncoding;</webidl>
        <Type type="DOMString" nullable="nullable"/>
      </Attribute>
      <Attribute readonly="readonly" name="xmlEncoding" id="::dom::Entity::xmlEncoding">
        <webidl>    readonly attribute DOMString?      xmlEncoding;</webidl>
        <Type type="DOMString" nullable="nullable"/>
      </Attribute>
      <Attribute readonly="readonly" name="xmlVersion" id="::dom::Entity::xmlVersion">
        <webidl>    readonly attribute DOMString?      xmlVersion;</webidl>
        <Type type="DOMString" nullable="nullable"/>
      </Attribute>
    </Interface>
    <Interface name="EntityReference" id="::dom::EntityReference">
      <webidl>  interface EntityReference : <ref>Node</ref> {
  };</webidl>
      <InterfaceInheritance>
        <Name name="Node"/>
      </InterfaceInheritance>
    </Interface>
    <Interface name="ProcessingInstruction" id="::dom::ProcessingInstruction">
      <webidl>  interface ProcessingInstruction : <ref>Node</ref> {
    readonly attribute DOMString       target;
             attribute DOMString       data setraises(<ref>DOMException</ref>);

  };</webidl>
      <InterfaceInheritance>
        <Name name="Node"/>
      </InterfaceInheritance>
      <Attribute readonly="readonly" name="target" id="::dom::ProcessingInstruction::target">
        <webidl>    readonly attribute DOMString       target;</webidl>
        <Type type="DOMString"/>
      </Attribute>
      <Attribute name="data" id="::dom::ProcessingInstruction::data">
        <webidl>             attribute DOMString       data setraises(<ref>DOMException</ref>);</webidl>
        <Type type="DOMString"/>
        <SetRaises>
          <RaiseException name="DOMException"/>
        </SetRaises>
      </Attribute>
    </Interface>
    <Interface name="DocumentFragment" id="::dom::DocumentFragment">
      <webidl>  interface DocumentFragment : <ref>Node</ref> {
  };</webidl>
      <InterfaceInheritance>
        <Name name="Node"/>
      </InterfaceInheritance>
    </Interface>
    <Interface name="Document" id="::dom::Document">
      <webidl>  interface Document : <ref>Node</ref> {
    readonly attribute <ref>DocumentType</ref>    doctype;
    readonly attribute <ref>DOMImplementation</ref> implementation;
    readonly attribute <ref>Element</ref>         documentElement;
    <ref>Element</ref>            createElement(in DOMString tagName)
                                        raises(<ref>DOMException</ref>);
    <ref>DocumentFragment</ref>   createDocumentFragment();
    <ref>Text</ref>               createTextNode(in DOMString data);
    <ref>Comment</ref>            createComment(in DOMString data);
    <ref>CDATASection</ref>       createCDATASection(in DOMString data)
                                        raises(<ref>DOMException</ref>);
    <ref>ProcessingInstruction</ref> createProcessingInstruction(in DOMString target, 
                                                      in DOMString data)
                                        raises(<ref>DOMException</ref>);
    <ref>Attr</ref>               createAttribute(in DOMString name)
                                        raises(<ref>DOMException</ref>);
    <ref>EntityReference</ref>    createEntityReference(in DOMString name)
                                        raises(<ref>DOMException</ref>);
    <ref>NodeList</ref>           getElementsByTagName(in DOMString tagname);
    <ref>Node</ref>               importNode(in <ref>Node</ref> importedNode, 
                                  in boolean deep)
                                        raises(<ref>DOMException</ref>);
    <ref>Element</ref>            createElementNS(in DOMString? namespaceURI, 
                                       in DOMString qualifiedName)
                                        raises(<ref>DOMException</ref>);
    <ref>Attr</ref>               createAttributeNS(in DOMString? namespaceURI, 
                                         in DOMString qualifiedName)
                                        raises(<ref>DOMException</ref>);
    <ref>NodeList</ref>           getElementsByTagNameNS(in DOMString? namespaceURI, 
                                              in DOMString localName);
    <ref>Element</ref>            getElementById(in DOMString elementId);
    readonly attribute DOMString?      inputEncoding;
    readonly attribute DOMString?      xmlEncoding;
             attribute boolean         xmlStandalone setraises(<ref>DOMException</ref>);

             attribute DOMString?      xmlVersion setraises(<ref>DOMException</ref>);

             attribute boolean         strictErrorChecking;
             attribute DOMString?      documentURI;
    <ref>Node</ref>               adoptNode(in <ref>Node</ref> source)
                                        raises(<ref>DOMException</ref>);
    readonly attribute <ref>DOMConfiguration</ref> domConfig;
    void               normalizeDocument();
    <ref>Node</ref>               renameNode(in <ref>Node</ref> n, 
                                  in DOMString? namespaceURI, 
                                  in DOMString qualifiedName)
                                        raises(<ref>DOMException</ref>);
  };</webidl>
      <InterfaceInheritance>
        <Name name="Node"/>
      </InterfaceInheritance>
      <Attribute readonly="readonly" name="doctype" id="::dom::Document::doctype">
        <webidl>    readonly attribute <ref>DocumentType</ref>    doctype;</webidl>
        <Type name="DocumentType"/>
      </Attribute>
      <Attribute readonly="readonly" name="implementation" id="::dom::Document::implementation">
        <webidl>    readonly attribute <ref>DOMImplementation</ref> implementation;</webidl>
        <Type name="DOMImplementation"/>
      </Attribute>
      <Attribute readonly="readonly" name="documentElement" id="::dom::Document::documentElement">
        <webidl>    readonly attribute <ref>Element</ref>         documentElement;</webidl>
        <Type name="Element"/>
      </Attribute>
      <Operation name="createElement" id="::dom::Document::createElement">
        <webidl>    <ref>Element</ref>            createElement(in DOMString tagName)
                                        raises(<ref>DOMException</ref>);</webidl>
        <Type name="Element"/>
        <ArgumentList>
          <Argument in="in" name="tagName">
            <Type type="DOMString"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="DOMException"/>
        </Raises>
      </Operation>
      <Operation name="createDocumentFragment" id="::dom::Document::createDocumentFragment">
        <webidl>    <ref>DocumentFragment</ref>   createDocumentFragment();</webidl>
        <Type name="DocumentFragment"/>
        <ArgumentList/>
      </Operation>
      <Operation name="createTextNode" id="::dom::Document::createTextNode">
        <webidl>    <ref>Text</ref>               createTextNode(in DOMString data);</webidl>
        <Type name="Text"/>
        <ArgumentList>
          <Argument in="in" name="data">
            <Type type="DOMString"/>
          </Argument>
        </ArgumentList>
      </Operation>
      <Operation name="createComment" id="::dom::Document::createComment">
        <webidl>    <ref>Comment</ref>            createComment(in DOMString data);</webidl>
        <Type name="Comment"/>
        <ArgumentList>
          <Argument in="in" name="data">
            <Type type="DOMString"/>
          </Argument>
        </ArgumentList>
      </Operation>
      <Operation name="createCDATASection" id="::dom::Document::createCDATASection">
        <webidl>    <ref>CDATASection</ref>       createCDATASection(in DOMString data)
                                        raises(<ref>DOMException</ref>);</webidl>
        <Type name="CDATASection"/>
        <ArgumentList>
          <Argument in="in" name="data">
            <Type type="DOMString"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="DOMException"/>
        </Raises>
      </Operation>
      <Operation name="createProcessingInstruction" id="::dom::Document::createProcessingInstruction">
        <webidl>    <ref>ProcessingInstruction</ref> createProcessingInstruction(in DOMString target, 
                                                      in DOMString data)
                                        raises(<ref>DOMException</ref>);</webidl>
        <Type name="ProcessingInstruction"/>
        <ArgumentList>
          <Argument in="in" name="target">
            <Type type="DOMString"/>
          </Argument>
          <Argument in="in" name="data">
            <Type type="DOMString"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="DOMException"/>
        </Raises>
      </Operation>
      <Operation name="createAttribute" id="::dom::Document::createAttribute">
        <webidl>    <ref>Attr</ref>               createAttribute(in DOMString name)
                                        raises(<ref>DOMException</ref>);</webidl>
        <Type name="Attr"/>
        <ArgumentList>
          <Argument in="in" name="name">
            <Type type="DOMString"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="DOMException"/>
        </Raises>
      </Operation>
      <Operation name="createEntityReference" id="::dom::Document::createEntityReference">
        <webidl>    <ref>EntityReference</ref>    createEntityReference(in DOMString name)
                                        raises(<ref>DOMException</ref>);</webidl>
        <Type name="EntityReference"/>
        <ArgumentList>
          <Argument in="in" name="name">
            <Type type="DOMString"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="DOMException"/>
        </Raises>
      </Operation>
      <Operation name="getElementsByTagName" id="::dom::Document::getElementsByTagName">
        <webidl>    <ref>NodeList</ref>           getElementsByTagName(in DOMString tagname);</webidl>
        <Type name="NodeList"/>
        <ArgumentList>
          <Argument in="in" name="tagname">
            <Type type="DOMString"/>
          </Argument>
        </ArgumentList>
      </Operation>
      <Operation name="importNode" id="::dom::Document::importNode">
        <webidl>    <ref>Node</ref>               importNode(in <ref>Node</ref> importedNode, 
                                  in boolean deep)
                                        raises(<ref>DOMException</ref>);</webidl>
        <Type name="Node"/>
        <ArgumentList>
          <Argument in="in" name="importedNode">
            <Type name="Node"/>
          </Argument>
          <Argument in="in" name="deep">
            <Type type="boolean"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="DOMException"/>
        </Raises>
      </Operation>
      <Operation name="createElementNS" id="::dom::Document::createElementNS">
        <webidl>    <ref>Element</ref>            createElementNS(in DOMString? namespaceURI, 
                                       in DOMString qualifiedName)
                                        raises(<ref>DOMException</ref>);</webidl>
        <Type name="Element"/>
        <ArgumentList>
          <Argument in="in" name="namespaceURI">
            <Type type="DOMString" nullable="nullable"/>
          </Argument>
          <Argument in="in" name="qualifiedName">
            <Type type="DOMString"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="DOMException"/>
        </Raises>
      </Operation>
      <Operation name="createAttributeNS" id="::dom::Document::createAttributeNS">
        <webidl>    <ref>Attr</ref>               createAttributeNS(in DOMString? namespaceURI, 
                                         in DOMString qualifiedName)
                                        raises(<ref>DOMException</ref>);</webidl>
        <Type name="Attr"/>
        <ArgumentList>
          <Argument in="in" name="namespaceURI">
            <Type type="DOMString" nullable="nullable"/>
          </Argument>
          <Argument in="in" name="qualifiedName">
            <Type type="DOMString"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="DOMException"/>
        </Raises>
      </Operation>
      <Operation name="getElementsByTagNameNS" id="::dom::Document::getElementsByTagNameNS">
        <webidl>    <ref>NodeList</ref>           getElementsByTagNameNS(in DOMString? namespaceURI, 
                                              in DOMString localName);</webidl>
        <Type name="NodeList"/>
        <ArgumentList>
          <Argument in="in" name="namespaceURI">
            <Type type="DOMString" nullable="nullable"/>
          </Argument>
          <Argument in="in" name="localName">
            <Type type="DOMString"/>
          </Argument>
        </ArgumentList>
      </Operation>
      <Operation name="getElementById" id="::dom::Document::getElementById">
        <webidl>    <ref>Element</ref>            getElementById(in DOMString elementId);</webidl>
        <Type name="Element"/>
        <ArgumentList>
          <Argument in="in" name="elementId">
            <Type type="DOMString"/>
          </Argument>
        </ArgumentList>
      </Operation>
      <Attribute readonly="readonly" name="inputEncoding" id="::dom::Document::inputEncoding">
        <webidl>    readonly attribute DOMString?      inputEncoding;</webidl>
        <Type type="DOMString" nullable="nullable"/>
      </Attribute>
      <Attribute readonly="readonly" name="xmlEncoding" id="::dom::Document::xmlEncoding">
        <webidl>    readonly attribute DOMString?      xmlEncoding;</webidl>
        <Type type="DOMString" nullable="nullable"/>
      </Attribute>
      <Attribute name="xmlStandalone" id="::dom::Document::xmlStandalone">
        <webidl>             attribute boolean         xmlStandalone setraises(<ref>DOMException</ref>);</webidl>
        <Type type="boolean"/>
        <SetRaises>
          <RaiseException name="DOMException"/>
        </SetRaises>
      </Attribute>
      <Attribute name="xmlVersion" id="::dom::Document::xmlVersion">
        <webidl>             attribute DOMString?      xmlVersion setraises(<ref>DOMException</ref>);</webidl>
        <Type type="DOMString" nullable="nullable"/>
        <SetRaises>
          <RaiseException name="DOMException"/>
        </SetRaises>
      </Attribute>
      <Attribute name="strictErrorChecking" id="::dom::Document::strictErrorChecking">
        <webidl>             attribute boolean         strictErrorChecking;</webidl>
        <Type type="boolean"/>
      </Attribute>
      <Attribute name="documentURI" id="::dom::Document::documentURI">
        <webidl>             attribute DOMString?      documentURI;</webidl>
        <Type type="DOMString" nullable="nullable"/>
      </Attribute>
      <Operation name="adoptNode" id="::dom::Document::adoptNode">
        <webidl>    <ref>Node</ref>               adoptNode(in <ref>Node</ref> source)
                                        raises(<ref>DOMException</ref>);</webidl>
        <Type name="Node"/>
        <ArgumentList>
          <Argument in="in" name="source">
            <Type name="Node"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="DOMException"/>
        </Raises>
      </Operation>
      <Attribute readonly="readonly" name="domConfig" id="::dom::Document::domConfig">
        <webidl>    readonly attribute <ref>DOMConfiguration</ref> domConfig;</webidl>
        <Type name="DOMConfiguration"/>
      </Attribute>
      <Operation name="normalizeDocument" id="::dom::Document::normalizeDocument">
        <webidl>    void               normalizeDocument();</webidl>
        <Type type="void"/>
        <ArgumentList/>
      </Operation>
      <Operation name="renameNode" id="::dom::Document::renameNode">
        <webidl>    <ref>Node</ref>               renameNode(in <ref>Node</ref> n, 
                                  in DOMString? namespaceURI, 
                                  in DOMString qualifiedName)
                                        raises(<ref>DOMException</ref>);</webidl>
        <Type name="Node"/>
        <ArgumentList>
          <Argument in="in" name="n">
            <Type name="Node"/>
          </Argument>
          <Argument in="in" name="namespaceURI">
            <Type type="DOMString" nullable="nullable"/>
          </Argument>
          <Argument in="in" name="qualifiedName">
            <Type type="DOMString"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="DOMException"/>
        </Raises>
      </Operation>
    </Interface>
  </Module>
</Definitions>
<Definitions>
  <Module name="ls" id="::ls">
    <webidl>module ls {

  typedef   <ref>Object</ref> LSInputStream;

  typedef   <ref>Object</ref> LSOutputStream;

  typedef   <ref>Object</ref> LSReader;

  typedef   <ref>Object</ref> LSWriter;

  typedef <ref>dom::DOMConfiguration</ref> DOMConfiguration;
  typedef <ref>dom::DOMException</ref> DOMException;
  typedef <ref>dom::Node</ref> Node;
  typedef <ref>dom::Document</ref> Document;
  typedef <ref>dom::Element</ref> Element;

  exception LSException {
    const unsigned short      PARSE_ERR                      = 81;
    const unsigned short      SERIALIZE_ERR                  = 82;

    unsigned short   code;
  };

  interface DOMImplementationLS {

    const unsigned short      MODE_SYNCHRONOUS               = 1;
    const unsigned short      MODE_ASYNCHRONOUS              = 2;

    <ref>LSParser</ref>           createLSParser(in unsigned short mode, 
                                      in DOMString? schemaType)
                                        raises(<ref>DOMException</ref>);
    <ref>LSSerializer</ref>       createLSSerializer();
    <ref>LSInput</ref>            createLSInput();
    <ref>LSOutput</ref>           createLSOutput();
  };

  <ref>DOMImplementation</ref> implements <ref>DOMImplementationLS</ref>;

  interface LSParser {
    readonly attribute <ref>DOMConfiguration</ref> domConfig;
             attribute <ref>LSParserFilter</ref>  filter;
    readonly attribute boolean         async;
    readonly attribute boolean         busy;
    <ref>Document</ref>           parse(in <ref>LSInput</ref> input)
                                        raises(<ref>DOMException</ref>, 
                                               <ref>LSException</ref>);
    <ref>Document</ref>           parseURI(in DOMString uri)
                                        raises(<ref>DOMException</ref>, 
                                               <ref>LSException</ref>);

    const unsigned short      ACTION_APPEND_AS_CHILDREN      = 1;
    const unsigned short      ACTION_REPLACE_CHILDREN        = 2;
    const unsigned short      ACTION_INSERT_BEFORE           = 3;
    const unsigned short      ACTION_INSERT_AFTER            = 4;
    const unsigned short      ACTION_REPLACE                 = 5;

    <ref>Node</ref>               parseWithContext(in <ref>LSInput</ref> input, 
                                        in <ref>Node</ref> contextArg, 
                                        in unsigned short action)
                                        raises(<ref>DOMException</ref>, 
                                               <ref>LSException</ref>);
    void               abort();
  };

  [Callback]
  interface LSInput {
             attribute <ref>LSReader</ref>        characterStream;
             attribute <ref>LSInputStream</ref>   byteStream;
             attribute DOMString?      stringData;
             attribute DOMString?      systemId;
             attribute DOMString?      publicId;
             attribute DOMString?      baseURI;
             attribute DOMString?      encoding;
             attribute boolean         certifiedText;
  };

  [Callback]
  interface LSResourceResolver {
    <ref>LSInput</ref>            resolveResource(in DOMString type, 
                                       in DOMString? namespaceURI, 
                                       in DOMString? publicId, 
                                       in DOMString? systemId, 
                                       in DOMString? baseURI);
  };

  [Callback]
  interface LSParserFilter {

    const short               FILTER_ACCEPT                  = 1;
    const short               FILTER_REJECT                  = 2;
    const short               FILTER_SKIP                    = 3;
    const short               FILTER_INTERRUPT               = 4;

    unsigned short     startElement(in <ref>Element</ref> elementArg);
    unsigned short     acceptNode(in <ref>Node</ref> nodeArg);
    readonly attribute unsigned long   whatToShow;
  };

  interface LSSerializer {
    readonly attribute <ref>DOMConfiguration</ref> domConfig;
             attribute DOMString?      newLine;
             attribute <ref>LSSerializerFilter</ref> filter;
    boolean            write(in <ref>Node</ref> nodeArg, 
                             in <ref>LSOutput</ref> destination)
                                        raises(<ref>LSException</ref>);
    boolean            writeToURI(in <ref>Node</ref> nodeArg, 
                                  in DOMString uri)
                                        raises(<ref>LSException</ref>);
    DOMString          writeToString(in <ref>Node</ref> nodeArg)
                                        raises(<ref>DOMException</ref>, 
                                               <ref>LSException</ref>);
  };

  [Callback]
  interface LSOutput {
             attribute <ref>LSWriter</ref>        characterStream;
             attribute <ref>LSOutputStream</ref>  byteStream;
             attribute DOMString?      systemId;
             attribute DOMString?      encoding;
  };

  interface LSProgressEvent : <ref>events::Event</ref> {
    readonly attribute <ref>LSInput</ref>         input;
    readonly attribute unsigned long   position;
    readonly attribute unsigned long   totalSize;
  };

  interface LSLoadEvent : <ref>events::Event</ref> {
    readonly attribute <ref>Document</ref>        newDocument;
    readonly attribute <ref>LSInput</ref>         input;
  };

  [Callback]
  interface LSSerializerFilter : <ref>traversal::NodeFilter</ref> {
    readonly attribute unsigned long   whatToShow;
  };
};</webidl>
    <Typedef name="LSInputStream" id="::ls::LSInputStream">
      <webidl>  typedef   <ref>Object</ref> LSInputStream;</webidl>
      <Type name="Object"/>
    </Typedef>
    <Typedef name="LSOutputStream" id="::ls::LSOutputStream">
      <webidl>  typedef   <ref>Object</ref> LSOutputStream;</webidl>
      <Type name="Object"/>
    </Typedef>
    <Typedef name="LSReader" id="::ls::LSReader">
      <webidl>  typedef   <ref>Object</ref> LSReader;</webidl>
      <Type name="Object"/>
    </Typedef>
    <Typedef name="LSWriter" id="::ls::LSWriter">
      <webidl>  typedef   <ref>Object</ref> LSWriter;</webidl>
      <Type name="Object"/>
    </Typedef>
    <Typedef name="DOMConfiguration" id="::ls::DOMConfiguration">
      <webidl>  typedef <ref>dom::DOMConfiguration</ref> DOMConfiguration;</webidl>
      <Type name="domDOMConfiguration"/>
    </Typedef>
    <Typedef name="DOMException" id="::ls::DOMException">
      <webidl>  typedef <ref>dom::DOMException</ref> DOMException;</webidl>
      <Type name="domDOMException"/>
    </Typedef>
    <Typedef name="Node" id="::ls::Node">
      <webidl>  typedef <ref>dom::Node</ref> Node;</webidl>
      <Type name="domNode"/>
    </Typedef>
    <Typedef name="Document" id="::ls::Document">
      <webidl>  typedef <ref>dom::Document</ref> Document;</webidl>
      <Type name="domDocument"/>
    </Typedef>
    <Typedef name="Element" id="::ls::Element">
      <webidl>  typedef <ref>dom::Element</ref> Element;</webidl>
      <Type name="domElement"/>
    </Typedef>
    <Exception name="LSException" id="::ls::LSException">
      <webidl>  exception LSException {
    const unsigned short      PARSE_ERR                      = 81;
    const unsigned short      SERIALIZE_ERR                  = 82;

    unsigned short   code;
  };</webidl>
      <Const name="PARSE_ERR" value="81" id="::ls::LSException::PARSE_ERR">
        <Type type="unsigned short"/>
      </Const>
      <Const name="SERIALIZE_ERR" value="82" id="::ls::LSException::SERIALIZE_ERR">
        <Type type="unsigned short"/>
      </Const>
      <ExceptionField name="code" id="::ls::LSException::code">
        <Type type="unsigned short"/>
      </ExceptionField>
    </Exception>
    <Interface name="DOMImplementationLS" id="::ls::DOMImplementationLS">
      <webidl>  interface DOMImplementationLS {

    const unsigned short      MODE_SYNCHRONOUS               = 1;
    const unsigned short      MODE_ASYNCHRONOUS              = 2;

    <ref>LSParser</ref>           createLSParser(in unsigned short mode, 
                                      in DOMString? schemaType)
                                        raises(<ref>DOMException</ref>);
    <ref>LSSerializer</ref>       createLSSerializer();
    <ref>LSInput</ref>            createLSInput();
    <ref>LSOutput</ref>           createLSOutput();
  };</webidl>
      <Const name="MODE_SYNCHRONOUS" value="1" id="::ls::DOMImplementationLS::MODE_SYNCHRONOUS">
        <webidl>    const unsigned short      MODE_SYNCHRONOUS               = 1;</webidl>
        <Type type="unsigned short"/>
      </Const>
      <Const name="MODE_ASYNCHRONOUS" value="2" id="::ls::DOMImplementationLS::MODE_ASYNCHRONOUS">
        <webidl>    const unsigned short      MODE_ASYNCHRONOUS              = 2;</webidl>
        <Type type="unsigned short"/>
      </Const>
      <Operation name="createLSParser" id="::ls::DOMImplementationLS::createLSParser">
        <webidl>    <ref>LSParser</ref>           createLSParser(in unsigned short mode, 
                                      in DOMString? schemaType)
                                        raises(<ref>DOMException</ref>);</webidl>
        <Type name="LSParser"/>
        <ArgumentList>
          <Argument in="in" name="mode">
            <Type type="unsigned short"/>
          </Argument>
          <Argument in="in" name="schemaType">
            <Type type="DOMString" nullable="nullable"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="DOMException"/>
        </Raises>
      </Operation>
      <Operation name="createLSSerializer" id="::ls::DOMImplementationLS::createLSSerializer">
        <webidl>    <ref>LSSerializer</ref>       createLSSerializer();</webidl>
        <Type name="LSSerializer"/>
        <ArgumentList/>
      </Operation>
      <Operation name="createLSInput" id="::ls::DOMImplementationLS::createLSInput">
        <webidl>    <ref>LSInput</ref>            createLSInput();</webidl>
        <Type name="LSInput"/>
        <ArgumentList/>
      </Operation>
      <Operation name="createLSOutput" id="::ls::DOMImplementationLS::createLSOutput">
        <webidl>    <ref>LSOutput</ref>           createLSOutput();</webidl>
        <Type name="LSOutput"/>
        <ArgumentList/>
      </Operation>
    </Interface>
    <Implements name1="DOMImplementation" name2="DOMImplementationLS">
      <webidl>  <ref>DOMImplementation</ref> implements <ref>DOMImplementationLS</ref>;</webidl>
    </Implements>
    <Interface name="LSParser" id="::ls::LSParser">
      <webidl>  interface LSParser {
    readonly attribute <ref>DOMConfiguration</ref> domConfig;
             attribute <ref>LSParserFilter</ref>  filter;
    readonly attribute boolean         async;
    readonly attribute boolean         busy;
    <ref>Document</ref>           parse(in <ref>LSInput</ref> input)
                                        raises(<ref>DOMException</ref>, 
                                               <ref>LSException</ref>);
    <ref>Document</ref>           parseURI(in DOMString uri)
                                        raises(<ref>DOMException</ref>, 
                                               <ref>LSException</ref>);

    const unsigned short      ACTION_APPEND_AS_CHILDREN      = 1;
    const unsigned short      ACTION_REPLACE_CHILDREN        = 2;
    const unsigned short      ACTION_INSERT_BEFORE           = 3;
    const unsigned short      ACTION_INSERT_AFTER            = 4;
    const unsigned short      ACTION_REPLACE                 = 5;

    <ref>Node</ref>               parseWithContext(in <ref>LSInput</ref> input, 
                                        in <ref>Node</ref> contextArg, 
                                        in unsigned short action)
                                        raises(<ref>DOMException</ref>, 
                                               <ref>LSException</ref>);
    void               abort();
  };</webidl>
      <Attribute readonly="readonly" name="domConfig" id="::ls::LSParser::domConfig">
        <webidl>    readonly attribute <ref>DOMConfiguration</ref> domConfig;</webidl>
        <Type name="DOMConfiguration"/>
      </Attribute>
      <Attribute name="filter" id="::ls::LSParser::filter">
        <webidl>             attribute <ref>LSParserFilter</ref>  filter;</webidl>
        <Type name="LSParserFilter"/>
      </Attribute>
      <Attribute readonly="readonly" name="async" id="::ls::LSParser::async">
        <webidl>    readonly attribute boolean         async;</webidl>
        <Type type="boolean"/>
      </Attribute>
      <Attribute readonly="readonly" name="busy" id="::ls::LSParser::busy">
        <webidl>    readonly attribute boolean         busy;</webidl>
        <Type type="boolean"/>
      </Attribute>
      <Operation name="parse" id="::ls::LSParser::parse">
        <webidl>    <ref>Document</ref>           parse(in <ref>LSInput</ref> input)
                                        raises(<ref>DOMException</ref>, 
                                               <ref>LSException</ref>);</webidl>
        <Type name="Document"/>
        <ArgumentList>
          <Argument in="in" name="input">
            <Type name="LSInput"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="DOMException"/>
          <RaiseException name="LSException"/>
        </Raises>
      </Operation>
      <Operation name="parseURI" id="::ls::LSParser::parseURI">
        <webidl>    <ref>Document</ref>           parseURI(in DOMString uri)
                                        raises(<ref>DOMException</ref>, 
                                               <ref>LSException</ref>);</webidl>
        <Type name="Document"/>
        <ArgumentList>
          <Argument in="in" name="uri">
            <Type type="DOMString"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="DOMException"/>
          <RaiseException name="LSException"/>
        </Raises>
      </Operation>
      <Const name="ACTION_APPEND_AS_CHILDREN" value="1" id="::ls::LSParser::ACTION_APPEND_AS_CHILDREN">
        <webidl>    const unsigned short      ACTION_APPEND_AS_CHILDREN      = 1;</webidl>
        <Type type="unsigned short"/>
      </Const>
      <Const name="ACTION_REPLACE_CHILDREN" value="2" id="::ls::LSParser::ACTION_REPLACE_CHILDREN">
        <webidl>    const unsigned short      ACTION_REPLACE_CHILDREN        = 2;</webidl>
        <Type type="unsigned short"/>
      </Const>
      <Const name="ACTION_INSERT_BEFORE" value="3" id="::ls::LSParser::ACTION_INSERT_BEFORE">
        <webidl>    const unsigned short      ACTION_INSERT_BEFORE           = 3;</webidl>
        <Type type="unsigned short"/>
      </Const>
      <Const name="ACTION_INSERT_AFTER" value="4" id="::ls::LSParser::ACTION_INSERT_AFTER">
        <webidl>    const unsigned short      ACTION_INSERT_AFTER            = 4;</webidl>
        <Type type="unsigned short"/>
      </Const>
      <Const name="ACTION_REPLACE" value="5" id="::ls::LSParser::ACTION_REPLACE">
        <webidl>    const unsigned short      ACTION_REPLACE                 = 5;</webidl>
        <Type type="unsigned short"/>
      </Const>
      <Operation name="parseWithContext" id="::ls::LSParser::parseWithContext">
        <webidl>    <ref>Node</ref>               parseWithContext(in <ref>LSInput</ref> input, 
                                        in <ref>Node</ref> contextArg, 
                                        in unsigned short action)
                                        raises(<ref>DOMException</ref>, 
                                               <ref>LSException</ref>);</webidl>
        <Type name="Node"/>
        <ArgumentList>
          <Argument in="in" name="input">
            <Type name="LSInput"/>
          </Argument>
          <Argument in="in" name="contextArg">
            <Type name="Node"/>
          </Argument>
          <Argument in="in" name="action">
            <Type type="unsigned short"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="DOMException"/>
          <RaiseException name="LSException"/>
        </Raises>
      </Operation>
      <Operation name="abort" id="::ls::LSParser::abort">
        <webidl>    void               abort();</webidl>
        <Type type="void"/>
        <ArgumentList/>
      </Operation>
    </Interface>
    <Interface name="LSInput" id="::ls::LSInput">
      <webidl>  [Callback]
  interface LSInput {
             attribute <ref>LSReader</ref>        characterStream;
             attribute <ref>LSInputStream</ref>   byteStream;
             attribute DOMString?      stringData;
             attribute DOMString?      systemId;
             attribute DOMString?      publicId;
             attribute DOMString?      baseURI;
             attribute DOMString?      encoding;
             attribute boolean         certifiedText;
  };</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="Callback"/>
      </ExtendedAttributeList>
      <Attribute name="characterStream" id="::ls::LSInput::characterStream">
        <webidl>             attribute <ref>LSReader</ref>        characterStream;</webidl>
        <Type name="LSReader"/>
      </Attribute>
      <Attribute name="byteStream" id="::ls::LSInput::byteStream">
        <webidl>             attribute <ref>LSInputStream</ref>   byteStream;</webidl>
        <Type name="LSInputStream"/>
      </Attribute>
      <Attribute name="stringData" id="::ls::LSInput::stringData">
        <webidl>             attribute DOMString?      stringData;</webidl>
        <Type type="DOMString" nullable="nullable"/>
      </Attribute>
      <Attribute name="systemId" id="::ls::LSInput::systemId">
        <webidl>             attribute DOMString?      systemId;</webidl>
        <Type type="DOMString" nullable="nullable"/>
      </Attribute>
      <Attribute name="publicId" id="::ls::LSInput::publicId">
        <webidl>             attribute DOMString?      publicId;</webidl>
        <Type type="DOMString" nullable="nullable"/>
      </Attribute>
      <Attribute name="baseURI" id="::ls::LSInput::baseURI">
        <webidl>             attribute DOMString?      baseURI;</webidl>
        <Type type="DOMString" nullable="nullable"/>
      </Attribute>
      <Attribute name="encoding" id="::ls::LSInput::encoding">
        <webidl>             attribute DOMString?      encoding;</webidl>
        <Type type="DOMString" nullable="nullable"/>
      </Attribute>
      <Attribute name="certifiedText" id="::ls::LSInput::certifiedText">
        <webidl>             attribute boolean         certifiedText;</webidl>
        <Type type="boolean"/>
      </Attribute>
    </Interface>
    <Interface name="LSResourceResolver" id="::ls::LSResourceResolver">
      <webidl>  [Callback]
  interface LSResourceResolver {
    <ref>LSInput</ref>            resolveResource(in DOMString type, 
                                       in DOMString? namespaceURI, 
                                       in DOMString? publicId, 
                                       in DOMString? systemId, 
                                       in DOMString? baseURI);
  };</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="Callback"/>
      </ExtendedAttributeList>
      <Operation name="resolveResource" id="::ls::LSResourceResolver::resolveResource">
        <webidl>    <ref>LSInput</ref>            resolveResource(in DOMString type, 
                                       in DOMString? namespaceURI, 
                                       in DOMString? publicId, 
                                       in DOMString? systemId, 
                                       in DOMString? baseURI);</webidl>
        <Type name="LSInput"/>
        <ArgumentList>
          <Argument in="in" name="type">
            <Type type="DOMString"/>
          </Argument>
          <Argument in="in" name="namespaceURI">
            <Type type="DOMString" nullable="nullable"/>
          </Argument>
          <Argument in="in" name="publicId">
            <Type type="DOMString" nullable="nullable"/>
          </Argument>
          <Argument in="in" name="systemId">
            <Type type="DOMString" nullable="nullable"/>
          </Argument>
          <Argument in="in" name="baseURI">
            <Type type="DOMString" nullable="nullable"/>
          </Argument>
        </ArgumentList>
      </Operation>
    </Interface>
    <Interface name="LSParserFilter" id="::ls::LSParserFilter">
      <webidl>  [Callback]
  interface LSParserFilter {

    const short               FILTER_ACCEPT                  = 1;
    const short               FILTER_REJECT                  = 2;
    const short               FILTER_SKIP                    = 3;
    const short               FILTER_INTERRUPT               = 4;

    unsigned short     startElement(in <ref>Element</ref> elementArg);
    unsigned short     acceptNode(in <ref>Node</ref> nodeArg);
    readonly attribute unsigned long   whatToShow;
  };</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="Callback"/>
      </ExtendedAttributeList>
      <Const name="FILTER_ACCEPT" value="1" id="::ls::LSParserFilter::FILTER_ACCEPT">
        <webidl>    const short               FILTER_ACCEPT                  = 1;</webidl>
        <Type type="short"/>
      </Const>
      <Const name="FILTER_REJECT" value="2" id="::ls::LSParserFilter::FILTER_REJECT">
        <webidl>    const short               FILTER_REJECT                  = 2;</webidl>
        <Type type="short"/>
      </Const>
      <Const name="FILTER_SKIP" value="3" id="::ls::LSParserFilter::FILTER_SKIP">
        <webidl>    const short               FILTER_SKIP                    = 3;</webidl>
        <Type type="short"/>
      </Const>
      <Const name="FILTER_INTERRUPT" value="4" id="::ls::LSParserFilter::FILTER_INTERRUPT">
        <webidl>    const short               FILTER_INTERRUPT               = 4;</webidl>
        <Type type="short"/>
      </Const>
      <Operation name="startElement" id="::ls::LSParserFilter::startElement">
        <webidl>    unsigned short     startElement(in <ref>Element</ref> elementArg);</webidl>
        <Type type="unsigned short"/>
        <ArgumentList>
          <Argument in="in" name="elementArg">
            <Type name="Element"/>
          </Argument>
        </ArgumentList>
      </Operation>
      <Operation name="acceptNode" id="::ls::LSParserFilter::acceptNode">
        <webidl>    unsigned short     acceptNode(in <ref>Node</ref> nodeArg);</webidl>
        <Type type="unsigned short"/>
        <ArgumentList>
          <Argument in="in" name="nodeArg">
            <Type name="Node"/>
          </Argument>
        </ArgumentList>
      </Operation>
      <Attribute readonly="readonly" name="whatToShow" id="::ls::LSParserFilter::whatToShow">
        <webidl>    readonly attribute unsigned long   whatToShow;</webidl>
        <Type type="unsigned long"/>
      </Attribute>
    </Interface>
    <Interface name="LSSerializer" id="::ls::LSSerializer">
      <webidl>  interface LSSerializer {
    readonly attribute <ref>DOMConfiguration</ref> domConfig;
             attribute DOMString?      newLine;
             attribute <ref>LSSerializerFilter</ref> filter;
    boolean            write(in <ref>Node</ref> nodeArg, 
                             in <ref>LSOutput</ref> destination)
                                        raises(<ref>LSException</ref>);
    boolean            writeToURI(in <ref>Node</ref> nodeArg, 
                                  in DOMString uri)
                                        raises(<ref>LSException</ref>);
    DOMString          writeToString(in <ref>Node</ref> nodeArg)
                                        raises(<ref>DOMException</ref>, 
                                               <ref>LSException</ref>);
  };</webidl>
      <Attribute readonly="readonly" name="domConfig" id="::ls::LSSerializer::domConfig">
        <webidl>    readonly attribute <ref>DOMConfiguration</ref> domConfig;</webidl>
        <Type name="DOMConfiguration"/>
      </Attribute>
      <Attribute name="newLine" id="::ls::LSSerializer::newLine">
        <webidl>             attribute DOMString?      newLine;</webidl>
        <Type type="DOMString" nullable="nullable"/>
      </Attribute>
      <Attribute name="filter" id="::ls::LSSerializer::filter">
        <webidl>             attribute <ref>LSSerializerFilter</ref> filter;</webidl>
        <Type name="LSSerializerFilter"/>
      </Attribute>
      <Operation name="write" id="::ls::LSSerializer::write">
        <webidl>    boolean            write(in <ref>Node</ref> nodeArg, 
                             in <ref>LSOutput</ref> destination)
                                        raises(<ref>LSException</ref>);</webidl>
        <Type type="boolean"/>
        <ArgumentList>
          <Argument in="in" name="nodeArg">
            <Type name="Node"/>
          </Argument>
          <Argument in="in" name="destination">
            <Type name="LSOutput"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="LSException"/>
        </Raises>
      </Operation>
      <Operation name="writeToURI" id="::ls::LSSerializer::writeToURI">
        <webidl>    boolean            writeToURI(in <ref>Node</ref> nodeArg, 
                                  in DOMString uri)
                                        raises(<ref>LSException</ref>);</webidl>
        <Type type="boolean"/>
        <ArgumentList>
          <Argument in="in" name="nodeArg">
            <Type name="Node"/>
          </Argument>
          <Argument in="in" name="uri">
            <Type type="DOMString"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="LSException"/>
        </Raises>
      </Operation>
      <Operation name="writeToString" id="::ls::LSSerializer::writeToString">
        <webidl>    DOMString          writeToString(in <ref>Node</ref> nodeArg)
                                        raises(<ref>DOMException</ref>, 
                                               <ref>LSException</ref>);</webidl>
        <Type type="DOMString"/>
        <ArgumentList>
          <Argument in="in" name="nodeArg">
            <Type name="Node"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="DOMException"/>
          <RaiseException name="LSException"/>
        </Raises>
      </Operation>
    </Interface>
    <Interface name="LSOutput" id="::ls::LSOutput">
      <webidl>  [Callback]
  interface LSOutput {
             attribute <ref>LSWriter</ref>        characterStream;
             attribute <ref>LSOutputStream</ref>  byteStream;
             attribute DOMString?      systemId;
             attribute DOMString?      encoding;
  };</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="Callback"/>
      </ExtendedAttributeList>
      <Attribute name="characterStream" id="::ls::LSOutput::characterStream">
        <webidl>             attribute <ref>LSWriter</ref>        characterStream;</webidl>
        <Type name="LSWriter"/>
      </Attribute>
      <Attribute name="byteStream" id="::ls::LSOutput::byteStream">
        <webidl>             attribute <ref>LSOutputStream</ref>  byteStream;</webidl>
        <Type name="LSOutputStream"/>
      </Attribute>
      <Attribute name="systemId" id="::ls::LSOutput::systemId">
        <webidl>             attribute DOMString?      systemId;</webidl>
        <Type type="DOMString" nullable="nullable"/>
      </Attribute>
      <Attribute name="encoding" id="::ls::LSOutput::encoding">
        <webidl>             attribute DOMString?      encoding;</webidl>
        <Type type="DOMString" nullable="nullable"/>
      </Attribute>
    </Interface>
    <Interface name="LSProgressEvent" id="::ls::LSProgressEvent">
      <webidl>  interface LSProgressEvent : <ref>events::Event</ref> {
    readonly attribute <ref>LSInput</ref>         input;
    readonly attribute unsigned long   position;
    readonly attribute unsigned long   totalSize;
  };</webidl>
      <InterfaceInheritance>
        <Name name="eventsEvent"/>
      </InterfaceInheritance>
      <Attribute readonly="readonly" name="input" id="::ls::LSProgressEvent::input">
        <webidl>    readonly attribute <ref>LSInput</ref>         input;</webidl>
        <Type name="LSInput"/>
      </Attribute>
      <Attribute readonly="readonly" name="position" id="::ls::LSProgressEvent::position">
        <webidl>    readonly attribute unsigned long   position;</webidl>
        <Type type="unsigned long"/>
      </Attribute>
      <Attribute readonly="readonly" name="totalSize" id="::ls::LSProgressEvent::totalSize">
        <webidl>    readonly attribute unsigned long   totalSize;</webidl>
        <Type type="unsigned long"/>
      </Attribute>
    </Interface>
    <Interface name="LSLoadEvent" id="::ls::LSLoadEvent">
      <webidl>  interface LSLoadEvent : <ref>events::Event</ref> {
    readonly attribute <ref>Document</ref>        newDocument;
    readonly attribute <ref>LSInput</ref>         input;
  };</webidl>
      <InterfaceInheritance>
        <Name name="eventsEvent"/>
      </InterfaceInheritance>
      <Attribute readonly="readonly" name="newDocument" id="::ls::LSLoadEvent::newDocument">
        <webidl>    readonly attribute <ref>Document</ref>        newDocument;</webidl>
        <Type name="Document"/>
      </Attribute>
      <Attribute readonly="readonly" name="input" id="::ls::LSLoadEvent::input">
        <webidl>    readonly attribute <ref>LSInput</ref>         input;</webidl>
        <Type name="LSInput"/>
      </Attribute>
    </Interface>
    <Interface name="LSSerializerFilter" id="::ls::LSSerializerFilter">
      <webidl>  [Callback]
  interface LSSerializerFilter : <ref>traversal::NodeFilter</ref> {
    readonly attribute unsigned long   whatToShow;
  };</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="Callback"/>
      </ExtendedAttributeList>
      <InterfaceInheritance>
        <Name name="traversalNodeFilter"/>
      </InterfaceInheritance>
      <Attribute readonly="readonly" name="whatToShow" id="::ls::LSSerializerFilter::whatToShow">
        <webidl>    readonly attribute unsigned long   whatToShow;</webidl>
        <Type type="unsigned long"/>
      </Attribute>
    </Interface>
  </Module>
</Definitions>
<Definitions>
  <Module name="validation" id="::validation">
    <webidl>module validation {

  typedef <ref>dom::DOMStringList</ref> DOMStringList;
  typedef <ref>dom::Node</ref> Node;
  typedef <ref>dom::NameList</ref> NameList;
  typedef <ref>dom::Attr</ref> Attr;
  typedef <ref>dom::DOMConfiguration</ref> DOMConfiguration;
  typedef <ref>dom::DOMException</ref> DOMException;

  exception ExceptionVAL {
    const unsigned short      NO_SCHEMA_AVAILABLE_ERR        = 71;

    unsigned short   code;
  };

  [PrototypeRoot]
  interface NodeEditVAL {

    const unsigned short      VAL_WF                         = 1;
    const unsigned short      VAL_NS_WF                      = 2;
    const unsigned short      VAL_INCOMPLETE                 = 3;
    const unsigned short      VAL_SCHEMA                     = 4;


    const unsigned short      VAL_TRUE                       = 5;
    const unsigned short      VAL_FALSE                      = 6;
    const unsigned short      VAL_UNKNOWN                    = 7;

    readonly attribute DOMString?      defaultValue;
    readonly attribute <ref>DOMStringList</ref>   enumeratedValues;
    unsigned short     canInsertBefore(in <ref>Node</ref> newChild, 
                                       in <ref>Node</ref> refChild);
    unsigned short     canRemoveChild(in <ref>Node</ref> oldChild);
    unsigned short     canReplaceChild(in <ref>Node</ref> newChild, 
                                       in <ref>Node</ref> oldChild);
    unsigned short     canAppendChild(in <ref>Node</ref> newChild);
    unsigned short     nodeValidity(in unsigned short valType);
  };

  interface ElementEditVAL : <ref>NodeEditVAL</ref> {

    const unsigned short      VAL_EMPTY_CONTENTTYPE          = 1;
    const unsigned short      VAL_ANY_CONTENTTYPE            = 2;
    const unsigned short      VAL_MIXED_CONTENTTYPE          = 3;
    const unsigned short      VAL_ELEMENTS_CONTENTTYPE       = 4;
    const unsigned short      VAL_SIMPLE_CONTENTTYPE         = 5;

    readonly attribute <ref>NameList</ref>        allowedChildren;
    readonly attribute <ref>NameList</ref>        allowedFirstChildren;
    readonly attribute <ref>NameList</ref>        allowedParents;
    readonly attribute <ref>NameList</ref>        allowedNextSiblings;
    readonly attribute <ref>NameList</ref>        allowedPreviousSiblings;
    readonly attribute <ref>NameList</ref>        allowedAttributes;
    readonly attribute <ref>NameList</ref>        requiredAttributes;
    readonly attribute unsigned short  contentType;
    unsigned short     canSetTextContent(in DOMString? possibleTextContent);
    unsigned short     canSetAttribute(in DOMString attrname, 
                                       in DOMString attrval);
    unsigned short     canSetAttributeNode(in <ref>Attr</ref> attrNode);
    unsigned short     canSetAttributeNS(in DOMString? namespaceURI, 
                                         in DOMString qualifiedName, 
                                         in DOMString value);
    unsigned short     canRemoveAttribute(in DOMString attrname);
    unsigned short     canRemoveAttributeNS(in DOMString? namespaceURI, 
                                            in DOMString localName);
    unsigned short     canRemoveAttributeNode(in <ref>Node</ref> attrNode);
    unsigned short     isElementDefined(in DOMString name);
    unsigned short     isElementDefinedNS(in DOMString? namespaceURI, 
                                          in DOMString name);
  };

  interface CharacterDataEditVAL : <ref>NodeEditVAL</ref> {
    unsigned short     isWhitespaceOnly();
    unsigned short     canSetData(in DOMString arg);
    unsigned short     canAppendData(in DOMString arg);
    unsigned short     canReplaceData(in unsigned long offset, 
                                      in unsigned long count, 
                                      in DOMString arg)
                                        raises(<ref>DOMException</ref>);
    unsigned short     canInsertData(in unsigned long offset, 
                                     in DOMString arg)
                                        raises(<ref>DOMException</ref>);
    unsigned short     canDeleteData(in unsigned long offset, 
                                     in unsigned long count)
                                        raises(<ref>DOMException</ref>);
  };

  interface DocumentEditVAL : <ref>NodeEditVAL</ref> {
             attribute boolean         continuousValidityChecking setraises(<ref>DOMException</ref>, <ref>ExceptionVAL</ref>);

    readonly attribute <ref>DOMConfiguration</ref> domConfig;
    <ref>NameList</ref>           getDefinedElements(in DOMString? namespaceURI);
    unsigned short     validateDocument();
  };
};</webidl>
    <Typedef name="DOMStringList" id="::validation::DOMStringList">
      <webidl>  typedef <ref>dom::DOMStringList</ref> DOMStringList;</webidl>
      <Type name="domDOMStringList"/>
    </Typedef>
    <Typedef name="Node" id="::validation::Node">
      <webidl>  typedef <ref>dom::Node</ref> Node;</webidl>
      <Type name="domNode"/>
    </Typedef>
    <Typedef name="NameList" id="::validation::NameList">
      <webidl>  typedef <ref>dom::NameList</ref> NameList;</webidl>
      <Type name="domNameList"/>
    </Typedef>
    <Typedef name="Attr" id="::validation::Attr">
      <webidl>  typedef <ref>dom::Attr</ref> Attr;</webidl>
      <Type name="domAttr"/>
    </Typedef>
    <Typedef name="DOMConfiguration" id="::validation::DOMConfiguration">
      <webidl>  typedef <ref>dom::DOMConfiguration</ref> DOMConfiguration;</webidl>
      <Type name="domDOMConfiguration"/>
    </Typedef>
    <Typedef name="DOMException" id="::validation::DOMException">
      <webidl>  typedef <ref>dom::DOMException</ref> DOMException;</webidl>
      <Type name="domDOMException"/>
    </Typedef>
    <Exception name="ExceptionVAL" id="::validation::ExceptionVAL">
      <webidl>  exception ExceptionVAL {
    const unsigned short      NO_SCHEMA_AVAILABLE_ERR        = 71;

    unsigned short   code;
  };</webidl>
      <Const name="NO_SCHEMA_AVAILABLE_ERR" value="71" id="::validation::ExceptionVAL::NO_SCHEMA_AVAILABLE_ERR">
        <Type type="unsigned short"/>
      </Const>
      <ExceptionField name="code" id="::validation::ExceptionVAL::code">
        <Type type="unsigned short"/>
      </ExceptionField>
    </Exception>
    <Interface name="NodeEditVAL" id="::validation::NodeEditVAL">
      <webidl>  [PrototypeRoot]
  interface NodeEditVAL {

    const unsigned short      VAL_WF                         = 1;
    const unsigned short      VAL_NS_WF                      = 2;
    const unsigned short      VAL_INCOMPLETE                 = 3;
    const unsigned short      VAL_SCHEMA                     = 4;


    const unsigned short      VAL_TRUE                       = 5;
    const unsigned short      VAL_FALSE                      = 6;
    const unsigned short      VAL_UNKNOWN                    = 7;

    readonly attribute DOMString?      defaultValue;
    readonly attribute <ref>DOMStringList</ref>   enumeratedValues;
    unsigned short     canInsertBefore(in <ref>Node</ref> newChild, 
                                       in <ref>Node</ref> refChild);
    unsigned short     canRemoveChild(in <ref>Node</ref> oldChild);
    unsigned short     canReplaceChild(in <ref>Node</ref> newChild, 
                                       in <ref>Node</ref> oldChild);
    unsigned short     canAppendChild(in <ref>Node</ref> newChild);
    unsigned short     nodeValidity(in unsigned short valType);
  };</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="PrototypeRoot"/>
      </ExtendedAttributeList>
      <Const name="VAL_WF" value="1" id="::validation::NodeEditVAL::VAL_WF">
        <webidl>    const unsigned short      VAL_WF                         = 1;</webidl>
        <Type type="unsigned short"/>
      </Const>
      <Const name="VAL_NS_WF" value="2" id="::validation::NodeEditVAL::VAL_NS_WF">
        <webidl>    const unsigned short      VAL_NS_WF                      = 2;</webidl>
        <Type type="unsigned short"/>
      </Const>
      <Const name="VAL_INCOMPLETE" value="3" id="::validation::NodeEditVAL::VAL_INCOMPLETE">
        <webidl>    const unsigned short      VAL_INCOMPLETE                 = 3;</webidl>
        <Type type="unsigned short"/>
      </Const>
      <Const name="VAL_SCHEMA" value="4" id="::validation::NodeEditVAL::VAL_SCHEMA">
        <webidl>    const unsigned short      VAL_SCHEMA                     = 4;</webidl>
        <Type type="unsigned short"/>
      </Const>
      <Const name="VAL_TRUE" value="5" id="::validation::NodeEditVAL::VAL_TRUE">
        <webidl>    const unsigned short      VAL_TRUE                       = 5;</webidl>
        <Type type="unsigned short"/>
      </Const>
      <Const name="VAL_FALSE" value="6" id="::validation::NodeEditVAL::VAL_FALSE">
        <webidl>    const unsigned short      VAL_FALSE                      = 6;</webidl>
        <Type type="unsigned short"/>
      </Const>
      <Const name="VAL_UNKNOWN" value="7" id="::validation::NodeEditVAL::VAL_UNKNOWN">
        <webidl>    const unsigned short      VAL_UNKNOWN                    = 7;</webidl>
        <Type type="unsigned short"/>
      </Const>
      <Attribute readonly="readonly" name="defaultValue" id="::validation::NodeEditVAL::defaultValue">
        <webidl>    readonly attribute DOMString?      defaultValue;</webidl>
        <Type type="DOMString" nullable="nullable"/>
      </Attribute>
      <Attribute readonly="readonly" name="enumeratedValues" id="::validation::NodeEditVAL::enumeratedValues">
        <webidl>    readonly attribute <ref>DOMStringList</ref>   enumeratedValues;</webidl>
        <Type name="DOMStringList"/>
      </Attribute>
      <Operation name="canInsertBefore" id="::validation::NodeEditVAL::canInsertBefore">
        <webidl>    unsigned short     canInsertBefore(in <ref>Node</ref> newChild, 
                                       in <ref>Node</ref> refChild);</webidl>
        <Type type="unsigned short"/>
        <ArgumentList>
          <Argument in="in" name="newChild">
            <Type name="Node"/>
          </Argument>
          <Argument in="in" name="refChild">
            <Type name="Node"/>
          </Argument>
        </ArgumentList>
      </Operation>
      <Operation name="canRemoveChild" id="::validation::NodeEditVAL::canRemoveChild">
        <webidl>    unsigned short     canRemoveChild(in <ref>Node</ref> oldChild);</webidl>
        <Type type="unsigned short"/>
        <ArgumentList>
          <Argument in="in" name="oldChild">
            <Type name="Node"/>
          </Argument>
        </ArgumentList>
      </Operation>
      <Operation name="canReplaceChild" id="::validation::NodeEditVAL::canReplaceChild">
        <webidl>    unsigned short     canReplaceChild(in <ref>Node</ref> newChild, 
                                       in <ref>Node</ref> oldChild);</webidl>
        <Type type="unsigned short"/>
        <ArgumentList>
          <Argument in="in" name="newChild">
            <Type name="Node"/>
          </Argument>
          <Argument in="in" name="oldChild">
            <Type name="Node"/>
          </Argument>
        </ArgumentList>
      </Operation>
      <Operation name="canAppendChild" id="::validation::NodeEditVAL::canAppendChild">
        <webidl>    unsigned short     canAppendChild(in <ref>Node</ref> newChild);</webidl>
        <Type type="unsigned short"/>
        <ArgumentList>
          <Argument in="in" name="newChild">
            <Type name="Node"/>
          </Argument>
        </ArgumentList>
      </Operation>
      <Operation name="nodeValidity" id="::validation::NodeEditVAL::nodeValidity">
        <webidl>    unsigned short     nodeValidity(in unsigned short valType);</webidl>
        <Type type="unsigned short"/>
        <ArgumentList>
          <Argument in="in" name="valType">
            <Type type="unsigned short"/>
          </Argument>
        </ArgumentList>
      </Operation>
    </Interface>
    <Interface name="ElementEditVAL" id="::validation::ElementEditVAL">
      <webidl>  interface ElementEditVAL : <ref>NodeEditVAL</ref> {

    const unsigned short      VAL_EMPTY_CONTENTTYPE          = 1;
    const unsigned short      VAL_ANY_CONTENTTYPE            = 2;
    const unsigned short      VAL_MIXED_CONTENTTYPE          = 3;
    const unsigned short      VAL_ELEMENTS_CONTENTTYPE       = 4;
    const unsigned short      VAL_SIMPLE_CONTENTTYPE         = 5;

    readonly attribute <ref>NameList</ref>        allowedChildren;
    readonly attribute <ref>NameList</ref>        allowedFirstChildren;
    readonly attribute <ref>NameList</ref>        allowedParents;
    readonly attribute <ref>NameList</ref>        allowedNextSiblings;
    readonly attribute <ref>NameList</ref>        allowedPreviousSiblings;
    readonly attribute <ref>NameList</ref>        allowedAttributes;
    readonly attribute <ref>NameList</ref>        requiredAttributes;
    readonly attribute unsigned short  contentType;
    unsigned short     canSetTextContent(in DOMString? possibleTextContent);
    unsigned short     canSetAttribute(in DOMString attrname, 
                                       in DOMString attrval);
    unsigned short     canSetAttributeNode(in <ref>Attr</ref> attrNode);
    unsigned short     canSetAttributeNS(in DOMString? namespaceURI, 
                                         in DOMString qualifiedName, 
                                         in DOMString value);
    unsigned short     canRemoveAttribute(in DOMString attrname);
    unsigned short     canRemoveAttributeNS(in DOMString? namespaceURI, 
                                            in DOMString localName);
    unsigned short     canRemoveAttributeNode(in <ref>Node</ref> attrNode);
    unsigned short     isElementDefined(in DOMString name);
    unsigned short     isElementDefinedNS(in DOMString? namespaceURI, 
                                          in DOMString name);
  };</webidl>
      <InterfaceInheritance>
        <Name name="NodeEditVAL"/>
      </InterfaceInheritance>
      <Const name="VAL_EMPTY_CONTENTTYPE" value="1" id="::validation::ElementEditVAL::VAL_EMPTY_CONTENTTYPE">
        <webidl>    const unsigned short      VAL_EMPTY_CONTENTTYPE          = 1;</webidl>
        <Type type="unsigned short"/>
      </Const>
      <Const name="VAL_ANY_CONTENTTYPE" value="2" id="::validation::ElementEditVAL::VAL_ANY_CONTENTTYPE">
        <webidl>    const unsigned short      VAL_ANY_CONTENTTYPE            = 2;</webidl>
        <Type type="unsigned short"/>
      </Const>
      <Const name="VAL_MIXED_CONTENTTYPE" value="3" id="::validation::ElementEditVAL::VAL_MIXED_CONTENTTYPE">
        <webidl>    const unsigned short      VAL_MIXED_CONTENTTYPE          = 3;</webidl>
        <Type type="unsigned short"/>
      </Const>
      <Const name="VAL_ELEMENTS_CONTENTTYPE" value="4" id="::validation::ElementEditVAL::VAL_ELEMENTS_CONTENTTYPE">
        <webidl>    const unsigned short      VAL_ELEMENTS_CONTENTTYPE       = 4;</webidl>
        <Type type="unsigned short"/>
      </Const>
      <Const name="VAL_SIMPLE_CONTENTTYPE" value="5" id="::validation::ElementEditVAL::VAL_SIMPLE_CONTENTTYPE">
        <webidl>    const unsigned short      VAL_SIMPLE_CONTENTTYPE         = 5;</webidl>
        <Type type="unsigned short"/>
      </Const>
      <Attribute readonly="readonly" name="allowedChildren" id="::validation::ElementEditVAL::allowedChildren">
        <webidl>    readonly attribute <ref>NameList</ref>        allowedChildren;</webidl>
        <Type name="NameList"/>
      </Attribute>
      <Attribute readonly="readonly" name="allowedFirstChildren" id="::validation::ElementEditVAL::allowedFirstChildren">
        <webidl>    readonly attribute <ref>NameList</ref>        allowedFirstChildren;</webidl>
        <Type name="NameList"/>
      </Attribute>
      <Attribute readonly="readonly" name="allowedParents" id="::validation::ElementEditVAL::allowedParents">
        <webidl>    readonly attribute <ref>NameList</ref>        allowedParents;</webidl>
        <Type name="NameList"/>
      </Attribute>
      <Attribute readonly="readonly" name="allowedNextSiblings" id="::validation::ElementEditVAL::allowedNextSiblings">
        <webidl>    readonly attribute <ref>NameList</ref>        allowedNextSiblings;</webidl>
        <Type name="NameList"/>
      </Attribute>
      <Attribute readonly="readonly" name="allowedPreviousSiblings" id="::validation::ElementEditVAL::allowedPreviousSiblings">
        <webidl>    readonly attribute <ref>NameList</ref>        allowedPreviousSiblings;</webidl>
        <Type name="NameList"/>
      </Attribute>
      <Attribute readonly="readonly" name="allowedAttributes" id="::validation::ElementEditVAL::allowedAttributes">
        <webidl>    readonly attribute <ref>NameList</ref>        allowedAttributes;</webidl>
        <Type name="NameList"/>
      </Attribute>
      <Attribute readonly="readonly" name="requiredAttributes" id="::validation::ElementEditVAL::requiredAttributes">
        <webidl>    readonly attribute <ref>NameList</ref>        requiredAttributes;</webidl>
        <Type name="NameList"/>
      </Attribute>
      <Attribute readonly="readonly" name="contentType" id="::validation::ElementEditVAL::contentType">
        <webidl>    readonly attribute unsigned short  contentType;</webidl>
        <Type type="unsigned short"/>
      </Attribute>
      <Operation name="canSetTextContent" id="::validation::ElementEditVAL::canSetTextContent">
        <webidl>    unsigned short     canSetTextContent(in DOMString? possibleTextContent);</webidl>
        <Type type="unsigned short"/>
        <ArgumentList>
          <Argument in="in" name="possibleTextContent">
            <Type type="DOMString" nullable="nullable"/>
          </Argument>
        </ArgumentList>
      </Operation>
      <Operation name="canSetAttribute" id="::validation::ElementEditVAL::canSetAttribute">
        <webidl>    unsigned short     canSetAttribute(in DOMString attrname, 
                                       in DOMString attrval);</webidl>
        <Type type="unsigned short"/>
        <ArgumentList>
          <Argument in="in" name="attrname">
            <Type type="DOMString"/>
          </Argument>
          <Argument in="in" name="attrval">
            <Type type="DOMString"/>
          </Argument>
        </ArgumentList>
      </Operation>
      <Operation name="canSetAttributeNode" id="::validation::ElementEditVAL::canSetAttributeNode">
        <webidl>    unsigned short     canSetAttributeNode(in <ref>Attr</ref> attrNode);</webidl>
        <Type type="unsigned short"/>
        <ArgumentList>
          <Argument in="in" name="attrNode">
            <Type name="Attr"/>
          </Argument>
        </ArgumentList>
      </Operation>
      <Operation name="canSetAttributeNS" id="::validation::ElementEditVAL::canSetAttributeNS">
        <webidl>    unsigned short     canSetAttributeNS(in DOMString? namespaceURI, 
                                         in DOMString qualifiedName, 
                                         in DOMString value);</webidl>
        <Type type="unsigned short"/>
        <ArgumentList>
          <Argument in="in" name="namespaceURI">
            <Type type="DOMString" nullable="nullable"/>
          </Argument>
          <Argument in="in" name="qualifiedName">
            <Type type="DOMString"/>
          </Argument>
          <Argument in="in" name="value">
            <Type type="DOMString"/>
          </Argument>
        </ArgumentList>
      </Operation>
      <Operation name="canRemoveAttribute" id="::validation::ElementEditVAL::canRemoveAttribute">
        <webidl>    unsigned short     canRemoveAttribute(in DOMString attrname);</webidl>
        <Type type="unsigned short"/>
        <ArgumentList>
          <Argument in="in" name="attrname">
            <Type type="DOMString"/>
          </Argument>
        </ArgumentList>
      </Operation>
      <Operation name="canRemoveAttributeNS" id="::validation::ElementEditVAL::canRemoveAttributeNS">
        <webidl>    unsigned short     canRemoveAttributeNS(in DOMString? namespaceURI, 
                                            in DOMString localName);</webidl>
        <Type type="unsigned short"/>
        <ArgumentList>
          <Argument in="in" name="namespaceURI">
            <Type type="DOMString" nullable="nullable"/>
          </Argument>
          <Argument in="in" name="localName">
            <Type type="DOMString"/>
          </Argument>
        </ArgumentList>
      </Operation>
      <Operation name="canRemoveAttributeNode" id="::validation::ElementEditVAL::canRemoveAttributeNode">
        <webidl>    unsigned short     canRemoveAttributeNode(in <ref>Node</ref> attrNode);</webidl>
        <Type type="unsigned short"/>
        <ArgumentList>
          <Argument in="in" name="attrNode">
            <Type name="Node"/>
          </Argument>
        </ArgumentList>
      </Operation>
      <Operation name="isElementDefined" id="::validation::ElementEditVAL::isElementDefined">
        <webidl>    unsigned short     isElementDefined(in DOMString name);</webidl>
        <Type type="unsigned short"/>
        <ArgumentList>
          <Argument in="in" name="name">
            <Type type="DOMString"/>
          </Argument>
        </ArgumentList>
      </Operation>
      <Operation name="isElementDefinedNS" id="::validation::ElementEditVAL::isElementDefinedNS">
        <webidl>    unsigned short     isElementDefinedNS(in DOMString? namespaceURI, 
                                          in DOMString name);</webidl>
        <Type type="unsigned short"/>
        <ArgumentList>
          <Argument in="in" name="namespaceURI">
            <Type type="DOMString" nullable="nullable"/>
          </Argument>
          <Argument in="in" name="name">
            <Type type="DOMString"/>
          </Argument>
        </ArgumentList>
      </Operation>
    </Interface>
    <Interface name="CharacterDataEditVAL" id="::validation::CharacterDataEditVAL">
      <webidl>  interface CharacterDataEditVAL : <ref>NodeEditVAL</ref> {
    unsigned short     isWhitespaceOnly();
    unsigned short     canSetData(in DOMString arg);
    unsigned short     canAppendData(in DOMString arg);
    unsigned short     canReplaceData(in unsigned long offset, 
                                      in unsigned long count, 
                                      in DOMString arg)
                                        raises(<ref>DOMException</ref>);
    unsigned short     canInsertData(in unsigned long offset, 
                                     in DOMString arg)
                                        raises(<ref>DOMException</ref>);
    unsigned short     canDeleteData(in unsigned long offset, 
                                     in unsigned long count)
                                        raises(<ref>DOMException</ref>);
  };</webidl>
      <InterfaceInheritance>
        <Name name="NodeEditVAL"/>
      </InterfaceInheritance>
      <Operation name="isWhitespaceOnly" id="::validation::CharacterDataEditVAL::isWhitespaceOnly">
        <webidl>    unsigned short     isWhitespaceOnly();</webidl>
        <Type type="unsigned short"/>
        <ArgumentList/>
      </Operation>
      <Operation name="canSetData" id="::validation::CharacterDataEditVAL::canSetData">
        <webidl>    unsigned short     canSetData(in DOMString arg);</webidl>
        <Type type="unsigned short"/>
        <ArgumentList>
          <Argument in="in" name="arg">
            <Type type="DOMString"/>
          </Argument>
        </ArgumentList>
      </Operation>
      <Operation name="canAppendData" id="::validation::CharacterDataEditVAL::canAppendData">
        <webidl>    unsigned short     canAppendData(in DOMString arg);</webidl>
        <Type type="unsigned short"/>
        <ArgumentList>
          <Argument in="in" name="arg">
            <Type type="DOMString"/>
          </Argument>
        </ArgumentList>
      </Operation>
      <Operation name="canReplaceData" id="::validation::CharacterDataEditVAL::canReplaceData">
        <webidl>    unsigned short     canReplaceData(in unsigned long offset, 
                                      in unsigned long count, 
                                      in DOMString arg)
                                        raises(<ref>DOMException</ref>);</webidl>
        <Type type="unsigned short"/>
        <ArgumentList>
          <Argument in="in" name="offset">
            <Type type="unsigned long"/>
          </Argument>
          <Argument in="in" name="count">
            <Type type="unsigned long"/>
          </Argument>
          <Argument in="in" name="arg">
            <Type type="DOMString"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="DOMException"/>
        </Raises>
      </Operation>
      <Operation name="canInsertData" id="::validation::CharacterDataEditVAL::canInsertData">
        <webidl>    unsigned short     canInsertData(in unsigned long offset, 
                                     in DOMString arg)
                                        raises(<ref>DOMException</ref>);</webidl>
        <Type type="unsigned short"/>
        <ArgumentList>
          <Argument in="in" name="offset">
            <Type type="unsigned long"/>
          </Argument>
          <Argument in="in" name="arg">
            <Type type="DOMString"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="DOMException"/>
        </Raises>
      </Operation>
      <Operation name="canDeleteData" id="::validation::CharacterDataEditVAL::canDeleteData">
        <webidl>    unsigned short     canDeleteData(in unsigned long offset, 
                                     in unsigned long count)
                                        raises(<ref>DOMException</ref>);</webidl>
        <Type type="unsigned short"/>
        <ArgumentList>
          <Argument in="in" name="offset">
            <Type type="unsigned long"/>
          </Argument>
          <Argument in="in" name="count">
            <Type type="unsigned long"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="DOMException"/>
        </Raises>
      </Operation>
    </Interface>
    <Interface name="DocumentEditVAL" id="::validation::DocumentEditVAL">
      <webidl>  interface DocumentEditVAL : <ref>NodeEditVAL</ref> {
             attribute boolean         continuousValidityChecking setraises(<ref>DOMException</ref>, <ref>ExceptionVAL</ref>);

    readonly attribute <ref>DOMConfiguration</ref> domConfig;
    <ref>NameList</ref>           getDefinedElements(in DOMString? namespaceURI);
    unsigned short     validateDocument();
  };</webidl>
      <InterfaceInheritance>
        <Name name="NodeEditVAL"/>
      </InterfaceInheritance>
      <Attribute name="continuousValidityChecking" id="::validation::DocumentEditVAL::continuousValidityChecking">
        <webidl>             attribute boolean         continuousValidityChecking setraises(<ref>DOMException</ref>, <ref>ExceptionVAL</ref>);</webidl>
        <Type type="boolean"/>
        <SetRaises>
          <RaiseException name="DOMException"/>
          <RaiseException name="ExceptionVAL"/>
        </SetRaises>
      </Attribute>
      <Attribute readonly="readonly" name="domConfig" id="::validation::DocumentEditVAL::domConfig">
        <webidl>    readonly attribute <ref>DOMConfiguration</ref> domConfig;</webidl>
        <Type name="DOMConfiguration"/>
      </Attribute>
      <Operation name="getDefinedElements" id="::validation::DocumentEditVAL::getDefinedElements">
        <webidl>    <ref>NameList</ref>           getDefinedElements(in DOMString? namespaceURI);</webidl>
        <Type name="NameList"/>
        <ArgumentList>
          <Argument in="in" name="namespaceURI">
            <Type type="DOMString" nullable="nullable"/>
          </Argument>
        </ArgumentList>
      </Operation>
      <Operation name="validateDocument" id="::validation::DocumentEditVAL::validateDocument">
        <webidl>    unsigned short     validateDocument();</webidl>
        <Type type="unsigned short"/>
        <ArgumentList/>
      </Operation>
    </Interface>
  </Module>
</Definitions>
<Definitions>
  <Module name="xpath" id="::xpath">
    <webidl>module xpath {

  typedef <ref>dom::Node</ref> Node;
  typedef <ref>dom::DOMObject</ref> DOMObject;
  typedef <ref>dom::Element</ref> Element;
  typedef <ref>dom::Document</ref> Document;
  typedef <ref>dom::DOMException</ref> DOMException;

  exception XPathException {
    const unsigned short      INVALID_EXPRESSION_ERR         = 51;
    const unsigned short      TYPE_ERR                       = 52;

    unsigned short   code;
  };

  interface XPathEvaluator {
    <ref>XPathExpression</ref>    createExpression(in DOMString expression, 
                                        in <ref>XPathNSResolver</ref> resolver)
                                        raises(<ref>XPathException</ref>, 
                                               <ref>DOMException</ref>);
    <ref>XPathNSResolver</ref>    createNSResolver(in <ref>Node</ref> nodeResolver);
    <ref>DOMObject</ref>          evaluate(in DOMString expression, 
                                in <ref>Node</ref> contextNode, 
                                in <ref>XPathNSResolver</ref> resolver, 
                                in unsigned short type, 
                                in <ref>DOMObject</ref> result)
                                        raises(<ref>XPathException</ref>, 
                                               <ref>DOMException</ref>);
  };

  <ref>Document</ref> implements <ref>XPathEvaluator</ref>;

  interface XPathExpression {
    <ref>DOMObject</ref>          evaluate(in <ref>Node</ref> contextNode, 
                                in unsigned short type, 
                                in <ref>DOMObject</ref> result)
                                        raises(<ref>XPathException</ref>, 
                                               <ref>dom::DOMException</ref>);
  };

  [Callback]
  interface XPathNSResolver {
    DOMString?         lookupNamespaceURI(in DOMString prefix);
  };

  interface XPathResult {

    const unsigned short      ANY_TYPE                       = 0;
    const unsigned short      NUMBER_TYPE                    = 1;
    const unsigned short      STRING_TYPE                    = 2;
    const unsigned short      BOOLEAN_TYPE                   = 3;
    const unsigned short      UNORDERED_NODE_ITERATOR_TYPE   = 4;
    const unsigned short      ORDERED_NODE_ITERATOR_TYPE     = 5;
    const unsigned short      UNORDERED_NODE_SNAPSHOT_TYPE   = 6;
    const unsigned short      ORDERED_NODE_SNAPSHOT_TYPE     = 7;
    const unsigned short      ANY_UNORDERED_NODE_TYPE        = 8;
    const unsigned short      FIRST_ORDERED_NODE_TYPE        = 9;

    readonly attribute unsigned short  resultType;
    readonly attribute double          numberValue getraises(<ref>XPathException</ref>);

    readonly attribute DOMString       stringValue getraises(<ref>XPathException</ref>);

    readonly attribute boolean         booleanValue getraises(<ref>XPathException</ref>);

    readonly attribute <ref>Node</ref>            singleNodeValue getraises(<ref>XPathException</ref>);

    readonly attribute boolean         invalidIteratorState;
    readonly attribute unsigned long   snapshotLength getraises(<ref>XPathException</ref>);

    <ref>Node</ref>               iterateNext()
                                        raises(<ref>XPathException</ref>, 
                                               <ref>DOMException</ref>);
    <ref>Node</ref>               snapshotItem(in unsigned long index)
                                        raises(<ref>XPathException</ref>);
  };

  interface XPathNamespace : <ref>Node</ref> {

    const unsigned short      XPATH_NAMESPACE_NODE           = 13;

    readonly attribute <ref>Element</ref>         ownerElement;
  };
};</webidl>
    <Typedef name="Node" id="::xpath::Node">
      <webidl>  typedef <ref>dom::Node</ref> Node;</webidl>
      <Type name="domNode"/>
    </Typedef>
    <Typedef name="DOMObject" id="::xpath::DOMObject">
      <webidl>  typedef <ref>dom::DOMObject</ref> DOMObject;</webidl>
      <Type name="domDOMObject"/>
    </Typedef>
    <Typedef name="Element" id="::xpath::Element">
      <webidl>  typedef <ref>dom::Element</ref> Element;</webidl>
      <Type name="domElement"/>
    </Typedef>
    <Typedef name="Document" id="::xpath::Document">
      <webidl>  typedef <ref>dom::Document</ref> Document;</webidl>
      <Type name="domDocument"/>
    </Typedef>
    <Typedef name="DOMException" id="::xpath::DOMException">
      <webidl>  typedef <ref>dom::DOMException</ref> DOMException;</webidl>
      <Type name="domDOMException"/>
    </Typedef>
    <Exception name="XPathException" id="::xpath::XPathException">
      <webidl>  exception XPathException {
    const unsigned short      INVALID_EXPRESSION_ERR         = 51;
    const unsigned short      TYPE_ERR                       = 52;

    unsigned short   code;
  };</webidl>
      <Const name="INVALID_EXPRESSION_ERR" value="51" id="::xpath::XPathException::INVALID_EXPRESSION_ERR">
        <Type type="unsigned short"/>
      </Const>
      <Const name="TYPE_ERR" value="52" id="::xpath::XPathException::TYPE_ERR">
        <Type type="unsigned short"/>
      </Const>
      <ExceptionField name="code" id="::xpath::XPathException::code">
        <Type type="unsigned short"/>
      </ExceptionField>
    </Exception>
    <Interface name="XPathEvaluator" id="::xpath::XPathEvaluator">
      <webidl>  interface XPathEvaluator {
    <ref>XPathExpression</ref>    createExpression(in DOMString expression, 
                                        in <ref>XPathNSResolver</ref> resolver)
                                        raises(<ref>XPathException</ref>, 
                                               <ref>DOMException</ref>);
    <ref>XPathNSResolver</ref>    createNSResolver(in <ref>Node</ref> nodeResolver);
    <ref>DOMObject</ref>          evaluate(in DOMString expression, 
                                in <ref>Node</ref> contextNode, 
                                in <ref>XPathNSResolver</ref> resolver, 
                                in unsigned short type, 
                                in <ref>DOMObject</ref> result)
                                        raises(<ref>XPathException</ref>, 
                                               <ref>DOMException</ref>);
  };</webidl>
      <Operation name="createExpression" id="::xpath::XPathEvaluator::createExpression">
        <webidl>    <ref>XPathExpression</ref>    createExpression(in DOMString expression, 
                                        in <ref>XPathNSResolver</ref> resolver)
                                        raises(<ref>XPathException</ref>, 
                                               <ref>DOMException</ref>);</webidl>
        <Type name="XPathExpression"/>
        <ArgumentList>
          <Argument in="in" name="expression">
            <Type type="DOMString"/>
          </Argument>
          <Argument in="in" name="resolver">
            <Type name="XPathNSResolver"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="XPathException"/>
          <RaiseException name="DOMException"/>
        </Raises>
      </Operation>
      <Operation name="createNSResolver" id="::xpath::XPathEvaluator::createNSResolver">
        <webidl>    <ref>XPathNSResolver</ref>    createNSResolver(in <ref>Node</ref> nodeResolver);</webidl>
        <Type name="XPathNSResolver"/>
        <ArgumentList>
          <Argument in="in" name="nodeResolver">
            <Type name="Node"/>
          </Argument>
        </ArgumentList>
      </Operation>
      <Operation name="evaluate" id="::xpath::XPathEvaluator::evaluate">
        <webidl>    <ref>DOMObject</ref>          evaluate(in DOMString expression, 
                                in <ref>Node</ref> contextNode, 
                                in <ref>XPathNSResolver</ref> resolver, 
                                in unsigned short type, 
                                in <ref>DOMObject</ref> result)
                                        raises(<ref>XPathException</ref>, 
                                               <ref>DOMException</ref>);</webidl>
        <Type name="DOMObject"/>
        <ArgumentList>
          <Argument in="in" name="expression">
            <Type type="DOMString"/>
          </Argument>
          <Argument in="in" name="contextNode">
            <Type name="Node"/>
          </Argument>
          <Argument in="in" name="resolver">
            <Type name="XPathNSResolver"/>
          </Argument>
          <Argument in="in" name="type">
            <Type type="unsigned short"/>
          </Argument>
          <Argument in="in" name="result">
            <Type name="DOMObject"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="XPathException"/>
          <RaiseException name="DOMException"/>
        </Raises>
      </Operation>
    </Interface>
    <Implements name1="Document" name2="XPathEvaluator">
      <webidl>  <ref>Document</ref> implements <ref>XPathEvaluator</ref>;</webidl>
    </Implements>
    <Interface name="XPathExpression" id="::xpath::XPathExpression">
      <webidl>  interface XPathExpression {
    <ref>DOMObject</ref>          evaluate(in <ref>Node</ref> contextNode, 
                                in unsigned short type, 
                                in <ref>DOMObject</ref> result)
                                        raises(<ref>XPathException</ref>, 
                                               <ref>dom::DOMException</ref>);
  };</webidl>
      <Operation name="evaluate" id="::xpath::XPathExpression::evaluate">
        <webidl>    <ref>DOMObject</ref>          evaluate(in <ref>Node</ref> contextNode, 
                                in unsigned short type, 
                                in <ref>DOMObject</ref> result)
                                        raises(<ref>XPathException</ref>, 
                                               <ref>dom::DOMException</ref>);</webidl>
        <Type name="DOMObject"/>
        <ArgumentList>
          <Argument in="in" name="contextNode">
            <Type name="Node"/>
          </Argument>
          <Argument in="in" name="type">
            <Type type="unsigned short"/>
          </Argument>
          <Argument in="in" name="result">
            <Type name="DOMObject"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="XPathException"/>
          <RaiseException name="domDOMException"/>
        </Raises>
      </Operation>
    </Interface>
    <Interface name="XPathNSResolver" id="::xpath::XPathNSResolver">
      <webidl>  [Callback]
  interface XPathNSResolver {
    DOMString?         lookupNamespaceURI(in DOMString prefix);
  };</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="Callback"/>
      </ExtendedAttributeList>
      <Operation name="lookupNamespaceURI" id="::xpath::XPathNSResolver::lookupNamespaceURI">
        <webidl>    DOMString?         lookupNamespaceURI(in DOMString prefix);</webidl>
        <Type type="DOMString" nullable="nullable"/>
        <ArgumentList>
          <Argument in="in" name="prefix">
            <Type type="DOMString"/>
          </Argument>
        </ArgumentList>
      </Operation>
    </Interface>
    <Interface name="XPathResult" id="::xpath::XPathResult">
      <webidl>  interface XPathResult {

    const unsigned short      ANY_TYPE                       = 0;
    const unsigned short      NUMBER_TYPE                    = 1;
    const unsigned short      STRING_TYPE                    = 2;
    const unsigned short      BOOLEAN_TYPE                   = 3;
    const unsigned short      UNORDERED_NODE_ITERATOR_TYPE   = 4;
    const unsigned short      ORDERED_NODE_ITERATOR_TYPE     = 5;
    const unsigned short      UNORDERED_NODE_SNAPSHOT_TYPE   = 6;
    const unsigned short      ORDERED_NODE_SNAPSHOT_TYPE     = 7;
    const unsigned short      ANY_UNORDERED_NODE_TYPE        = 8;
    const unsigned short      FIRST_ORDERED_NODE_TYPE        = 9;

    readonly attribute unsigned short  resultType;
    readonly attribute double          numberValue getraises(<ref>XPathException</ref>);

    readonly attribute DOMString       stringValue getraises(<ref>XPathException</ref>);

    readonly attribute boolean         booleanValue getraises(<ref>XPathException</ref>);

    readonly attribute <ref>Node</ref>            singleNodeValue getraises(<ref>XPathException</ref>);

    readonly attribute boolean         invalidIteratorState;
    readonly attribute unsigned long   snapshotLength getraises(<ref>XPathException</ref>);

    <ref>Node</ref>               iterateNext()
                                        raises(<ref>XPathException</ref>, 
                                               <ref>DOMException</ref>);
    <ref>Node</ref>               snapshotItem(in unsigned long index)
                                        raises(<ref>XPathException</ref>);
  };</webidl>
      <Const name="ANY_TYPE" value="0" id="::xpath::XPathResult::ANY_TYPE">
        <webidl>    const unsigned short      ANY_TYPE                       = 0;</webidl>
        <Type type="unsigned short"/>
      </Const>
      <Const name="NUMBER_TYPE" value="1" id="::xpath::XPathResult::NUMBER_TYPE">
        <webidl>    const unsigned short      NUMBER_TYPE                    = 1;</webidl>
        <Type type="unsigned short"/>
      </Const>
      <Const name="STRING_TYPE" value="2" id="::xpath::XPathResult::STRING_TYPE">
        <webidl>    const unsigned short      STRING_TYPE                    = 2;</webidl>
        <Type type="unsigned short"/>
      </Const>
      <Const name="BOOLEAN_TYPE" value="3" id="::xpath::XPathResult::BOOLEAN_TYPE">
        <webidl>    const unsigned short      BOOLEAN_TYPE                   = 3;</webidl>
        <Type type="unsigned short"/>
      </Const>
      <Const name="UNORDERED_NODE_ITERATOR_TYPE" value="4" id="::xpath::XPathResult::UNORDERED_NODE_ITERATOR_TYPE">
        <webidl>    const unsigned short      UNORDERED_NODE_ITERATOR_TYPE   = 4;</webidl>
        <Type type="unsigned short"/>
      </Const>
      <Const name="ORDERED_NODE_ITERATOR_TYPE" value="5" id="::xpath::XPathResult::ORDERED_NODE_ITERATOR_TYPE">
        <webidl>    const unsigned short      ORDERED_NODE_ITERATOR_TYPE     = 5;</webidl>
        <Type type="unsigned short"/>
      </Const>
      <Const name="UNORDERED_NODE_SNAPSHOT_TYPE" value="6" id="::xpath::XPathResult::UNORDERED_NODE_SNAPSHOT_TYPE">
        <webidl>    const unsigned short      UNORDERED_NODE_SNAPSHOT_TYPE   = 6;</webidl>
        <Type type="unsigned short"/>
      </Const>
      <Const name="ORDERED_NODE_SNAPSHOT_TYPE" value="7" id="::xpath::XPathResult::ORDERED_NODE_SNAPSHOT_TYPE">
        <webidl>    const unsigned short      ORDERED_NODE_SNAPSHOT_TYPE     = 7;</webidl>
        <Type type="unsigned short"/>
      </Const>
      <Const name="ANY_UNORDERED_NODE_TYPE" value="8" id="::xpath::XPathResult::ANY_UNORDERED_NODE_TYPE">
        <webidl>    const unsigned short      ANY_UNORDERED_NODE_TYPE        = 8;</webidl>
        <Type type="unsigned short"/>
      </Const>
      <Const name="FIRST_ORDERED_NODE_TYPE" value="9" id="::xpath::XPathResult::FIRST_ORDERED_NODE_TYPE">
        <webidl>    const unsigned short      FIRST_ORDERED_NODE_TYPE        = 9;</webidl>
        <Type type="unsigned short"/>
      </Const>
      <Attribute readonly="readonly" name="resultType" id="::xpath::XPathResult::resultType">
        <webidl>    readonly attribute unsigned short  resultType;</webidl>
        <Type type="unsigned short"/>
      </Attribute>
      <Attribute readonly="readonly" name="numberValue" id="::xpath::XPathResult::numberValue">
        <webidl>    readonly attribute double          numberValue getraises(<ref>XPathException</ref>);</webidl>
        <Type type="double"/>
        <GetRaises>
          <RaiseException name="XPathException"/>
        </GetRaises>
      </Attribute>
      <Attribute readonly="readonly" name="stringValue" id="::xpath::XPathResult::stringValue">
        <webidl>    readonly attribute DOMString       stringValue getraises(<ref>XPathException</ref>);</webidl>
        <Type type="DOMString"/>
        <GetRaises>
          <RaiseException name="XPathException"/>
        </GetRaises>
      </Attribute>
      <Attribute readonly="readonly" name="booleanValue" id="::xpath::XPathResult::booleanValue">
        <webidl>    readonly attribute boolean         booleanValue getraises(<ref>XPathException</ref>);</webidl>
        <Type type="boolean"/>
        <GetRaises>
          <RaiseException name="XPathException"/>
        </GetRaises>
      </Attribute>
      <Attribute readonly="readonly" name="singleNodeValue" id="::xpath::XPathResult::singleNodeValue">
        <webidl>    readonly attribute <ref>Node</ref>            singleNodeValue getraises(<ref>XPathException</ref>);</webidl>
        <Type name="Node"/>
        <GetRaises>
          <RaiseException name="XPathException"/>
        </GetRaises>
      </Attribute>
      <Attribute readonly="readonly" name="invalidIteratorState" id="::xpath::XPathResult::invalidIteratorState">
        <webidl>    readonly attribute boolean         invalidIteratorState;</webidl>
        <Type type="boolean"/>
      </Attribute>
      <Attribute readonly="readonly" name="snapshotLength" id="::xpath::XPathResult::snapshotLength">
        <webidl>    readonly attribute unsigned long   snapshotLength getraises(<ref>XPathException</ref>);</webidl>
        <Type type="unsigned long"/>
        <GetRaises>
          <RaiseException name="XPathException"/>
        </GetRaises>
      </Attribute>
      <Operation name="iterateNext" id="::xpath::XPathResult::iterateNext">
        <webidl>    <ref>Node</ref>               iterateNext()
                                        raises(<ref>XPathException</ref>, 
                                               <ref>DOMException</ref>);</webidl>
        <Type name="Node"/>
        <ArgumentList/>
        <Raises>
          <RaiseException name="XPathException"/>
          <RaiseException name="DOMException"/>
        </Raises>
      </Operation>
      <Operation name="snapshotItem" id="::xpath::XPathResult::snapshotItem">
        <webidl>    <ref>Node</ref>               snapshotItem(in unsigned long index)
                                        raises(<ref>XPathException</ref>);</webidl>
        <Type name="Node"/>
        <ArgumentList>
          <Argument in="in" name="index">
            <Type type="unsigned long"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="XPathException"/>
        </Raises>
      </Operation>
    </Interface>
    <Interface name="XPathNamespace" id="::xpath::XPathNamespace">
      <webidl>  interface XPathNamespace : <ref>Node</ref> {

    const unsigned short      XPATH_NAMESPACE_NODE           = 13;

    readonly attribute <ref>Element</ref>         ownerElement;
  };</webidl>
      <InterfaceInheritance>
        <Name name="Node"/>
      </InterfaceInheritance>
      <Const name="XPATH_NAMESPACE_NODE" value="13" id="::xpath::XPathNamespace::XPATH_NAMESPACE_NODE">
        <webidl>    const unsigned short      XPATH_NAMESPACE_NODE           = 13;</webidl>
        <Type type="unsigned short"/>
      </Const>
      <Attribute readonly="readonly" name="ownerElement" id="::xpath::XPathNamespace::ownerElement">
        <webidl>    readonly attribute <ref>Element</ref>         ownerElement;</webidl>
        <Type name="Element"/>
      </Attribute>
    </Interface>
  </Module>
</Definitions>
<Definitions>
  <webidl>    interface FileList {
      getter <ref>File</ref>? item(unsigned long index);
      readonly attribute unsigned long length;
    };
    

    [Constructor, 
     Constructor(sequence&lt;(<ref>ArrayBuffer</ref> or <ref>ArrayBufferView</ref> or <ref>Blob</ref> or DOMString)> blobParts, optional <ref>BlobPropertyBag</ref> options)] 
    interface Blob {
      
      readonly attribute unsigned long long size;
      readonly attribute DOMString type;
      
      
      <ref>Blob</ref> slice(optional long long start,
                 optional long long end,
                 optional DOMString contentType);
      void close(); 
    
    };

    dictionary BlobPropertyBag {
                
      DOMString type = &quot;&quot;;
        
    };
    

interface File : <ref>Blob</ref> {

  readonly attribute DOMString name;
  readonly attribute Date lastModifiedDate;

};
          


        [Constructor]
        interface FileReader: <ref>EventTarget</ref> {

          void readAsArrayBuffer(<ref>Blob</ref> blob);
          void readAsText(<ref>Blob</ref> blob, optional DOMString label);
          void readAsDataURL(<ref>Blob</ref> blob);

          void abort();

          const unsigned short EMPTY = 0;
          const unsigned short LOADING = 1;
          const unsigned short DONE = 2;


          readonly attribute unsigned short readyState;

          readonly attribute (DOMString or <ref>ArrayBuffer</ref>)? result;

          readonly attribute <ref>DOMError</ref>? error;

          attribute <ref>EventHandler</ref> onloadstart;
          attribute <ref>EventHandler</ref> onprogress;
          attribute <ref>EventHandler</ref> onload;
          attribute <ref>EventHandler</ref> onabort;
          attribute <ref>EventHandler</ref> onerror;
          attribute <ref>EventHandler</ref> onloadend;

        };
          


        [Constructor]
        interface FileReaderSync {


          <ref>ArrayBuffer</ref> readAsArrayBuffer(<ref>Blob</ref> blob); 
          DOMString readAsText(<ref>Blob</ref> blob, optional DOMString label);
          DOMString readAsDataURL(<ref>Blob</ref> blob);
        };
        

        partial interface URL {

            static DOMString? createObjectURL(<ref>Blob</ref> blob, optional <ref>objectURLOptions</ref> options);
            static void revokeObjectURL(DOMString url);
        };
        
        dictionary objectURLOptions
        {
                boolean autoRevoke = true;

        };</webidl>
  <Interface name="FileList" id="::FileList">
    <webidl>    interface FileList {
      getter <ref>File</ref>? item(unsigned long index);
      readonly attribute unsigned long length;
    };</webidl>
    <Operation getter="getter" name="item" id="::FileList::item">
      <webidl>      getter <ref>File</ref>? item(unsigned long index);</webidl>
      <Type name="File" nullable="nullable"/>
      <ArgumentList>
        <Argument name="index">
          <Type type="unsigned long"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Attribute readonly="readonly" name="length" id="::FileList::length">
      <webidl>      readonly attribute unsigned long length;</webidl>
      <Type type="unsigned long"/>
    </Attribute>
  </Interface>
  <Interface name="Blob" id="::Blob">
    <webidl>    [Constructor, 
     Constructor(sequence&lt;(<ref>ArrayBuffer</ref> or <ref>ArrayBufferView</ref> or <ref>Blob</ref> or DOMString)> blobParts, optional <ref>BlobPropertyBag</ref> options)] 
    interface Blob {
      
      readonly attribute unsigned long long size;
      readonly attribute DOMString type;
      
      
      <ref>Blob</ref> slice(optional long long start,
                 optional long long end,
                 optional DOMString contentType);
      void close(); 
    
    };</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="Constructor">
        <webidl>Constructor</webidl>
      </ExtendedAttribute>
      <ExtendedAttribute name="Constructor">
        <webidl>     Constructor(sequence&lt;(<ref>ArrayBuffer</ref> or <ref>ArrayBufferView</ref> or <ref>Blob</ref> or DOMString)> blobParts, optional <ref>BlobPropertyBag</ref> options)</webidl>
        <ArgumentList>
          <Argument name="blobParts">
            <Type type="sequence">
              <Type type="union">
                <Type name="ArrayBuffer"/>
                <Type name="ArrayBufferView"/>
                <Type name="Blob"/>
                <Type type="DOMString"/>
              </Type>
            </Type>
          </Argument>
          <Argument optional="optional" name="options">
            <Type name="BlobPropertyBag"/>
          </Argument>
        </ArgumentList>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <Attribute readonly="readonly" name="size" id="::Blob::size">
      <webidl>      readonly attribute unsigned long long size;</webidl>
      <Type type="unsigned long long"/>
    </Attribute>
    <Attribute readonly="readonly" name="type" id="::Blob::type">
      <webidl>      readonly attribute DOMString type;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Operation name="slice" id="::Blob::slice">
      <webidl>      <ref>Blob</ref> slice(optional long long start,
                 optional long long end,
                 optional DOMString contentType);</webidl>
      <Type name="Blob"/>
      <ArgumentList>
        <Argument optional="optional" name="start">
          <Type type="long long"/>
        </Argument>
        <Argument optional="optional" name="end">
          <Type type="long long"/>
        </Argument>
        <Argument optional="optional" name="contentType">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="close" id="::Blob::close">
      <webidl>      void close();</webidl>
      <Type type="void"/>
      <ArgumentList/>
    </Operation>
  </Interface>
  <Dictionary name="BlobPropertyBag" id="::BlobPropertyBag">
    <webidl>    dictionary BlobPropertyBag {
                
      DOMString type = &quot;&quot;;
        
    };</webidl>
    <DictionaryMember name="type" stringvalue="" id="::BlobPropertyBag::type">
      <webidl>      DOMString type = &quot;&quot;;</webidl>
      <Type type="DOMString"/>
    </DictionaryMember>
  </Dictionary>
  <Interface name="File" id="::File">
    <webidl>interface File : <ref>Blob</ref> {

  readonly attribute DOMString name;
  readonly attribute Date lastModifiedDate;

};</webidl>
    <InterfaceInheritance>
      <Name name="Blob"/>
    </InterfaceInheritance>
    <Attribute readonly="readonly" name="name" id="::File::name">
      <webidl>  readonly attribute DOMString name;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute readonly="readonly" name="lastModifiedDate" id="::File::lastModifiedDate">
      <webidl>  readonly attribute Date lastModifiedDate;</webidl>
      <Type type="Date"/>
    </Attribute>
  </Interface>
  <Interface name="FileReader" id="::FileReader">
    <webidl>        [Constructor]
        interface FileReader: <ref>EventTarget</ref> {

          void readAsArrayBuffer(<ref>Blob</ref> blob);
          void readAsText(<ref>Blob</ref> blob, optional DOMString label);
          void readAsDataURL(<ref>Blob</ref> blob);

          void abort();

          const unsigned short EMPTY = 0;
          const unsigned short LOADING = 1;
          const unsigned short DONE = 2;


          readonly attribute unsigned short readyState;

          readonly attribute (DOMString or <ref>ArrayBuffer</ref>)? result;

          readonly attribute <ref>DOMError</ref>? error;

          attribute <ref>EventHandler</ref> onloadstart;
          attribute <ref>EventHandler</ref> onprogress;
          attribute <ref>EventHandler</ref> onload;
          attribute <ref>EventHandler</ref> onabort;
          attribute <ref>EventHandler</ref> onerror;
          attribute <ref>EventHandler</ref> onloadend;

        };</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="Constructor">
        <webidl>Constructor</webidl>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <InterfaceInheritance>
      <Name name="EventTarget"/>
    </InterfaceInheritance>
    <Operation name="readAsArrayBuffer" id="::FileReader::readAsArrayBuffer">
      <webidl>          void readAsArrayBuffer(<ref>Blob</ref> blob);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument name="blob">
          <Type name="Blob"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="readAsText" id="::FileReader::readAsText">
      <webidl>          void readAsText(<ref>Blob</ref> blob, optional DOMString label);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument name="blob">
          <Type name="Blob"/>
        </Argument>
        <Argument optional="optional" name="label">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="readAsDataURL" id="::FileReader::readAsDataURL">
      <webidl>          void readAsDataURL(<ref>Blob</ref> blob);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument name="blob">
          <Type name="Blob"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="abort" id="::FileReader::abort">
      <webidl>          void abort();</webidl>
      <Type type="void"/>
      <ArgumentList/>
    </Operation>
    <Const name="EMPTY" value="0" id="::FileReader::EMPTY">
      <webidl>          const unsigned short EMPTY = 0;</webidl>
      <Type type="unsigned short"/>
    </Const>
    <Const name="LOADING" value="1" id="::FileReader::LOADING">
      <webidl>          const unsigned short LOADING = 1;</webidl>
      <Type type="unsigned short"/>
    </Const>
    <Const name="DONE" value="2" id="::FileReader::DONE">
      <webidl>          const unsigned short DONE = 2;</webidl>
      <Type type="unsigned short"/>
    </Const>
    <Attribute readonly="readonly" name="readyState" id="::FileReader::readyState">
      <webidl>          readonly attribute unsigned short readyState;</webidl>
      <Type type="unsigned short"/>
    </Attribute>
    <Attribute readonly="readonly" name="result" id="::FileReader::result">
      <webidl>          readonly attribute (DOMString or <ref>ArrayBuffer</ref>)? result;</webidl>
      <Type type="union" nullable="nullable">
        <Type type="DOMString"/>
        <Type name="ArrayBuffer"/>
      </Type>
    </Attribute>
    <Attribute readonly="readonly" name="error" id="::FileReader::error">
      <webidl>          readonly attribute <ref>DOMError</ref>? error;</webidl>
      <Type name="DOMError" nullable="nullable"/>
    </Attribute>
    <Attribute name="onloadstart" id="::FileReader::onloadstart">
      <webidl>          attribute <ref>EventHandler</ref> onloadstart;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="onprogress" id="::FileReader::onprogress">
      <webidl>          attribute <ref>EventHandler</ref> onprogress;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="onload" id="::FileReader::onload">
      <webidl>          attribute <ref>EventHandler</ref> onload;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="onabort" id="::FileReader::onabort">
      <webidl>          attribute <ref>EventHandler</ref> onabort;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="onerror" id="::FileReader::onerror">
      <webidl>          attribute <ref>EventHandler</ref> onerror;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="onloadend" id="::FileReader::onloadend">
      <webidl>          attribute <ref>EventHandler</ref> onloadend;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
  </Interface>
  <Interface name="FileReaderSync" id="::FileReaderSync">
    <webidl>        [Constructor]
        interface FileReaderSync {


          <ref>ArrayBuffer</ref> readAsArrayBuffer(<ref>Blob</ref> blob); 
          DOMString readAsText(<ref>Blob</ref> blob, optional DOMString label);
          DOMString readAsDataURL(<ref>Blob</ref> blob);
        };</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="Constructor">
        <webidl>Constructor</webidl>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <Operation name="readAsArrayBuffer" id="::FileReaderSync::readAsArrayBuffer">
      <webidl>          <ref>ArrayBuffer</ref> readAsArrayBuffer(<ref>Blob</ref> blob);</webidl>
      <Type name="ArrayBuffer"/>
      <ArgumentList>
        <Argument name="blob">
          <Type name="Blob"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="readAsText" id="::FileReaderSync::readAsText">
      <webidl>          DOMString readAsText(<ref>Blob</ref> blob, optional DOMString label);</webidl>
      <Type type="DOMString"/>
      <ArgumentList>
        <Argument name="blob">
          <Type name="Blob"/>
        </Argument>
        <Argument optional="optional" name="label">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="readAsDataURL" id="::FileReaderSync::readAsDataURL">
      <webidl>          DOMString readAsDataURL(<ref>Blob</ref> blob);</webidl>
      <Type type="DOMString"/>
      <ArgumentList>
        <Argument name="blob">
          <Type name="Blob"/>
        </Argument>
      </ArgumentList>
    </Operation>
  </Interface>
  <Interface name="URL" partial="partial" id="::URL">
    <webidl>        partial interface URL {

            static DOMString? createObjectURL(<ref>Blob</ref> blob, optional <ref>objectURLOptions</ref> options);
            static void revokeObjectURL(DOMString url);
        };</webidl>
    <Operation static="static" name="createObjectURL" id="::URL::createObjectURL">
      <webidl>            static DOMString? createObjectURL(<ref>Blob</ref> blob, optional <ref>objectURLOptions</ref> options);</webidl>
      <Type type="DOMString" nullable="nullable"/>
      <ArgumentList>
        <Argument name="blob">
          <Type name="Blob"/>
        </Argument>
        <Argument optional="optional" name="options">
          <Type name="objectURLOptions"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation static="static" name="revokeObjectURL" id="::URL::revokeObjectURL">
      <webidl>            static void revokeObjectURL(DOMString url);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument name="url">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
  </Interface>
  <Dictionary name="objectURLOptions" id="::objectURLOptions">
    <webidl>        dictionary objectURLOptions
        {
                boolean autoRevoke = true;

        };</webidl>
    <DictionaryMember name="autoRevoke" value="true" id="::objectURLOptions::autoRevoke">
      <webidl>                boolean autoRevoke = true;</webidl>
      <Type type="boolean"/>
    </DictionaryMember>
  </Dictionary>
</Definitions>
<Definitions>
  <webidl>interface HTMLAllCollection : <ref>HTMLCollection</ref> {
  (<ref>HTMLCollection</ref> or <ref>Element</ref>)? item(DOMString name);
  legacycaller getter (<ref>HTMLCollection</ref> or <ref>Element</ref>)? namedItem(DOMString name); 
  <ref>HTMLAllCollection</ref> tags(DOMString tagName);
};
interface HTMLFormControlsCollection : <ref>HTMLCollection</ref> {
  legacycaller getter (<ref>RadioNodeList</ref> or <ref>Element</ref>)? namedItem(DOMString name); 
};

interface RadioNodeList : <ref>NodeList</ref> {
          attribute DOMString value;
};
interface HTMLOptionsCollection : <ref>HTMLCollection</ref> {
           attribute unsigned long length; 
  legacycaller getter (<ref>HTMLOptionElement</ref> or <ref>HTMLOptGroupElement</ref>)? namedItem(DOMString name); 
  setter creator void (unsigned long index, <ref>HTMLOptionElement</ref>? option);
  void add((<ref>HTMLOptionElement</ref> or <ref>HTMLOptGroupElement</ref>) element, optional (<ref>HTMLElement</ref> or long)? before = null);
  void remove(long index);
           attribute long selectedIndex;
};
interface DOMStringMap {
  getter DOMString (DOMString name);
  setter creator void (DOMString name, DOMString value);
  deleter void (DOMString name);
};
interface DOMElementMap {
  getter <ref>Element</ref> (DOMString name);
  setter creator void (DOMString name, <ref>Element</ref> value);
  deleter void (DOMString name);
};
[NoInterfaceObject]
interface Transferable { };
callback FileCallback = void (<ref>File</ref> file);
enum DocumentReadyState { &quot;loading&quot;, &quot;interactive&quot;, &quot;complete&quot; };

[OverrideBuiltins]
partial  interface Document {
  [PutForwards=href, Unforgeable] readonly attribute <ref>Location</ref>? location;
           attribute DOMString domain;
  readonly attribute DOMString referrer;
           attribute DOMString cookie;
  readonly attribute DOMString lastModified;
  readonly attribute <ref>DocumentReadyState</ref> readyState;

  getter object (DOMString name);
           attribute DOMString title;
           attribute DOMString dir;
           attribute <ref>HTMLElement</ref>? body;
  readonly attribute <ref>HTMLHeadElement</ref>? head;
  readonly attribute <ref>HTMLCollection</ref> images;
  readonly attribute <ref>HTMLCollection</ref> embeds;
  readonly attribute <ref>HTMLCollection</ref> plugins;
  readonly attribute <ref>HTMLCollection</ref> links;
  readonly attribute <ref>HTMLCollection</ref> forms;
  readonly attribute <ref>HTMLCollection</ref> scripts;
  <ref>NodeList</ref> getElementsByName(DOMString elementName);
  <ref>NodeList</ref> getItems(optional DOMString typeNames = &quot;&quot;); 
  readonly attribute <ref>DOMElementMap</ref> cssElementMap;
  readonly attribute <ref>HTMLScriptElement</ref>? currentScript;

  <ref>Document</ref> open(optional DOMString type = &quot;text/html&quot;, optional DOMString replace = &quot;&quot;);
  <ref>WindowProxy</ref> open(DOMString url, DOMString name, DOMString features, optional boolean replace = false);
  void close();
  void write(DOMString... text);
  void writeln(DOMString... text);

  readonly attribute <ref>WindowProxy</ref>? defaultView;
  readonly attribute <ref>Element</ref>? activeElement;
  boolean hasFocus();
           attribute DOMString designMode;
  boolean execCommand(DOMString commandId, optional boolean showUI = false, optional DOMString value = &quot;&quot;);
  boolean queryCommandEnabled(DOMString commandId);
  boolean queryCommandIndeterm(DOMString commandId);
  boolean queryCommandState(DOMString commandId);
  boolean queryCommandSupported(DOMString commandId);
  DOMString queryCommandValue(DOMString commandId);
  readonly attribute <ref>HTMLCollection</ref> commands;

  [LenientThis] attribute <ref>EventHandler</ref> onreadystatechange;
};
<ref>Document</ref> implements <ref>GlobalEventHandlers</ref>;
partial interface XMLDocument {
  boolean load(DOMString url);
};
interface HTMLElement : <ref>Element</ref> {
           attribute DOMString title;
           attribute DOMString lang;
           attribute boolean translate;
           attribute DOMString dir;
  readonly attribute <ref>DOMStringMap</ref> dataset;

           attribute boolean itemScope;
  [PutForwards=value] readonly attribute <ref>DOMSettableTokenList</ref> itemType;
           attribute DOMString itemId;
  [PutForwards=value] readonly attribute <ref>DOMSettableTokenList</ref> itemRef;
  [PutForwards=value] readonly attribute <ref>DOMSettableTokenList</ref> itemProp;
  readonly attribute <ref>HTMLPropertiesCollection</ref> properties;
           attribute any itemValue; 

           attribute boolean hidden;
  void click();
           attribute long tabIndex;
  void focus();
  void blur();
           attribute DOMString accessKey;
  readonly attribute DOMString accessKeyLabel;
           attribute boolean draggable;
  [PutForwards=value] readonly attribute <ref>DOMSettableTokenList</ref> dropzone;
           attribute DOMString contentEditable;
  readonly attribute boolean isContentEditable;
           attribute <ref>HTMLMenuElement</ref>? contextMenu;
           attribute boolean spellcheck;
  void forceSpellCheck();

  readonly attribute DOMString? commandType;
  readonly attribute DOMString? commandLabel;
  readonly attribute DOMString? commandIcon;
  readonly attribute boolean? commandHidden;
  readonly attribute boolean? commandDisabled;
  readonly attribute boolean? commandChecked;

  [PutForwards=cssText] readonly attribute <ref>CSSStyleDeclaration</ref> style;
};
<ref>HTMLElement</ref> implements <ref>GlobalEventHandlers</ref>;

interface HTMLUnknownElement : <ref>HTMLElement</ref> { };
interface HTMLHtmlElement : <ref>HTMLElement</ref> {};
interface HTMLHeadElement : <ref>HTMLElement</ref> {};
interface HTMLTitleElement : <ref>HTMLElement</ref> {
           attribute DOMString text;
};
interface HTMLBaseElement : <ref>HTMLElement</ref> {
           attribute DOMString href;
           attribute DOMString target;
};
interface HTMLLinkElement : <ref>HTMLElement</ref> {
           attribute boolean disabled;
           attribute DOMString href;
           attribute DOMString crossOrigin;
           attribute DOMString rel;
  readonly attribute <ref>DOMTokenList</ref> relList;
           attribute DOMString media;
           attribute DOMString hreflang;
           attribute DOMString type;
  [PutForwards=value] readonly attribute <ref>DOMSettableTokenList</ref> sizes;
};
<ref>HTMLLinkElement</ref> implements <ref>LinkStyle</ref>;
interface HTMLMetaElement : <ref>HTMLElement</ref> {
           attribute DOMString name;
           attribute DOMString httpEquiv;
           attribute DOMString content;
};
interface HTMLStyleElement : <ref>HTMLElement</ref> {
           attribute boolean disabled;
           attribute DOMString media;
           attribute DOMString type;
           attribute boolean scoped;
};
<ref>HTMLStyleElement</ref> implements <ref>LinkStyle</ref>;
interface HTMLScriptElement : <ref>HTMLElement</ref> {
           attribute DOMString src;
           attribute DOMString type;
           attribute DOMString charset;
           attribute boolean async;
           attribute boolean defer;
           attribute DOMString crossOrigin;
           attribute DOMString text;
};
interface HTMLBodyElement : <ref>HTMLElement</ref> {
};
<ref>HTMLBodyElement</ref> implements <ref>WindowEventHandlers</ref>;
interface HTMLHeadingElement : <ref>HTMLElement</ref> {};
interface HTMLParagraphElement : <ref>HTMLElement</ref> {};
interface HTMLHRElement : <ref>HTMLElement</ref> {};
interface HTMLPreElement : <ref>HTMLElement</ref> {};
interface HTMLQuoteElement : <ref>HTMLElement</ref> {
           attribute DOMString cite;
};
interface HTMLOListElement : <ref>HTMLElement</ref> {
           attribute boolean reversed;
           attribute long start;
           attribute DOMString type;
};
interface HTMLUListElement : <ref>HTMLElement</ref> {};
interface HTMLLIElement : <ref>HTMLElement</ref> {
           attribute long value;
};
interface HTMLDListElement : <ref>HTMLElement</ref> {};
interface HTMLDivElement : <ref>HTMLElement</ref> {};
interface HTMLAnchorElement : <ref>HTMLElement</ref> {
           attribute DOMString target;
           attribute DOMString download;

           attribute DOMString rel;
  readonly attribute <ref>DOMTokenList</ref> relList;
           attribute DOMString hreflang;
           attribute DOMString type;

           attribute DOMString text;
};
<ref>HTMLAnchorElement</ref> implements <ref>URLUtils</ref>;
interface HTMLDataElement : <ref>HTMLElement</ref> {
           attribute DOMString value;
};
interface HTMLTimeElement : <ref>HTMLElement</ref> {
           attribute DOMString dateTime;
};
interface HTMLSpanElement : <ref>HTMLElement</ref> {};
interface HTMLBRElement : <ref>HTMLElement</ref> {};
interface HTMLModElement : <ref>HTMLElement</ref> {
           attribute DOMString cite;
           attribute DOMString dateTime;
};
[NamedConstructor=Image(optional unsigned long width, optional unsigned long height)]
interface HTMLImageElement : <ref>HTMLElement</ref> {
           attribute DOMString alt;
           attribute DOMString src;

           attribute DOMString crossOrigin;
           attribute DOMString useMap;
           attribute boolean isMap;
           attribute unsigned long width;
           attribute unsigned long height;
  readonly attribute unsigned long naturalWidth;
  readonly attribute unsigned long naturalHeight;
  readonly attribute boolean complete;
};
interface HTMLIFrameElement : <ref>HTMLElement</ref> {
           attribute DOMString src;
           attribute DOMString srcdoc;
           attribute DOMString name;
  [PutForwards=value] readonly attribute <ref>DOMSettableTokenList</ref> sandbox;
           attribute boolean seamless;
           attribute boolean allowFullscreen;
           attribute DOMString width;
           attribute DOMString height;
  readonly attribute <ref>Document</ref>? contentDocument;
  readonly attribute <ref>WindowProxy</ref>? contentWindow;
};
interface HTMLEmbedElement : <ref>HTMLElement</ref> {
           attribute DOMString src;
           attribute DOMString type;
           attribute DOMString width;
           attribute DOMString height;
  legacycaller any (any... arguments);
};
interface HTMLObjectElement : <ref>HTMLElement</ref> {
           attribute DOMString data;
           attribute DOMString type;
           attribute boolean typeMustMatch;
           attribute DOMString name;
           attribute DOMString useMap;
  readonly attribute <ref>HTMLFormElement</ref>? form;
           attribute DOMString width;
           attribute DOMString height;
  readonly attribute <ref>Document</ref>? contentDocument;
  readonly attribute <ref>WindowProxy</ref>? contentWindow;

  readonly attribute boolean willValidate;
  readonly attribute <ref>ValidityState</ref> validity;
  readonly attribute DOMString validationMessage;
  boolean checkValidity();
  void setCustomValidity(DOMString error);

  legacycaller any (any... arguments);
};
interface HTMLParamElement : <ref>HTMLElement</ref> {
           attribute DOMString name;
           attribute DOMString value;
};
interface HTMLVideoElement : <ref>HTMLMediaElement</ref> {
           attribute unsigned long width;
           attribute unsigned long height;
  readonly attribute unsigned long videoWidth;
  readonly attribute unsigned long videoHeight;
           attribute DOMString poster;
};
[NamedConstructor=Audio(optional DOMString src)]
interface HTMLAudioElement : <ref>HTMLMediaElement</ref> {};
interface HTMLSourceElement : <ref>HTMLElement</ref> {
           attribute DOMString src;
           attribute DOMString type;
           attribute DOMString media;
};
interface HTMLTrackElement : <ref>HTMLElement</ref> {
           attribute <ref>TextTrackKind</ref> kind;
           attribute DOMString src;
           attribute DOMString srclang;
           attribute DOMString label;
           attribute boolean default;

  const unsigned short NONE = 0;
  const unsigned short LOADING = 1;
  const unsigned short LOADED = 2;
  const unsigned short ERROR = 3;
  readonly attribute unsigned short readyState;

  readonly attribute <ref>TextTrack</ref> track;
};
enum CanPlayTypeEnum { &quot;&quot; , &quot;maybe&quot;, &quot;probably&quot; };
interface HTMLMediaElement : <ref>HTMLElement</ref> {

  readonly attribute <ref>MediaError</ref>? error;

           attribute DOMString src;
  readonly attribute DOMString currentSrc;
           attribute DOMString crossOrigin;
  const unsigned short NETWORK_EMPTY = 0;
  const unsigned short NETWORK_IDLE = 1;
  const unsigned short NETWORK_LOADING = 2;
  const unsigned short NETWORK_NO_SOURCE = 3;
  readonly attribute unsigned short networkState;
           attribute DOMString preload;
  readonly attribute <ref>TimeRanges</ref> buffered;
  void load();
  <ref>CanPlayTypeEnum</ref> canPlayType(DOMString type);

  const unsigned short HAVE_NOTHING = 0;
  const unsigned short HAVE_METADATA = 1;
  const unsigned short HAVE_CURRENT_DATA = 2;
  const unsigned short HAVE_FUTURE_DATA = 3;
  const unsigned short HAVE_ENOUGH_DATA = 4;
  readonly attribute unsigned short readyState;
  readonly attribute boolean seeking;

           attribute double currentTime;
  void fastSeek(double time);
  readonly attribute unrestricted double duration;
  readonly attribute Date startDate;
  readonly attribute boolean paused;
           attribute double defaultPlaybackRate;
           attribute double playbackRate;
  readonly attribute <ref>TimeRanges</ref> played;
  readonly attribute <ref>TimeRanges</ref> seekable;
  readonly attribute boolean ended;
           attribute boolean autoplay;
           attribute boolean loop;
  void play();
  void pause();

           attribute DOMString mediaGroup;
           attribute <ref>MediaController</ref>? controller;

           attribute boolean controls;
           attribute double volume;
           attribute boolean muted;
           attribute boolean defaultMuted;

  readonly attribute <ref>AudioTrackList</ref> audioTracks;
  readonly attribute <ref>VideoTrackList</ref> videoTracks;
  readonly attribute <ref>TextTrackList</ref> textTracks;
  <ref>TextTrack</ref> addTextTrack(<ref>TextTrackKind</ref> kind, optional DOMString label = &quot;&quot;, optional DOMString language = &quot;&quot;);
};
interface MediaError {
  const unsigned short MEDIA_ERR_ABORTED = 1;
  const unsigned short MEDIA_ERR_NETWORK = 2;
  const unsigned short MEDIA_ERR_DECODE = 3;
  const unsigned short MEDIA_ERR_SRC_NOT_SUPPORTED = 4;
  readonly attribute unsigned short code;
};
interface AudioTrackList : <ref>EventTarget</ref> {
  readonly attribute unsigned long length;
  getter <ref>AudioTrack</ref> (unsigned long index);
  <ref>AudioTrack</ref>? getTrackById(DOMString id);

           attribute <ref>EventHandler</ref> onchange;
           attribute <ref>EventHandler</ref> onaddtrack;
           attribute <ref>EventHandler</ref> onremovetrack;
};

interface AudioTrack {
  readonly attribute DOMString id;
  readonly attribute DOMString kind;
  readonly attribute DOMString label;
  readonly attribute DOMString language;
           attribute boolean enabled;
};

interface VideoTrackList : <ref>EventTarget</ref> {
  readonly attribute unsigned long length;
  getter <ref>VideoTrack</ref> (unsigned long index);
  <ref>VideoTrack</ref>? getTrackById(DOMString id);
  readonly attribute long selectedIndex;

           attribute <ref>EventHandler</ref> onchange;
           attribute <ref>EventHandler</ref> onaddtrack;
           attribute <ref>EventHandler</ref> onremovetrack;
};

interface VideoTrack {
  readonly attribute DOMString id;
  readonly attribute DOMString kind;
  readonly attribute DOMString label;
  readonly attribute DOMString language;
           attribute boolean selected;
};
enum MediaControllerPlaybackState { &quot;waiting&quot;, &quot;playing&quot;, &quot;ended&quot; };
[Constructor]
interface MediaController : <ref>EventTarget</ref> {
  readonly attribute unsigned short readyState; 

  readonly attribute <ref>TimeRanges</ref> buffered;
  readonly attribute <ref>TimeRanges</ref> seekable;
  readonly attribute unrestricted double duration;
           attribute double currentTime;

  readonly attribute boolean paused;
  readonly attribute <ref>MediaControllerPlaybackState</ref> playbackState;
  readonly attribute <ref>TimeRanges</ref> played;
  void pause();
  void unpause();
  void play(); 

           attribute double defaultPlaybackRate;
           attribute double playbackRate;

           attribute double volume;
           attribute boolean muted;

           attribute <ref>EventHandler</ref> onemptied;
           attribute <ref>EventHandler</ref> onloadedmetadata;
           attribute <ref>EventHandler</ref> onloadeddata;
           attribute <ref>EventHandler</ref> oncanplay;
           attribute <ref>EventHandler</ref> oncanplaythrough;
           attribute <ref>EventHandler</ref> onplaying;
           attribute <ref>EventHandler</ref> onended;
           attribute <ref>EventHandler</ref> onwaiting;

           attribute <ref>EventHandler</ref> ondurationchange;
           attribute <ref>EventHandler</ref> ontimeupdate;
           attribute <ref>EventHandler</ref> onplay;
           attribute <ref>EventHandler</ref> onpause;
           attribute <ref>EventHandler</ref> onratechange;
           attribute <ref>EventHandler</ref> onvolumechange;
};
interface TextTrackList : <ref>EventTarget</ref> {
  readonly attribute unsigned long length;
  getter <ref>TextTrack</ref> (unsigned long index);

           attribute <ref>EventHandler</ref> onaddtrack;
           attribute <ref>EventHandler</ref> onremovetrack;
};
enum TextTrackMode { &quot;disabled&quot;,  &quot;hidden&quot;,  &quot;showing&quot; };
enum TextTrackKind { &quot;subtitles&quot;,  &quot;captions&quot;,  &quot;descriptions&quot;,  &quot;chapters&quot;,  &quot;metadata&quot; };
interface TextTrack : <ref>EventTarget</ref> {
  readonly attribute <ref>TextTrackKind</ref> kind;
  readonly attribute DOMString label;
  readonly attribute DOMString language;
  readonly attribute DOMString inBandMetadataTrackDispatchType;

           attribute <ref>TextTrackMode</ref> mode;

  readonly attribute <ref>TextTrackCueList</ref>? cues;
  readonly attribute <ref>TextTrackCueList</ref>? activeCues;

  void addCue(<ref>TextTrackCue</ref> cue);
  void removeCue(<ref>TextTrackCue</ref> cue);

           attribute <ref>EventHandler</ref> oncuechange;
};
interface TextTrackCueList {
  readonly attribute unsigned long length;
  getter <ref>TextTrackCue</ref> (unsigned long index);
  <ref>TextTrackCue</ref>? getCueById(DOMString id);
};
interface TextTrackCue : <ref>EventTarget</ref> {
  readonly attribute <ref>TextTrack</ref>? track;

           attribute DOMString id;
           attribute double startTime;
           attribute double endTime;
           attribute boolean pauseOnExit;

           attribute <ref>EventHandler</ref> onenter;
           attribute <ref>EventHandler</ref> onexit;
};
interface TimeRanges {
  readonly attribute unsigned long length;
  double start(unsigned long index);
  double end(unsigned long index);
};
[Constructor(DOMString type, optional <ref>TrackEventInit</ref> eventInitDict)]
interface TrackEvent : <ref>Event</ref> {
  readonly attribute object? track;
};

dictionary TrackEventInit : <ref>EventInit</ref> {
  object? track;
};
typedef (<ref>CanvasRenderingContext2D</ref> or <ref>WebGLRenderingContext</ref>) RenderingContext;

interface HTMLCanvasElement : <ref>HTMLElement</ref> {
           attribute unsigned long width;
           attribute unsigned long height;

  <ref>RenderingContext</ref>? getContext(DOMString contextId, any... arguments);
  boolean supportsContext(DOMString contextId, any... arguments);

  void setContext(<ref>RenderingContext</ref> context);
  <ref>CanvasProxy</ref> transferControlToProxy();

  DOMString toDataURL(optional DOMString type, any... arguments);
  void toBlob(<ref>FileCallback</ref>? _callback, optional DOMString type, any... arguments);
};
interface CanvasProxy {
  void setContext(<ref>RenderingContext</ref> context);
};
<ref>CanvasProxy</ref> implements <ref>Transferable</ref>;
interface HTMLMapElement : <ref>HTMLElement</ref> {
           attribute DOMString name;
  readonly attribute <ref>HTMLCollection</ref> areas;
  readonly attribute <ref>HTMLCollection</ref> images;
};
interface HTMLAreaElement : <ref>HTMLElement</ref> {
           attribute DOMString alt;
           attribute DOMString coords;
           attribute DOMString shape;
           attribute DOMString target;
           attribute DOMString download;

           attribute DOMString rel;
  readonly attribute <ref>DOMTokenList</ref> relList;
           attribute DOMString hreflang;
           attribute DOMString type;
};
<ref>HTMLAreaElement</ref> implements <ref>URLUtils</ref>;
interface HTMLTableElement : <ref>HTMLElement</ref> {
           attribute <ref>HTMLTableCaptionElement</ref>? caption;
  <ref>HTMLElement</ref> createCaption();
  void deleteCaption();
           attribute <ref>HTMLTableSectionElement</ref>? tHead;
  <ref>HTMLElement</ref> createTHead();
  void deleteTHead();
           attribute <ref>HTMLTableSectionElement</ref>? tFoot;
  <ref>HTMLElement</ref> createTFoot();
  void deleteTFoot();
  readonly attribute <ref>HTMLCollection</ref> tBodies;
  <ref>HTMLElement</ref> createTBody();
  readonly attribute <ref>HTMLCollection</ref> rows;
  <ref>HTMLElement</ref> insertRow(optional long index = -1);
  void deleteRow(long index);
           attribute DOMString border;
           attribute boolean sortable;
  void stopSorting();
};
interface HTMLTableCaptionElement : <ref>HTMLElement</ref> {};
interface HTMLTableColElement : <ref>HTMLElement</ref> {
           attribute unsigned long span;
};
interface HTMLTableSectionElement : <ref>HTMLElement</ref> {
  readonly attribute <ref>HTMLCollection</ref> rows;
  <ref>HTMLElement</ref> insertRow(optional long index = -1);
  void deleteRow(long index);
};
interface HTMLTableRowElement : <ref>HTMLElement</ref> {
  readonly attribute long rowIndex;
  readonly attribute long sectionRowIndex;
  readonly attribute <ref>HTMLCollection</ref> cells;
  <ref>HTMLElement</ref> insertCell(optional long index = -1);
  void deleteCell(long index);
};
interface HTMLTableDataCellElement : <ref>HTMLTableCellElement</ref> {};
interface HTMLTableHeaderCellElement : <ref>HTMLTableCellElement</ref> {
           attribute DOMString scope;
           attribute DOMString abbr;
           attribute DOMString sorted;
  void sort();
};
interface HTMLTableCellElement : <ref>HTMLElement</ref> {
           attribute unsigned long colSpan;
           attribute unsigned long rowSpan;
  [PutForwards=value] readonly attribute <ref>DOMSettableTokenList</ref> headers;
  readonly attribute long cellIndex;
};
[OverrideBuiltins]
interface HTMLFormElement : <ref>HTMLElement</ref> {
           attribute DOMString acceptCharset;
           attribute DOMString action;
           attribute DOMString autocomplete;
           attribute DOMString enctype;
           attribute DOMString encoding;
           attribute DOMString method;
           attribute DOMString name;
           attribute boolean noValidate;
           attribute DOMString target;

  readonly attribute <ref>HTMLFormControlsCollection</ref> elements;
  readonly attribute long length;
  getter <ref>Element</ref> (unsigned long index);
  getter object (DOMString name);

  void submit();
  void reset();
  boolean checkValidity();
};
interface HTMLFieldSetElement : <ref>HTMLElement</ref> {
           attribute boolean disabled;
  readonly attribute <ref>HTMLFormElement</ref>? form;
           attribute DOMString name;

  readonly attribute DOMString type;

  readonly attribute <ref>HTMLFormControlsCollection</ref> elements;

  readonly attribute boolean willValidate;
  readonly attribute <ref>ValidityState</ref> validity;
  readonly attribute DOMString validationMessage;
  boolean checkValidity();
  void setCustomValidity(DOMString error);
};
interface HTMLLegendElement : <ref>HTMLElement</ref> {
  readonly attribute <ref>HTMLFormElement</ref>? form;
};
interface HTMLLabelElement : <ref>HTMLElement</ref> {
  readonly attribute <ref>HTMLFormElement</ref>? form;
           attribute DOMString htmlFor;
  readonly attribute <ref>HTMLElement</ref>? control;
};
interface HTMLInputElement : <ref>HTMLElement</ref> {
           attribute DOMString accept;
           attribute DOMString alt;
           attribute DOMString autocomplete;
           attribute boolean autofocus;
           attribute boolean defaultChecked;
           attribute boolean checked;
           attribute DOMString dirName;
           attribute boolean disabled;
  readonly attribute <ref>HTMLFormElement</ref>? form;
  readonly attribute <ref>FileList</ref>? files;
           attribute DOMString formAction;
           attribute DOMString formEnctype;
           attribute DOMString formMethod;
           attribute boolean formNoValidate;
           attribute DOMString formTarget;
           attribute unsigned long height;
           attribute boolean indeterminate;
           attribute DOMString inputMode;
  readonly attribute <ref>HTMLElement</ref>? list;
           attribute DOMString max;
           attribute long maxLength;
           attribute DOMString min;
           attribute boolean multiple;
           attribute DOMString name;
           attribute DOMString pattern;
           attribute DOMString placeholder;
           attribute boolean readOnly;
           attribute boolean required;
           attribute unsigned long size;
           attribute DOMString src;
           attribute DOMString step;
           attribute DOMString type;
           attribute DOMString defaultValue;
  [TreatNullAs=EmptyString] attribute DOMString value;
           attribute Date? valueAsDate;
           attribute unrestricted double valueAsNumber;
           attribute unsigned long width;

  void stepUp(optional long n = 1);
  void stepDown(optional long n = 1);

  readonly attribute boolean willValidate;
  readonly attribute <ref>ValidityState</ref> validity;
  readonly attribute DOMString validationMessage;
  boolean checkValidity();
  void setCustomValidity(DOMString error);

  readonly attribute <ref>NodeList</ref> labels;

  void select();
           attribute unsigned long selectionStart;
           attribute unsigned long selectionEnd;
           attribute DOMString selectionDirection;
  void setRangeText(DOMString replacement);
  void setRangeText(DOMString replacement, unsigned long start, unsigned long end, optional <ref>SelectionMode</ref> selectionMode);
  void setSelectionRange(unsigned long start, unsigned long end, optional DOMString direction);
};
interface HTMLButtonElement : <ref>HTMLElement</ref> {
           attribute boolean autofocus;
           attribute boolean disabled;
  readonly attribute <ref>HTMLFormElement</ref>? form;
           attribute DOMString formAction;
           attribute DOMString formEnctype;
           attribute DOMString formMethod;
           attribute boolean formNoValidate;
           attribute DOMString formTarget;
           attribute DOMString name;
           attribute DOMString type;
           attribute DOMString value;
           attribute <ref>HTMLMenuElement</ref>? menu;

  readonly attribute boolean willValidate;
  readonly attribute <ref>ValidityState</ref> validity;
  readonly attribute DOMString validationMessage;
  boolean checkValidity();
  void setCustomValidity(DOMString error);

  readonly attribute <ref>NodeList</ref> labels;
};
interface HTMLSelectElement : <ref>HTMLElement</ref> {
           attribute boolean autofocus;
           attribute boolean disabled;
  readonly attribute <ref>HTMLFormElement</ref>? form;
           attribute boolean multiple;
           attribute DOMString name;
           attribute boolean required;
           attribute unsigned long size;

  readonly attribute DOMString type;

  readonly attribute <ref>HTMLOptionsCollection</ref> options;
           attribute unsigned long length;
  getter <ref>Element</ref> item(unsigned long index);
  object namedItem(DOMString name);
  void add((<ref>HTMLOptionElement</ref> or <ref>HTMLOptGroupElement</ref>) element, optional (<ref>HTMLElement</ref> or long)? before = null);
  void remove(long index);
  setter creator void (unsigned long index, <ref>HTMLOptionElement</ref>? option);

  readonly attribute <ref>HTMLCollection</ref> selectedOptions;
           attribute long selectedIndex;
           attribute DOMString value;

  readonly attribute boolean willValidate;
  readonly attribute <ref>ValidityState</ref> validity;
  readonly attribute DOMString validationMessage;
  boolean checkValidity();
  void setCustomValidity(DOMString error);

  readonly attribute <ref>NodeList</ref> labels;
};
interface HTMLDataListElement : <ref>HTMLElement</ref> {
  readonly attribute <ref>HTMLCollection</ref> options;
};
interface HTMLOptGroupElement : <ref>HTMLElement</ref> {
           attribute boolean disabled;
           attribute DOMString label;
};
[NamedConstructor=Option(optional DOMString text = &quot;&quot;, optional DOMString value, optional boolean defaultSelected = false, optional boolean selected = false)]
interface HTMLOptionElement : <ref>HTMLElement</ref> {
           attribute boolean disabled;
  readonly attribute <ref>HTMLFormElement</ref>? form;
           attribute DOMString label;
           attribute boolean defaultSelected;
           attribute boolean selected;
           attribute DOMString value;

           attribute DOMString text;
  readonly attribute long index;
};
interface HTMLTextAreaElement : <ref>HTMLElement</ref> {
           attribute DOMString autocomplete;
           attribute boolean autofocus;
           attribute unsigned long cols;
           attribute DOMString dirName;
           attribute boolean disabled;
  readonly attribute <ref>HTMLFormElement</ref>? form;
           attribute DOMString inputMode;
           attribute long maxLength;
           attribute DOMString name;
           attribute DOMString placeholder;
           attribute boolean readOnly;
           attribute boolean required;
           attribute unsigned long rows;
           attribute DOMString wrap;

  readonly attribute DOMString type;
           attribute DOMString defaultValue;
  [TreatNullAs=EmptyString] attribute DOMString value;
  readonly attribute unsigned long textLength;

  readonly attribute boolean willValidate;
  readonly attribute <ref>ValidityState</ref> validity;
  readonly attribute DOMString validationMessage;
  boolean checkValidity();
  void setCustomValidity(DOMString error);

  readonly attribute <ref>NodeList</ref> labels;

  void select();
           attribute unsigned long selectionStart;
           attribute unsigned long selectionEnd;
           attribute DOMString selectionDirection;
  void setRangeText(DOMString replacement);
  void setRangeText(DOMString replacement, unsigned long start, unsigned long end, optional <ref>SelectionMode</ref> selectionMode);
  void setSelectionRange(unsigned long start, unsigned long end, optional DOMString direction);
};
interface HTMLKeygenElement : <ref>HTMLElement</ref> {
           attribute boolean autofocus;
           attribute DOMString challenge;
           attribute boolean disabled;
  readonly attribute <ref>HTMLFormElement</ref>? form;
           attribute DOMString keytype;
           attribute DOMString name;

  readonly attribute DOMString type;

  readonly attribute boolean willValidate;
  readonly attribute <ref>ValidityState</ref> validity;
  readonly attribute DOMString validationMessage;
  boolean checkValidity();
  void setCustomValidity(DOMString error);

  readonly attribute <ref>NodeList</ref> labels;
};
interface HTMLOutputElement : <ref>HTMLElement</ref> {
  [PutForwards=value] readonly attribute <ref>DOMSettableTokenList</ref> htmlFor;
  readonly attribute <ref>HTMLFormElement</ref>? form;
           attribute DOMString name;

  readonly attribute DOMString type;
           attribute DOMString defaultValue;
           attribute DOMString value;

  readonly attribute boolean willValidate;
  readonly attribute <ref>ValidityState</ref> validity;
  readonly attribute DOMString validationMessage;
  boolean checkValidity();
  void setCustomValidity(DOMString error);

  readonly attribute <ref>NodeList</ref> labels;
};
interface HTMLProgressElement : <ref>HTMLElement</ref> {
           attribute double value;
           attribute double max;
  readonly attribute double position;
  readonly attribute <ref>NodeList</ref> labels;
};
interface HTMLMeterElement : <ref>HTMLElement</ref> {
           attribute double value;
           attribute double min;
           attribute double max;
           attribute double low;
           attribute double high;
           attribute double optimum;
  readonly attribute <ref>NodeList</ref> labels;
};
enum SelectionMode {
  &quot;select&quot;,
  &quot;start&quot;,
  &quot;end&quot;,
  &quot;preserve&quot;,
};
interface ValidityState {
  readonly attribute boolean valueMissing;
  readonly attribute boolean typeMismatch;
  readonly attribute boolean patternMismatch;
  readonly attribute boolean tooLong;
  readonly attribute boolean rangeUnderflow;
  readonly attribute boolean rangeOverflow;
  readonly attribute boolean stepMismatch;
  readonly attribute boolean badInput;
  readonly attribute boolean customError;
  readonly attribute boolean valid;
};
interface HTMLDetailsElement : <ref>HTMLElement</ref> {
           attribute boolean open;
};
interface HTMLMenuElement : <ref>HTMLElement</ref> {
           attribute DOMString type;
           attribute DOMString label;
};
interface HTMLMenuItemElement : <ref>HTMLElement</ref> {
           attribute DOMString type;
           attribute DOMString label;
           attribute DOMString icon;
           attribute boolean disabled;
           attribute boolean checked;
           attribute DOMString radiogroup;
           attribute boolean default;
  readonly attribute <ref>HTMLElement</ref>? command;
};
[Constructor(DOMString type, optional <ref>RelatedEventInit</ref> eventInitDict)]
interface RelatedEvent : <ref>Event</ref> {
  readonly attribute <ref>EventTarget</ref>? relatedTarget;
};

dictionary RelatedEventInit : <ref>EventInit</ref> {
  <ref>EventTarget</ref>? relatedTarget;
};
interface HTMLDialogElement : <ref>HTMLElement</ref> {
           attribute boolean open;
           attribute DOMString returnValue;
  void show(optional (<ref>MouseEvent</ref> or <ref>Element</ref>) anchor);
  void showModal(optional (<ref>MouseEvent</ref> or <ref>Element</ref>) anchor);
  void close(optional DOMString returnValue);
};
[NamedPropertiesObject]
interface Window : <ref>EventTarget</ref> {
  [Unforgeable] readonly attribute <ref>WindowProxy</ref> window;
  [Replaceable] readonly attribute <ref>WindowProxy</ref> self;
  [Unforgeable] readonly attribute <ref>Document</ref> document;
           attribute DOMString name; 
  [PutForwards=href, Unforgeable] readonly attribute <ref>Location</ref> location;
  readonly attribute <ref>History</ref> history;
  [Replaceable] readonly attribute <ref>BarProp</ref> locationbar;
  [Replaceable] readonly attribute <ref>BarProp</ref> menubar;
  [Replaceable] readonly attribute <ref>BarProp</ref> personalbar;
  [Replaceable] readonly attribute <ref>BarProp</ref> scrollbars;
  [Replaceable] readonly attribute <ref>BarProp</ref> statusbar;
  [Replaceable] readonly attribute <ref>BarProp</ref> toolbar;
           attribute DOMString status;
  void close();
  void stop();
  void focus();
  void blur();

  [Replaceable] readonly attribute <ref>WindowProxy</ref> frames;
  [Replaceable] readonly attribute unsigned long length;
  [Unforgeable] readonly attribute <ref>WindowProxy</ref> top;
           attribute <ref>WindowProxy</ref>? opener;
  readonly attribute <ref>WindowProxy</ref> parent;
  readonly attribute <ref>Element</ref>? frameElement;
  <ref>WindowProxy</ref> open(optional DOMString url = &quot;about:blank&quot;, optional DOMString target = &quot;_blank&quot;, optional DOMString features = &quot;&quot;, optional boolean replace = false);
  getter <ref>WindowProxy</ref> (unsigned long index);
  getter object (DOMString name);

  readonly attribute <ref>Navigator</ref> navigator; 
  readonly attribute <ref>External</ref> external;
  readonly attribute <ref>ApplicationCache</ref> applicationCache;

  void alert(optional DOMString message = &quot;&quot;);
  boolean confirm(optional DOMString message = &quot;&quot;);
  DOMString? prompt(optional DOMString message = &quot;&quot;, optional DOMString default = &quot;&quot;);
  void print();
  any showModalDialog(DOMString url, optional any argument);


};
<ref>Window</ref> implements <ref>GlobalEventHandlers</ref>;
<ref>Window</ref> implements <ref>WindowEventHandlers</ref>;
interface BarProp {
           attribute boolean visible;
};
interface History {
  readonly attribute long length;
  readonly attribute any state;
  void go(optional long delta);
  void back();
  void forward();
  void pushState(any data, DOMString title, optional DOMString? url = null);
  void replaceState(any data, DOMString title, optional DOMString? url = null);
};
[Unforgeable] interface Location {
  void assign(DOMString url);
  void replace(DOMString url);
  void reload();
};
<ref>Location</ref> implements <ref>URLUtils</ref>;
[Constructor(DOMString type, optional <ref>PopStateEventInit</ref> eventInitDict)]
interface PopStateEvent : <ref>Event</ref> {
  readonly attribute any state;
};

dictionary PopStateEventInit : <ref>EventInit</ref> {
  any state;
};
[Constructor(DOMString type, optional <ref>HashChangeEventInit</ref> eventInitDict)]
interface HashChangeEvent : <ref>Event</ref> {
  readonly attribute DOMString oldURL;
  readonly attribute DOMString newURL;
};

dictionary HashChangeEventInit : <ref>EventInit</ref> {
  DOMString oldURL;
  DOMString newURL;
};
[Constructor(DOMString type, optional <ref>PageTransitionEventInit</ref> eventInitDict)]
interface PageTransitionEvent : <ref>Event</ref> {
  readonly attribute boolean persisted;
};

dictionary PageTransitionEventInit : <ref>EventInit</ref> {
  boolean persisted;
};
interface BeforeUnloadEvent : <ref>Event</ref> {
           attribute DOMString returnValue;
};
interface ApplicationCache : <ref>EventTarget</ref> {

  const unsigned short UNCACHED = 0;
  const unsigned short IDLE = 1;
  const unsigned short CHECKING = 2;
  const unsigned short DOWNLOADING = 3;
  const unsigned short UPDATEREADY = 4;
  const unsigned short OBSOLETE = 5;
  readonly attribute unsigned short status;

  void update();
  void abort();
  void swapCache();

           attribute <ref>EventHandler</ref> onchecking;
           attribute <ref>EventHandler</ref> onerror;
           attribute <ref>EventHandler</ref> onnoupdate;
           attribute <ref>EventHandler</ref> ondownloading;
           attribute <ref>EventHandler</ref> onprogress;
           attribute <ref>EventHandler</ref> onupdateready;
           attribute <ref>EventHandler</ref> oncached;
           attribute <ref>EventHandler</ref> onobsolete;
};
[NoInterfaceObject]
interface NavigatorOnLine {
  readonly attribute boolean onLine;
};
[TreatNonCallableAsNull]
callback EventHandlerNonNull = any (<ref>Event</ref> event);
typedef <ref>EventHandlerNonNull</ref>? EventHandler;
[TreatNonCallableAsNull]
callback OnErrorEventHandlerNonNull = any ((<ref>Event</ref> or DOMString) event, optional DOMString source, optional unsigned long lineno, optional unsigned long column);
typedef <ref>OnErrorEventHandlerNonNull</ref>? OnErrorEventHandler;
[NoInterfaceObject]
interface GlobalEventHandlers {
           attribute <ref>EventHandler</ref> onabort;
           attribute <ref>EventHandler</ref> onblur;
           attribute <ref>OnErrorEventHandler</ref> onerror;
           attribute <ref>EventHandler</ref> onfocus;
           attribute <ref>EventHandler</ref> oncancel;
           attribute <ref>EventHandler</ref> oncanplay;
           attribute <ref>EventHandler</ref> oncanplaythrough;
           attribute <ref>EventHandler</ref> onchange;
           attribute <ref>EventHandler</ref> onclick;
           attribute <ref>EventHandler</ref> onclose;
           attribute <ref>EventHandler</ref> oncontextmenu;
           attribute <ref>EventHandler</ref> oncuechange;
           attribute <ref>EventHandler</ref> ondblclick;
           attribute <ref>EventHandler</ref> ondrag;
           attribute <ref>EventHandler</ref> ondragend;
           attribute <ref>EventHandler</ref> ondragenter;
           attribute <ref>EventHandler</ref> ondragexit;
           attribute <ref>EventHandler</ref> ondragleave;
           attribute <ref>EventHandler</ref> ondragover;
           attribute <ref>EventHandler</ref> ondragstart;
           attribute <ref>EventHandler</ref> ondrop;
           attribute <ref>EventHandler</ref> ondurationchange;
           attribute <ref>EventHandler</ref> onemptied;
           attribute <ref>EventHandler</ref> onended;
           attribute <ref>EventHandler</ref> oninput;
           attribute <ref>EventHandler</ref> oninvalid;
           attribute <ref>EventHandler</ref> onkeydown;
           attribute <ref>EventHandler</ref> onkeypress;
           attribute <ref>EventHandler</ref> onkeyup;
           attribute <ref>EventHandler</ref> onload;
           attribute <ref>EventHandler</ref> onloadeddata;
           attribute <ref>EventHandler</ref> onloadedmetadata;
           attribute <ref>EventHandler</ref> onloadstart;
           attribute <ref>EventHandler</ref> onmousedown;
  [LenientThis] attribute <ref>EventHandler</ref> onmouseenter;
  [LenientThis] attribute <ref>EventHandler</ref> onmouseleave;
           attribute <ref>EventHandler</ref> onmousemove;
           attribute <ref>EventHandler</ref> onmouseout;
           attribute <ref>EventHandler</ref> onmouseover;
           attribute <ref>EventHandler</ref> onmouseup;
           attribute <ref>EventHandler</ref> onmousewheel;
           attribute <ref>EventHandler</ref> onpause;
           attribute <ref>EventHandler</ref> onplay;
           attribute <ref>EventHandler</ref> onplaying;
           attribute <ref>EventHandler</ref> onprogress;
           attribute <ref>EventHandler</ref> onratechange;
           attribute <ref>EventHandler</ref> onreset;
           attribute <ref>EventHandler</ref> onscroll;
           attribute <ref>EventHandler</ref> onseeked;
           attribute <ref>EventHandler</ref> onseeking;
           attribute <ref>EventHandler</ref> onselect;
           attribute <ref>EventHandler</ref> onshow;
           attribute <ref>EventHandler</ref> onsort;
           attribute <ref>EventHandler</ref> onstalled;
           attribute <ref>EventHandler</ref> onsubmit;
           attribute <ref>EventHandler</ref> onsuspend;
           attribute <ref>EventHandler</ref> ontimeupdate;
           attribute <ref>EventHandler</ref> onvolumechange;
           attribute <ref>EventHandler</ref> onwaiting;
};

[NoInterfaceObject]
interface WindowEventHandlers {
           attribute <ref>EventHandler</ref> onafterprint;
           attribute <ref>EventHandler</ref> onbeforeprint;
           attribute <ref>EventHandler</ref> onbeforeunload;
           attribute <ref>EventHandler</ref> onfullscreenchange;
           attribute <ref>EventHandler</ref> onfullscreenerror;
           attribute <ref>EventHandler</ref> onhashchange;
           attribute <ref>EventHandler</ref> onmessage;
           attribute <ref>EventHandler</ref> onoffline;
           attribute <ref>EventHandler</ref> ononline;
           attribute <ref>EventHandler</ref> onpagehide;
           attribute <ref>EventHandler</ref> onpageshow;
           attribute <ref>EventHandler</ref> onpopstate;
           attribute <ref>EventHandler</ref> onresize;
           attribute <ref>EventHandler</ref> onstorage;
           attribute <ref>EventHandler</ref> onunload;
};
[NoInterfaceObject]
interface WindowBase64 {
  DOMString btoa(DOMString btoa);
  DOMString atob(DOMString atob);
};
<ref>Window</ref> implements <ref>WindowBase64</ref>;
[NoInterfaceObject]
interface WindowTimers {
  long setTimeout(<ref>Function</ref> handler, optional long timeout, any... arguments);
  long setTimeout(DOMString handler, optional long timeout, any... arguments);
  void clearTimeout(long handle);
  long setInterval(<ref>Function</ref> handler, optional long timeout, any... arguments);
  long setInterval(DOMString handler, optional long timeout, any... arguments);
  void clearInterval(long handle);
};
<ref>Window</ref> implements <ref>WindowTimers</ref>;
[NoInterfaceObject] interface WindowModal {
  readonly attribute any dialogArguments;
           attribute DOMString returnValue;
};
interface Navigator {
};
<ref>Navigator</ref> implements <ref>NavigatorID</ref>;
<ref>Navigator</ref> implements <ref>NavigatorLanguage</ref>;
<ref>Navigator</ref> implements <ref>NavigatorOnLine</ref>;
<ref>Navigator</ref> implements <ref>NavigatorContentUtils</ref>;
<ref>Navigator</ref> implements <ref>NavigatorStorageUtils</ref>;
[NoInterfaceObject]
interface NavigatorID {
  readonly attribute DOMString appName;
  readonly attribute DOMString appVersion;
  readonly attribute DOMString platform;
  readonly attribute DOMString userAgent;

  readonly attribute DOMString product; 
};
[NoInterfaceObject]
interface NavigatorLanguage {
  readonly attribute DOMString? language;
};
[NoInterfaceObject]
interface NavigatorContentUtils {
  void registerProtocolHandler(DOMString scheme, DOMString url, DOMString title);
  void registerContentHandler(DOMString mimeType, DOMString url, DOMString title);
  DOMString isProtocolHandlerRegistered(DOMString scheme, DOMString url);
  DOMString isContentHandlerRegistered(DOMString mimeType, DOMString url);
  void unregisterProtocolHandler(DOMString scheme, DOMString url);
  void unregisterContentHandler(DOMString mimeType, DOMString url);
};
[NoInterfaceObject]
interface NavigatorStorageUtils {
  void yieldForStorageUpdates();
};
interface External {
  void AddSearchProvider(DOMString engineURL);
  unsigned long IsSearchProviderInstalled(DOMString engineURL);
};
interface ImageBitmap {
};

callback ImageBitmapCallback = void (<ref>ImageBitmap</ref> image);

typedef (<ref>HTMLImageElement</ref> or
         <ref>HTMLVideoElement</ref> or
         <ref>HTMLCanvasElement</ref> or
         <ref>Blob</ref> or
         <ref>ImageData</ref> or
         <ref>CanvasRenderingContext2D</ref> or
         <ref>ImageBitmap</ref>) ImageBitmapSource;

[NoInterfaceObject]
interface ImageBitmapFactories {
  void createImageBitmap(<ref>ImageBitmapSource</ref> image, <ref>ImageBitmapCallback</ref> _callback, optional long sx, long sy, long sw, long sh);
};
<ref>Window</ref> implements <ref>ImageBitmapFactories</ref>;
<ref>WorkerGlobalScope</ref> implements <ref>ImageBitmapFactories</ref>;
interface DataTransfer {
           attribute DOMString dropEffect;
           attribute DOMString effectAllowed;

  readonly attribute <ref>DataTransferItemList</ref> items;

  void setDragImage(<ref>Element</ref> image, long x, long y);

  readonly attribute DOMString[] types;
  DOMString getData(DOMString format);
  void setData(DOMString format, DOMString data);
  void clearData(optional DOMString format);
  readonly attribute <ref>FileList</ref> files;
};
interface DataTransferItemList {
  readonly attribute unsigned long length;
  getter <ref>DataTransferItem</ref> (unsigned long index);
  void remove(unsigned long index);
  void clear();

  <ref>DataTransferItem</ref>? add(DOMString data, DOMString type);
  <ref>DataTransferItem</ref>? add(<ref>File</ref> data);
};
interface DataTransferItem {
  readonly attribute DOMString kind;
  readonly attribute DOMString type;
  void getAsString(<ref>FunctionStringCallback</ref>? _callback);
  <ref>File</ref>? getAsFile();
};

[Callback, NoInterfaceObject]
interface FunctionStringCallback {
  void handleEvent(DOMString data);
};
[Constructor(DOMString type, optional <ref>DragEventInit</ref> eventInitDict)]
interface DragEvent : <ref>MouseEvent</ref> {
  readonly attribute <ref>DataTransfer</ref>? dataTransfer;
};

dictionary DragEventInit : <ref>EventInit</ref> {
  <ref>Window</ref>? view = null;
  long detail = 0;
  long screenX = 0;
  long screenY = 0;
  long clientX = 0;
  long clientY = 0;
  boolean ctrlKey = false;
  boolean shiftKey = false;
  boolean altKey = false;
  boolean metaKey = false;
  unsigned short button = 0;
  unsigned short buttons = 0;
  <ref>EventTarget</ref>? relatedTarget = null;
  <ref>DataTransfer</ref>? dataTransfer;
};
interface HTMLAppletElement : <ref>HTMLElement</ref> {
           attribute DOMString align;
           attribute DOMString alt;
           attribute DOMString archive;
           attribute DOMString code;
           attribute DOMString codeBase;
           attribute DOMString height;
           attribute unsigned long hspace;
           attribute DOMString name;
           attribute DOMString _object; 
           attribute unsigned long vspace;
           attribute DOMString width;
};
interface HTMLMarqueeElement : <ref>HTMLElement</ref> {
           attribute DOMString behavior;
           attribute DOMString bgColor;
           attribute DOMString direction;
           attribute DOMString height;
           attribute unsigned long hspace;
           attribute long loop;
           attribute unsigned long scrollAmount;
           attribute unsigned long scrollDelay;
           attribute boolean trueSpeed;
           attribute unsigned long vspace;
           attribute DOMString width;

           attribute <ref>EventHandler</ref> onbounce;
           attribute <ref>EventHandler</ref> onfinish;
           attribute <ref>EventHandler</ref> onstart;

  void start();
  void stop();
};
interface HTMLFrameSetElement : <ref>HTMLElement</ref> {
           attribute DOMString cols;
           attribute DOMString rows;
};
<ref>HTMLFrameSetElement</ref> implements <ref>WindowEventHandlers</ref>;
interface HTMLFrameElement : <ref>HTMLElement</ref> {
           attribute DOMString name;
           attribute DOMString scrolling;
           attribute DOMString src;
           attribute DOMString frameBorder;
           attribute DOMString longDesc;
           attribute boolean noResize;
  readonly attribute <ref>Document</ref>? contentDocument;
  readonly attribute <ref>WindowProxy</ref>? contentWindow;

  [TreatNullAs=EmptyString] attribute DOMString marginHeight;
  [TreatNullAs=EmptyString] attribute DOMString marginWidth;
};
partial interface HTMLAnchorElement {
           attribute DOMString coords;
           attribute DOMString charset;
           attribute DOMString name;
           attribute DOMString rev;
           attribute DOMString shape;
};
partial interface HTMLAreaElement {
           attribute boolean noHref;
};
partial interface HTMLBodyElement {
  [TreatNullAs=EmptyString] attribute DOMString text;
  [TreatNullAs=EmptyString] attribute DOMString link;
  [TreatNullAs=EmptyString] attribute DOMString vLink;
  [TreatNullAs=EmptyString] attribute DOMString aLink;
  [TreatNullAs=EmptyString] attribute DOMString bgColor;
                            attribute DOMString background;
};
partial interface HTMLBRElement {
           attribute DOMString clear;
};
partial interface HTMLTableCaptionElement {
           attribute DOMString align;
};
partial interface HTMLTableColElement {
           attribute DOMString align;
           attribute DOMString ch;
           attribute DOMString chOff;
           attribute DOMString vAlign;
           attribute DOMString width;
};
interface HTMLDirectoryElement : <ref>HTMLElement</ref> {
           attribute boolean compact;
};
partial interface HTMLDivElement {
           attribute DOMString align;
};
partial interface HTMLDListElement {
           attribute boolean compact;
};
partial interface HTMLEmbedElement {
           attribute DOMString align;
           attribute DOMString name;
};
interface HTMLFontElement : <ref>HTMLElement</ref> {
  [TreatNullAs=EmptyString] attribute DOMString color;
                            attribute DOMString face;
                            attribute DOMString size; 
};
partial interface HTMLHeadingElement {
           attribute DOMString align;
};
partial interface HTMLHRElement {
           attribute DOMString align;
           attribute DOMString color;
           attribute boolean noShade;
           attribute DOMString size;
           attribute DOMString width;
};
partial interface HTMLHtmlElement {
           attribute DOMString version;
};
partial interface HTMLIFrameElement {
           attribute DOMString align;
           attribute DOMString scrolling;
           attribute DOMString frameBorder;
           attribute DOMString longDesc;

  [TreatNullAs=EmptyString] attribute DOMString marginHeight;
  [TreatNullAs=EmptyString] attribute DOMString marginWidth;
};
partial interface HTMLImageElement {
           attribute DOMString name;
           attribute DOMString align;
           attribute unsigned long hspace;
           attribute unsigned long vspace;
           attribute DOMString longDesc;

  [TreatNullAs=EmptyString] attribute DOMString border;
};
partial interface HTMLInputElement {
           attribute DOMString align;
           attribute DOMString useMap;
};
partial interface HTMLLegendElement {
           attribute DOMString align;
};
partial interface HTMLLIElement {
           attribute DOMString type;
};
partial interface HTMLLinkElement {
           attribute DOMString charset;
           attribute DOMString rev;
           attribute DOMString target;
};
partial interface HTMLMenuElement {
           attribute boolean compact;
};
partial interface HTMLMetaElement {
           attribute DOMString scheme;
};
partial interface HTMLObjectElement {
           attribute DOMString align;
           attribute DOMString archive;
           attribute DOMString code;
           attribute boolean declare;
           attribute unsigned long hspace;
           attribute DOMString standby;
           attribute unsigned long vspace;
           attribute DOMString codeBase;
           attribute DOMString codeType;

  [TreatNullAs=EmptyString] attribute DOMString border;
};
partial interface HTMLOListElement {
           attribute boolean compact;
};
partial interface HTMLParagraphElement {
           attribute DOMString align;
};
partial interface HTMLParamElement {
           attribute DOMString type;
           attribute DOMString valueType;
};
partial interface HTMLPreElement {
           attribute long width;
};
partial interface HTMLScriptElement {
           attribute DOMString event;
           attribute DOMString htmlFor;
};
partial interface HTMLTableElement {
           attribute DOMString align;
           attribute DOMString frame;
           attribute DOMString rules;
           attribute DOMString summary;
           attribute DOMString width;

  [TreatNullAs=EmptyString] attribute DOMString bgColor;
  [TreatNullAs=EmptyString] attribute DOMString cellPadding;
  [TreatNullAs=EmptyString] attribute DOMString cellSpacing;
};
partial interface HTMLTableSectionElement {
           attribute DOMString align;
           attribute DOMString ch;
           attribute DOMString chOff;
           attribute DOMString vAlign;
};
partial interface HTMLTableCellElement {
           attribute DOMString align;
           attribute DOMString axis;
           attribute DOMString height;
           attribute DOMString width;

           attribute DOMString ch;
           attribute DOMString chOff;
           attribute boolean noWrap;
           attribute DOMString vAlign;

  [TreatNullAs=EmptyString] attribute DOMString bgColor;
};
partial interface HTMLTableDataCellElement {
           attribute DOMString abbr;
};
partial interface HTMLTableRowElement {
           attribute DOMString align;
           attribute DOMString ch;
           attribute DOMString chOff;
           attribute DOMString vAlign;

  [TreatNullAs=EmptyString] attribute DOMString bgColor;
};
partial interface HTMLUListElement {
           attribute boolean compact;
           attribute DOMString type;
};
partial interface Document {
  [TreatNullAs=EmptyString] attribute DOMString fgColor;
  [TreatNullAs=EmptyString] attribute DOMString linkColor;
  [TreatNullAs=EmptyString] attribute DOMString vlinkColor;
  [TreatNullAs=EmptyString] attribute DOMString alinkColor;
  [TreatNullAs=EmptyString] attribute DOMString bgColor;

  readonly attribute <ref>HTMLCollection</ref> anchors;
  readonly attribute <ref>HTMLCollection</ref> applets;

  void clear();

  readonly attribute <ref>HTMLAllCollection</ref> all;
};</webidl>
  <Interface name="HTMLAllCollection" id="::HTMLAllCollection">
    <webidl>interface HTMLAllCollection : <ref>HTMLCollection</ref> {
  (<ref>HTMLCollection</ref> or <ref>Element</ref>)? item(DOMString name);
  legacycaller getter (<ref>HTMLCollection</ref> or <ref>Element</ref>)? namedItem(DOMString name); 
  <ref>HTMLAllCollection</ref> tags(DOMString tagName);
};</webidl>
    <InterfaceInheritance>
      <Name name="HTMLCollection"/>
    </InterfaceInheritance>
    <Operation name="item" id="::HTMLAllCollection::item">
      <webidl>  (<ref>HTMLCollection</ref> or <ref>Element</ref>)? item(DOMString name);</webidl>
      <Type type="union" nullable="nullable">
        <Type name="HTMLCollection"/>
        <Type name="Element"/>
      </Type>
      <ArgumentList>
        <Argument name="name">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation legacycaller="legacycaller" getter="getter" name="namedItem" id="::HTMLAllCollection::namedItem">
      <webidl>  legacycaller getter (<ref>HTMLCollection</ref> or <ref>Element</ref>)? namedItem(DOMString name);</webidl>
      <Type type="union" nullable="nullable">
        <Type name="HTMLCollection"/>
        <Type name="Element"/>
      </Type>
      <ArgumentList>
        <Argument name="name">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="tags" id="::HTMLAllCollection::tags">
      <webidl>  <ref>HTMLAllCollection</ref> tags(DOMString tagName);</webidl>
      <Type name="HTMLAllCollection"/>
      <ArgumentList>
        <Argument name="tagName">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
  </Interface>
  <Interface name="HTMLFormControlsCollection" id="::HTMLFormControlsCollection">
    <webidl>interface HTMLFormControlsCollection : <ref>HTMLCollection</ref> {
  legacycaller getter (<ref>RadioNodeList</ref> or <ref>Element</ref>)? namedItem(DOMString name); 
};</webidl>
    <InterfaceInheritance>
      <Name name="HTMLCollection"/>
    </InterfaceInheritance>
    <Operation legacycaller="legacycaller" getter="getter" name="namedItem" id="::HTMLFormControlsCollection::namedItem">
      <webidl>  legacycaller getter (<ref>RadioNodeList</ref> or <ref>Element</ref>)? namedItem(DOMString name);</webidl>
      <Type type="union" nullable="nullable">
        <Type name="RadioNodeList"/>
        <Type name="Element"/>
      </Type>
      <ArgumentList>
        <Argument name="name">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
  </Interface>
  <Interface name="RadioNodeList" id="::RadioNodeList">
    <webidl>interface RadioNodeList : <ref>NodeList</ref> {
          attribute DOMString value;
};</webidl>
    <InterfaceInheritance>
      <Name name="NodeList"/>
    </InterfaceInheritance>
    <Attribute name="value" id="::RadioNodeList::value">
      <webidl>          attribute DOMString value;</webidl>
      <Type type="DOMString"/>
    </Attribute>
  </Interface>
  <Interface name="HTMLOptionsCollection" id="::HTMLOptionsCollection">
    <webidl>interface HTMLOptionsCollection : <ref>HTMLCollection</ref> {
           attribute unsigned long length; 
  legacycaller getter (<ref>HTMLOptionElement</ref> or <ref>HTMLOptGroupElement</ref>)? namedItem(DOMString name); 
  setter creator void (unsigned long index, <ref>HTMLOptionElement</ref>? option);
  void add((<ref>HTMLOptionElement</ref> or <ref>HTMLOptGroupElement</ref>) element, optional (<ref>HTMLElement</ref> or long)? before = null);
  void remove(long index);
           attribute long selectedIndex;
};</webidl>
    <InterfaceInheritance>
      <Name name="HTMLCollection"/>
    </InterfaceInheritance>
    <Attribute name="length" id="::HTMLOptionsCollection::length">
      <webidl>           attribute unsigned long length;</webidl>
      <Type type="unsigned long"/>
    </Attribute>
    <Operation legacycaller="legacycaller" getter="getter" name="namedItem" id="::HTMLOptionsCollection::namedItem">
      <webidl>  legacycaller getter (<ref>HTMLOptionElement</ref> or <ref>HTMLOptGroupElement</ref>)? namedItem(DOMString name);</webidl>
      <Type type="union" nullable="nullable">
        <Type name="HTMLOptionElement"/>
        <Type name="HTMLOptGroupElement"/>
      </Type>
      <ArgumentList>
        <Argument name="name">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation setter="setter" creator="creator">
      <webidl>  setter creator void (unsigned long index, <ref>HTMLOptionElement</ref>? option);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument name="index">
          <Type type="unsigned long"/>
        </Argument>
        <Argument name="option">
          <Type name="HTMLOptionElement" nullable="nullable"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="add" id="::HTMLOptionsCollection::add">
      <webidl>  void add((<ref>HTMLOptionElement</ref> or <ref>HTMLOptGroupElement</ref>) element, optional (<ref>HTMLElement</ref> or long)? before = null);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument name="element">
          <Type type="union">
            <Type name="HTMLOptionElement"/>
            <Type name="HTMLOptGroupElement"/>
          </Type>
        </Argument>
        <Argument optional="optional" name="before" value="null">
          <Type type="union" nullable="nullable">
            <Type name="HTMLElement"/>
            <Type type="long"/>
          </Type>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="remove" id="::HTMLOptionsCollection::remove">
      <webidl>  void remove(long index);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument name="index">
          <Type type="long"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Attribute name="selectedIndex" id="::HTMLOptionsCollection::selectedIndex">
      <webidl>           attribute long selectedIndex;</webidl>
      <Type type="long"/>
    </Attribute>
  </Interface>
  <Interface name="DOMStringMap" id="::DOMStringMap">
    <webidl>interface DOMStringMap {
  getter DOMString (DOMString name);
  setter creator void (DOMString name, DOMString value);
  deleter void (DOMString name);
};</webidl>
    <Operation getter="getter">
      <webidl>  getter DOMString (DOMString name);</webidl>
      <Type type="DOMString"/>
      <ArgumentList>
        <Argument name="name">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation setter="setter" creator="creator">
      <webidl>  setter creator void (DOMString name, DOMString value);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument name="name">
          <Type type="DOMString"/>
        </Argument>
        <Argument name="value">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation deleter="deleter">
      <webidl>  deleter void (DOMString name);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument name="name">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
  </Interface>
  <Interface name="DOMElementMap" id="::DOMElementMap">
    <webidl>interface DOMElementMap {
  getter <ref>Element</ref> (DOMString name);
  setter creator void (DOMString name, <ref>Element</ref> value);
  deleter void (DOMString name);
};</webidl>
    <Operation getter="getter">
      <webidl>  getter <ref>Element</ref> (DOMString name);</webidl>
      <Type name="Element"/>
      <ArgumentList>
        <Argument name="name">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation setter="setter" creator="creator">
      <webidl>  setter creator void (DOMString name, <ref>Element</ref> value);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument name="name">
          <Type type="DOMString"/>
        </Argument>
        <Argument name="value">
          <Type name="Element"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation deleter="deleter">
      <webidl>  deleter void (DOMString name);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument name="name">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
  </Interface>
  <Interface name="Transferable" id="::Transferable">
    <webidl>[NoInterfaceObject]
interface Transferable { };</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="NoInterfaceObject">
        <webidl>NoInterfaceObject</webidl>
      </ExtendedAttribute>
    </ExtendedAttributeList>
  </Interface>
  <Callback name="FileCallback" id="::FileCallback">
    <webidl>callback FileCallback = void (<ref>File</ref> file);</webidl>
    <Type type="void"/>
    <ArgumentList>
      <Argument name="file">
        <Type name="File"/>
      </Argument>
    </ArgumentList>
  </Callback>
  <Enum name="DocumentReadyState" id="::DocumentReadyState">
    <webidl>enum DocumentReadyState { &quot;loading&quot;, &quot;interactive&quot;, &quot;complete&quot; };</webidl>
    <EnumValue stringvalue="loading">
      <webidl> &quot;loading</webidl>
    </EnumValue>
    <EnumValue stringvalue="interactive">
      <webidl> &quot;interactive</webidl>
    </EnumValue>
    <EnumValue stringvalue="complete">
      <webidl> &quot;complete</webidl>
    </EnumValue>
  </Enum>
  <Interface name="Document" partial="partial" id="::Document">
    <webidl>[OverrideBuiltins]
partial  interface Document {
  [PutForwards=href, Unforgeable] readonly attribute <ref>Location</ref>? location;
           attribute DOMString domain;
  readonly attribute DOMString referrer;
           attribute DOMString cookie;
  readonly attribute DOMString lastModified;
  readonly attribute <ref>DocumentReadyState</ref> readyState;

  getter object (DOMString name);
           attribute DOMString title;
           attribute DOMString dir;
           attribute <ref>HTMLElement</ref>? body;
  readonly attribute <ref>HTMLHeadElement</ref>? head;
  readonly attribute <ref>HTMLCollection</ref> images;
  readonly attribute <ref>HTMLCollection</ref> embeds;
  readonly attribute <ref>HTMLCollection</ref> plugins;
  readonly attribute <ref>HTMLCollection</ref> links;
  readonly attribute <ref>HTMLCollection</ref> forms;
  readonly attribute <ref>HTMLCollection</ref> scripts;
  <ref>NodeList</ref> getElementsByName(DOMString elementName);
  <ref>NodeList</ref> getItems(optional DOMString typeNames = &quot;&quot;); 
  readonly attribute <ref>DOMElementMap</ref> cssElementMap;
  readonly attribute <ref>HTMLScriptElement</ref>? currentScript;

  <ref>Document</ref> open(optional DOMString type = &quot;text/html&quot;, optional DOMString replace = &quot;&quot;);
  <ref>WindowProxy</ref> open(DOMString url, DOMString name, DOMString features, optional boolean replace = false);
  void close();
  void write(DOMString... text);
  void writeln(DOMString... text);

  readonly attribute <ref>WindowProxy</ref>? defaultView;
  readonly attribute <ref>Element</ref>? activeElement;
  boolean hasFocus();
           attribute DOMString designMode;
  boolean execCommand(DOMString commandId, optional boolean showUI = false, optional DOMString value = &quot;&quot;);
  boolean queryCommandEnabled(DOMString commandId);
  boolean queryCommandIndeterm(DOMString commandId);
  boolean queryCommandState(DOMString commandId);
  boolean queryCommandSupported(DOMString commandId);
  DOMString queryCommandValue(DOMString commandId);
  readonly attribute <ref>HTMLCollection</ref> commands;

  [LenientThis] attribute <ref>EventHandler</ref> onreadystatechange;
};</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="OverrideBuiltins">
        <webidl>OverrideBuiltins</webidl>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <Attribute readonly="readonly" name="location" id="::Document::location">
      <webidl>  [PutForwards=href, Unforgeable] readonly attribute <ref>Location</ref>? location;</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="PutForwards" value="href">
          <webidl>PutForwards</webidl>
        </ExtendedAttribute>
        <ExtendedAttribute name="Unforgeable">
          <webidl> Unforgeable</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type name="Location" nullable="nullable"/>
    </Attribute>
    <Attribute name="domain" id="::Document::domain">
      <webidl>           attribute DOMString domain;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute readonly="readonly" name="referrer" id="::Document::referrer">
      <webidl>  readonly attribute DOMString referrer;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="cookie" id="::Document::cookie">
      <webidl>           attribute DOMString cookie;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute readonly="readonly" name="lastModified" id="::Document::lastModified">
      <webidl>  readonly attribute DOMString lastModified;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute readonly="readonly" name="readyState" id="::Document::readyState">
      <webidl>  readonly attribute <ref>DocumentReadyState</ref> readyState;</webidl>
      <Type name="DocumentReadyState"/>
    </Attribute>
    <Operation getter="getter">
      <webidl>  getter object (DOMString name);</webidl>
      <Type type="object"/>
      <ArgumentList>
        <Argument name="name">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Attribute name="title" id="::Document::title">
      <webidl>           attribute DOMString title;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="dir" id="::Document::dir">
      <webidl>           attribute DOMString dir;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="body" id="::Document::body">
      <webidl>           attribute <ref>HTMLElement</ref>? body;</webidl>
      <Type name="HTMLElement" nullable="nullable"/>
    </Attribute>
    <Attribute readonly="readonly" name="head" id="::Document::head">
      <webidl>  readonly attribute <ref>HTMLHeadElement</ref>? head;</webidl>
      <Type name="HTMLHeadElement" nullable="nullable"/>
    </Attribute>
    <Attribute readonly="readonly" name="images" id="::Document::images">
      <webidl>  readonly attribute <ref>HTMLCollection</ref> images;</webidl>
      <Type name="HTMLCollection"/>
    </Attribute>
    <Attribute readonly="readonly" name="embeds" id="::Document::embeds">
      <webidl>  readonly attribute <ref>HTMLCollection</ref> embeds;</webidl>
      <Type name="HTMLCollection"/>
    </Attribute>
    <Attribute readonly="readonly" name="plugins" id="::Document::plugins">
      <webidl>  readonly attribute <ref>HTMLCollection</ref> plugins;</webidl>
      <Type name="HTMLCollection"/>
    </Attribute>
    <Attribute readonly="readonly" name="links" id="::Document::links">
      <webidl>  readonly attribute <ref>HTMLCollection</ref> links;</webidl>
      <Type name="HTMLCollection"/>
    </Attribute>
    <Attribute readonly="readonly" name="forms" id="::Document::forms">
      <webidl>  readonly attribute <ref>HTMLCollection</ref> forms;</webidl>
      <Type name="HTMLCollection"/>
    </Attribute>
    <Attribute readonly="readonly" name="scripts" id="::Document::scripts">
      <webidl>  readonly attribute <ref>HTMLCollection</ref> scripts;</webidl>
      <Type name="HTMLCollection"/>
    </Attribute>
    <Operation name="getElementsByName" id="::Document::getElementsByName">
      <webidl>  <ref>NodeList</ref> getElementsByName(DOMString elementName);</webidl>
      <Type name="NodeList"/>
      <ArgumentList>
        <Argument name="elementName">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="getItems" id="::Document::getItems">
      <webidl>  <ref>NodeList</ref> getItems(optional DOMString typeNames = &quot;&quot;);</webidl>
      <Type name="NodeList"/>
      <ArgumentList>
        <Argument optional="optional" name="typeNames" stringvalue="">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Attribute readonly="readonly" name="cssElementMap" id="::Document::cssElementMap">
      <webidl>  readonly attribute <ref>DOMElementMap</ref> cssElementMap;</webidl>
      <Type name="DOMElementMap"/>
    </Attribute>
    <Attribute readonly="readonly" name="currentScript" id="::Document::currentScript">
      <webidl>  readonly attribute <ref>HTMLScriptElement</ref>? currentScript;</webidl>
      <Type name="HTMLScriptElement" nullable="nullable"/>
    </Attribute>
    <Operation name="open" id="::Document::open">
      <webidl>  <ref>Document</ref> open(optional DOMString type = &quot;text/html&quot;, optional DOMString replace = &quot;&quot;);</webidl>
      <Type name="Document"/>
      <ArgumentList>
        <Argument optional="optional" name="type" stringvalue="text/html">
          <Type type="DOMString"/>
        </Argument>
        <Argument optional="optional" name="replace" stringvalue="">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="open" id="::Document::open">
      <webidl>  <ref>WindowProxy</ref> open(DOMString url, DOMString name, DOMString features, optional boolean replace = false);</webidl>
      <Type name="WindowProxy"/>
      <ArgumentList>
        <Argument name="url">
          <Type type="DOMString"/>
        </Argument>
        <Argument name="name">
          <Type type="DOMString"/>
        </Argument>
        <Argument name="features">
          <Type type="DOMString"/>
        </Argument>
        <Argument optional="optional" name="replace" value="false">
          <Type type="boolean"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="close" id="::Document::close">
      <webidl>  void close();</webidl>
      <Type type="void"/>
      <ArgumentList/>
    </Operation>
    <Operation name="write" id="::Document::write">
      <webidl>  void write(DOMString... text);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument ellipsis="ellipsis" name="text">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="writeln" id="::Document::writeln">
      <webidl>  void writeln(DOMString... text);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument ellipsis="ellipsis" name="text">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Attribute readonly="readonly" name="defaultView" id="::Document::defaultView">
      <webidl>  readonly attribute <ref>WindowProxy</ref>? defaultView;</webidl>
      <Type name="WindowProxy" nullable="nullable"/>
    </Attribute>
    <Attribute readonly="readonly" name="activeElement" id="::Document::activeElement">
      <webidl>  readonly attribute <ref>Element</ref>? activeElement;</webidl>
      <Type name="Element" nullable="nullable"/>
    </Attribute>
    <Operation name="hasFocus" id="::Document::hasFocus">
      <webidl>  boolean hasFocus();</webidl>
      <Type type="boolean"/>
      <ArgumentList/>
    </Operation>
    <Attribute name="designMode" id="::Document::designMode">
      <webidl>           attribute DOMString designMode;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Operation name="execCommand" id="::Document::execCommand">
      <webidl>  boolean execCommand(DOMString commandId, optional boolean showUI = false, optional DOMString value = &quot;&quot;);</webidl>
      <Type type="boolean"/>
      <ArgumentList>
        <Argument name="commandId">
          <Type type="DOMString"/>
        </Argument>
        <Argument optional="optional" name="showUI" value="false">
          <Type type="boolean"/>
        </Argument>
        <Argument optional="optional" name="value" stringvalue="">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="queryCommandEnabled" id="::Document::queryCommandEnabled">
      <webidl>  boolean queryCommandEnabled(DOMString commandId);</webidl>
      <Type type="boolean"/>
      <ArgumentList>
        <Argument name="commandId">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="queryCommandIndeterm" id="::Document::queryCommandIndeterm">
      <webidl>  boolean queryCommandIndeterm(DOMString commandId);</webidl>
      <Type type="boolean"/>
      <ArgumentList>
        <Argument name="commandId">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="queryCommandState" id="::Document::queryCommandState">
      <webidl>  boolean queryCommandState(DOMString commandId);</webidl>
      <Type type="boolean"/>
      <ArgumentList>
        <Argument name="commandId">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="queryCommandSupported" id="::Document::queryCommandSupported">
      <webidl>  boolean queryCommandSupported(DOMString commandId);</webidl>
      <Type type="boolean"/>
      <ArgumentList>
        <Argument name="commandId">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="queryCommandValue" id="::Document::queryCommandValue">
      <webidl>  DOMString queryCommandValue(DOMString commandId);</webidl>
      <Type type="DOMString"/>
      <ArgumentList>
        <Argument name="commandId">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Attribute readonly="readonly" name="commands" id="::Document::commands">
      <webidl>  readonly attribute <ref>HTMLCollection</ref> commands;</webidl>
      <Type name="HTMLCollection"/>
    </Attribute>
    <Attribute name="onreadystatechange" id="::Document::onreadystatechange">
      <webidl>  [LenientThis] attribute <ref>EventHandler</ref> onreadystatechange;</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="LenientThis">
          <webidl>LenientThis</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type name="EventHandler"/>
    </Attribute>
  </Interface>
  <Implements name1="Document" name2="GlobalEventHandlers">
    <webidl><ref>Document</ref> implements <ref>GlobalEventHandlers</ref>;</webidl>
  </Implements>
  <Interface name="XMLDocument" partial="partial" id="::XMLDocument">
    <webidl>partial interface XMLDocument {
  boolean load(DOMString url);
};</webidl>
    <Operation name="load" id="::XMLDocument::load">
      <webidl>  boolean load(DOMString url);</webidl>
      <Type type="boolean"/>
      <ArgumentList>
        <Argument name="url">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
  </Interface>
  <Interface name="HTMLElement" id="::HTMLElement">
    <webidl>interface HTMLElement : <ref>Element</ref> {
           attribute DOMString title;
           attribute DOMString lang;
           attribute boolean translate;
           attribute DOMString dir;
  readonly attribute <ref>DOMStringMap</ref> dataset;

           attribute boolean itemScope;
  [PutForwards=value] readonly attribute <ref>DOMSettableTokenList</ref> itemType;
           attribute DOMString itemId;
  [PutForwards=value] readonly attribute <ref>DOMSettableTokenList</ref> itemRef;
  [PutForwards=value] readonly attribute <ref>DOMSettableTokenList</ref> itemProp;
  readonly attribute <ref>HTMLPropertiesCollection</ref> properties;
           attribute any itemValue; 

           attribute boolean hidden;
  void click();
           attribute long tabIndex;
  void focus();
  void blur();
           attribute DOMString accessKey;
  readonly attribute DOMString accessKeyLabel;
           attribute boolean draggable;
  [PutForwards=value] readonly attribute <ref>DOMSettableTokenList</ref> dropzone;
           attribute DOMString contentEditable;
  readonly attribute boolean isContentEditable;
           attribute <ref>HTMLMenuElement</ref>? contextMenu;
           attribute boolean spellcheck;
  void forceSpellCheck();

  readonly attribute DOMString? commandType;
  readonly attribute DOMString? commandLabel;
  readonly attribute DOMString? commandIcon;
  readonly attribute boolean? commandHidden;
  readonly attribute boolean? commandDisabled;
  readonly attribute boolean? commandChecked;

  [PutForwards=cssText] readonly attribute <ref>CSSStyleDeclaration</ref> style;
};</webidl>
    <InterfaceInheritance>
      <Name name="Element"/>
    </InterfaceInheritance>
    <Attribute name="title" id="::HTMLElement::title">
      <webidl>           attribute DOMString title;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="lang" id="::HTMLElement::lang">
      <webidl>           attribute DOMString lang;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="translate" id="::HTMLElement::translate">
      <webidl>           attribute boolean translate;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute name="dir" id="::HTMLElement::dir">
      <webidl>           attribute DOMString dir;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute readonly="readonly" name="dataset" id="::HTMLElement::dataset">
      <webidl>  readonly attribute <ref>DOMStringMap</ref> dataset;</webidl>
      <Type name="DOMStringMap"/>
    </Attribute>
    <Attribute name="itemScope" id="::HTMLElement::itemScope">
      <webidl>           attribute boolean itemScope;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute readonly="readonly" name="itemType" id="::HTMLElement::itemType">
      <webidl>  [PutForwards=value] readonly attribute <ref>DOMSettableTokenList</ref> itemType;</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="PutForwards" value="value">
          <webidl>PutForwards</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type name="DOMSettableTokenList"/>
    </Attribute>
    <Attribute name="itemId" id="::HTMLElement::itemId">
      <webidl>           attribute DOMString itemId;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute readonly="readonly" name="itemRef" id="::HTMLElement::itemRef">
      <webidl>  [PutForwards=value] readonly attribute <ref>DOMSettableTokenList</ref> itemRef;</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="PutForwards" value="value">
          <webidl>PutForwards</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type name="DOMSettableTokenList"/>
    </Attribute>
    <Attribute readonly="readonly" name="itemProp" id="::HTMLElement::itemProp">
      <webidl>  [PutForwards=value] readonly attribute <ref>DOMSettableTokenList</ref> itemProp;</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="PutForwards" value="value">
          <webidl>PutForwards</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type name="DOMSettableTokenList"/>
    </Attribute>
    <Attribute readonly="readonly" name="properties" id="::HTMLElement::properties">
      <webidl>  readonly attribute <ref>HTMLPropertiesCollection</ref> properties;</webidl>
      <Type name="HTMLPropertiesCollection"/>
    </Attribute>
    <Attribute name="itemValue" id="::HTMLElement::itemValue">
      <webidl>           attribute any itemValue;</webidl>
      <Type type="any"/>
    </Attribute>
    <Attribute name="hidden" id="::HTMLElement::hidden">
      <webidl>           attribute boolean hidden;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Operation name="click" id="::HTMLElement::click">
      <webidl>  void click();</webidl>
      <Type type="void"/>
      <ArgumentList/>
    </Operation>
    <Attribute name="tabIndex" id="::HTMLElement::tabIndex">
      <webidl>           attribute long tabIndex;</webidl>
      <Type type="long"/>
    </Attribute>
    <Operation name="focus" id="::HTMLElement::focus">
      <webidl>  void focus();</webidl>
      <Type type="void"/>
      <ArgumentList/>
    </Operation>
    <Operation name="blur" id="::HTMLElement::blur">
      <webidl>  void blur();</webidl>
      <Type type="void"/>
      <ArgumentList/>
    </Operation>
    <Attribute name="accessKey" id="::HTMLElement::accessKey">
      <webidl>           attribute DOMString accessKey;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute readonly="readonly" name="accessKeyLabel" id="::HTMLElement::accessKeyLabel">
      <webidl>  readonly attribute DOMString accessKeyLabel;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="draggable" id="::HTMLElement::draggable">
      <webidl>           attribute boolean draggable;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute readonly="readonly" name="dropzone" id="::HTMLElement::dropzone">
      <webidl>  [PutForwards=value] readonly attribute <ref>DOMSettableTokenList</ref> dropzone;</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="PutForwards" value="value">
          <webidl>PutForwards</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type name="DOMSettableTokenList"/>
    </Attribute>
    <Attribute name="contentEditable" id="::HTMLElement::contentEditable">
      <webidl>           attribute DOMString contentEditable;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute readonly="readonly" name="isContentEditable" id="::HTMLElement::isContentEditable">
      <webidl>  readonly attribute boolean isContentEditable;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute name="contextMenu" id="::HTMLElement::contextMenu">
      <webidl>           attribute <ref>HTMLMenuElement</ref>? contextMenu;</webidl>
      <Type name="HTMLMenuElement" nullable="nullable"/>
    </Attribute>
    <Attribute name="spellcheck" id="::HTMLElement::spellcheck">
      <webidl>           attribute boolean spellcheck;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Operation name="forceSpellCheck" id="::HTMLElement::forceSpellCheck">
      <webidl>  void forceSpellCheck();</webidl>
      <Type type="void"/>
      <ArgumentList/>
    </Operation>
    <Attribute readonly="readonly" name="commandType" id="::HTMLElement::commandType">
      <webidl>  readonly attribute DOMString? commandType;</webidl>
      <Type type="DOMString" nullable="nullable"/>
    </Attribute>
    <Attribute readonly="readonly" name="commandLabel" id="::HTMLElement::commandLabel">
      <webidl>  readonly attribute DOMString? commandLabel;</webidl>
      <Type type="DOMString" nullable="nullable"/>
    </Attribute>
    <Attribute readonly="readonly" name="commandIcon" id="::HTMLElement::commandIcon">
      <webidl>  readonly attribute DOMString? commandIcon;</webidl>
      <Type type="DOMString" nullable="nullable"/>
    </Attribute>
    <Attribute readonly="readonly" name="commandHidden" id="::HTMLElement::commandHidden">
      <webidl>  readonly attribute boolean? commandHidden;</webidl>
      <Type type="boolean" nullable="nullable"/>
    </Attribute>
    <Attribute readonly="readonly" name="commandDisabled" id="::HTMLElement::commandDisabled">
      <webidl>  readonly attribute boolean? commandDisabled;</webidl>
      <Type type="boolean" nullable="nullable"/>
    </Attribute>
    <Attribute readonly="readonly" name="commandChecked" id="::HTMLElement::commandChecked">
      <webidl>  readonly attribute boolean? commandChecked;</webidl>
      <Type type="boolean" nullable="nullable"/>
    </Attribute>
    <Attribute readonly="readonly" name="style" id="::HTMLElement::style">
      <webidl>  [PutForwards=cssText] readonly attribute <ref>CSSStyleDeclaration</ref> style;</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="PutForwards" value="cssText">
          <webidl>PutForwards</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type name="CSSStyleDeclaration"/>
    </Attribute>
  </Interface>
  <Implements name1="HTMLElement" name2="GlobalEventHandlers">
    <webidl><ref>HTMLElement</ref> implements <ref>GlobalEventHandlers</ref>;</webidl>
  </Implements>
  <Interface name="HTMLUnknownElement" id="::HTMLUnknownElement">
    <webidl>interface HTMLUnknownElement : <ref>HTMLElement</ref> { };</webidl>
    <InterfaceInheritance>
      <Name name="HTMLElement"/>
    </InterfaceInheritance>
  </Interface>
  <Interface name="HTMLHtmlElement" id="::HTMLHtmlElement">
    <webidl>interface HTMLHtmlElement : <ref>HTMLElement</ref> {};</webidl>
    <InterfaceInheritance>
      <Name name="HTMLElement"/>
    </InterfaceInheritance>
  </Interface>
  <Interface name="HTMLHeadElement" id="::HTMLHeadElement">
    <webidl>interface HTMLHeadElement : <ref>HTMLElement</ref> {};</webidl>
    <InterfaceInheritance>
      <Name name="HTMLElement"/>
    </InterfaceInheritance>
  </Interface>
  <Interface name="HTMLTitleElement" id="::HTMLTitleElement">
    <webidl>interface HTMLTitleElement : <ref>HTMLElement</ref> {
           attribute DOMString text;
};</webidl>
    <InterfaceInheritance>
      <Name name="HTMLElement"/>
    </InterfaceInheritance>
    <Attribute name="text" id="::HTMLTitleElement::text">
      <webidl>           attribute DOMString text;</webidl>
      <Type type="DOMString"/>
    </Attribute>
  </Interface>
  <Interface name="HTMLBaseElement" id="::HTMLBaseElement">
    <webidl>interface HTMLBaseElement : <ref>HTMLElement</ref> {
           attribute DOMString href;
           attribute DOMString target;
};</webidl>
    <InterfaceInheritance>
      <Name name="HTMLElement"/>
    </InterfaceInheritance>
    <Attribute name="href" id="::HTMLBaseElement::href">
      <webidl>           attribute DOMString href;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="target" id="::HTMLBaseElement::target">
      <webidl>           attribute DOMString target;</webidl>
      <Type type="DOMString"/>
    </Attribute>
  </Interface>
  <Interface name="HTMLLinkElement" id="::HTMLLinkElement">
    <webidl>interface HTMLLinkElement : <ref>HTMLElement</ref> {
           attribute boolean disabled;
           attribute DOMString href;
           attribute DOMString crossOrigin;
           attribute DOMString rel;
  readonly attribute <ref>DOMTokenList</ref> relList;
           attribute DOMString media;
           attribute DOMString hreflang;
           attribute DOMString type;
  [PutForwards=value] readonly attribute <ref>DOMSettableTokenList</ref> sizes;
};</webidl>
    <InterfaceInheritance>
      <Name name="HTMLElement"/>
    </InterfaceInheritance>
    <Attribute name="disabled" id="::HTMLLinkElement::disabled">
      <webidl>           attribute boolean disabled;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute name="href" id="::HTMLLinkElement::href">
      <webidl>           attribute DOMString href;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="crossOrigin" id="::HTMLLinkElement::crossOrigin">
      <webidl>           attribute DOMString crossOrigin;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="rel" id="::HTMLLinkElement::rel">
      <webidl>           attribute DOMString rel;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute readonly="readonly" name="relList" id="::HTMLLinkElement::relList">
      <webidl>  readonly attribute <ref>DOMTokenList</ref> relList;</webidl>
      <Type name="DOMTokenList"/>
    </Attribute>
    <Attribute name="media" id="::HTMLLinkElement::media">
      <webidl>           attribute DOMString media;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="hreflang" id="::HTMLLinkElement::hreflang">
      <webidl>           attribute DOMString hreflang;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="type" id="::HTMLLinkElement::type">
      <webidl>           attribute DOMString type;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute readonly="readonly" name="sizes" id="::HTMLLinkElement::sizes">
      <webidl>  [PutForwards=value] readonly attribute <ref>DOMSettableTokenList</ref> sizes;</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="PutForwards" value="value">
          <webidl>PutForwards</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type name="DOMSettableTokenList"/>
    </Attribute>
  </Interface>
  <Implements name1="HTMLLinkElement" name2="LinkStyle">
    <webidl><ref>HTMLLinkElement</ref> implements <ref>LinkStyle</ref>;</webidl>
  </Implements>
  <Interface name="HTMLMetaElement" id="::HTMLMetaElement">
    <webidl>interface HTMLMetaElement : <ref>HTMLElement</ref> {
           attribute DOMString name;
           attribute DOMString httpEquiv;
           attribute DOMString content;
};</webidl>
    <InterfaceInheritance>
      <Name name="HTMLElement"/>
    </InterfaceInheritance>
    <Attribute name="name" id="::HTMLMetaElement::name">
      <webidl>           attribute DOMString name;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="httpEquiv" id="::HTMLMetaElement::httpEquiv">
      <webidl>           attribute DOMString httpEquiv;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="content" id="::HTMLMetaElement::content">
      <webidl>           attribute DOMString content;</webidl>
      <Type type="DOMString"/>
    </Attribute>
  </Interface>
  <Interface name="HTMLStyleElement" id="::HTMLStyleElement">
    <webidl>interface HTMLStyleElement : <ref>HTMLElement</ref> {
           attribute boolean disabled;
           attribute DOMString media;
           attribute DOMString type;
           attribute boolean scoped;
};</webidl>
    <InterfaceInheritance>
      <Name name="HTMLElement"/>
    </InterfaceInheritance>
    <Attribute name="disabled" id="::HTMLStyleElement::disabled">
      <webidl>           attribute boolean disabled;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute name="media" id="::HTMLStyleElement::media">
      <webidl>           attribute DOMString media;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="type" id="::HTMLStyleElement::type">
      <webidl>           attribute DOMString type;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="scoped" id="::HTMLStyleElement::scoped">
      <webidl>           attribute boolean scoped;</webidl>
      <Type type="boolean"/>
    </Attribute>
  </Interface>
  <Implements name1="HTMLStyleElement" name2="LinkStyle">
    <webidl><ref>HTMLStyleElement</ref> implements <ref>LinkStyle</ref>;</webidl>
  </Implements>
  <Interface name="HTMLScriptElement" id="::HTMLScriptElement">
    <webidl>interface HTMLScriptElement : <ref>HTMLElement</ref> {
           attribute DOMString src;
           attribute DOMString type;
           attribute DOMString charset;
           attribute boolean async;
           attribute boolean defer;
           attribute DOMString crossOrigin;
           attribute DOMString text;
};</webidl>
    <InterfaceInheritance>
      <Name name="HTMLElement"/>
    </InterfaceInheritance>
    <Attribute name="src" id="::HTMLScriptElement::src">
      <webidl>           attribute DOMString src;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="type" id="::HTMLScriptElement::type">
      <webidl>           attribute DOMString type;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="charset" id="::HTMLScriptElement::charset">
      <webidl>           attribute DOMString charset;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="async" id="::HTMLScriptElement::async">
      <webidl>           attribute boolean async;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute name="defer" id="::HTMLScriptElement::defer">
      <webidl>           attribute boolean defer;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute name="crossOrigin" id="::HTMLScriptElement::crossOrigin">
      <webidl>           attribute DOMString crossOrigin;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="text" id="::HTMLScriptElement::text">
      <webidl>           attribute DOMString text;</webidl>
      <Type type="DOMString"/>
    </Attribute>
  </Interface>
  <Interface name="HTMLBodyElement" id="::HTMLBodyElement">
    <webidl>interface HTMLBodyElement : <ref>HTMLElement</ref> {
};</webidl>
    <InterfaceInheritance>
      <Name name="HTMLElement"/>
    </InterfaceInheritance>
  </Interface>
  <Implements name1="HTMLBodyElement" name2="WindowEventHandlers">
    <webidl><ref>HTMLBodyElement</ref> implements <ref>WindowEventHandlers</ref>;</webidl>
  </Implements>
  <Interface name="HTMLHeadingElement" id="::HTMLHeadingElement">
    <webidl>interface HTMLHeadingElement : <ref>HTMLElement</ref> {};</webidl>
    <InterfaceInheritance>
      <Name name="HTMLElement"/>
    </InterfaceInheritance>
  </Interface>
  <Interface name="HTMLParagraphElement" id="::HTMLParagraphElement">
    <webidl>interface HTMLParagraphElement : <ref>HTMLElement</ref> {};</webidl>
    <InterfaceInheritance>
      <Name name="HTMLElement"/>
    </InterfaceInheritance>
  </Interface>
  <Interface name="HTMLHRElement" id="::HTMLHRElement">
    <webidl>interface HTMLHRElement : <ref>HTMLElement</ref> {};</webidl>
    <InterfaceInheritance>
      <Name name="HTMLElement"/>
    </InterfaceInheritance>
  </Interface>
  <Interface name="HTMLPreElement" id="::HTMLPreElement">
    <webidl>interface HTMLPreElement : <ref>HTMLElement</ref> {};</webidl>
    <InterfaceInheritance>
      <Name name="HTMLElement"/>
    </InterfaceInheritance>
  </Interface>
  <Interface name="HTMLQuoteElement" id="::HTMLQuoteElement">
    <webidl>interface HTMLQuoteElement : <ref>HTMLElement</ref> {
           attribute DOMString cite;
};</webidl>
    <InterfaceInheritance>
      <Name name="HTMLElement"/>
    </InterfaceInheritance>
    <Attribute name="cite" id="::HTMLQuoteElement::cite">
      <webidl>           attribute DOMString cite;</webidl>
      <Type type="DOMString"/>
    </Attribute>
  </Interface>
  <Interface name="HTMLOListElement" id="::HTMLOListElement">
    <webidl>interface HTMLOListElement : <ref>HTMLElement</ref> {
           attribute boolean reversed;
           attribute long start;
           attribute DOMString type;
};</webidl>
    <InterfaceInheritance>
      <Name name="HTMLElement"/>
    </InterfaceInheritance>
    <Attribute name="reversed" id="::HTMLOListElement::reversed">
      <webidl>           attribute boolean reversed;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute name="start" id="::HTMLOListElement::start">
      <webidl>           attribute long start;</webidl>
      <Type type="long"/>
    </Attribute>
    <Attribute name="type" id="::HTMLOListElement::type">
      <webidl>           attribute DOMString type;</webidl>
      <Type type="DOMString"/>
    </Attribute>
  </Interface>
  <Interface name="HTMLUListElement" id="::HTMLUListElement">
    <webidl>interface HTMLUListElement : <ref>HTMLElement</ref> {};</webidl>
    <InterfaceInheritance>
      <Name name="HTMLElement"/>
    </InterfaceInheritance>
  </Interface>
  <Interface name="HTMLLIElement" id="::HTMLLIElement">
    <webidl>interface HTMLLIElement : <ref>HTMLElement</ref> {
           attribute long value;
};</webidl>
    <InterfaceInheritance>
      <Name name="HTMLElement"/>
    </InterfaceInheritance>
    <Attribute name="value" id="::HTMLLIElement::value">
      <webidl>           attribute long value;</webidl>
      <Type type="long"/>
    </Attribute>
  </Interface>
  <Interface name="HTMLDListElement" id="::HTMLDListElement">
    <webidl>interface HTMLDListElement : <ref>HTMLElement</ref> {};</webidl>
    <InterfaceInheritance>
      <Name name="HTMLElement"/>
    </InterfaceInheritance>
  </Interface>
  <Interface name="HTMLDivElement" id="::HTMLDivElement">
    <webidl>interface HTMLDivElement : <ref>HTMLElement</ref> {};</webidl>
    <InterfaceInheritance>
      <Name name="HTMLElement"/>
    </InterfaceInheritance>
  </Interface>
  <Interface name="HTMLAnchorElement" id="::HTMLAnchorElement">
    <webidl>interface HTMLAnchorElement : <ref>HTMLElement</ref> {
           attribute DOMString target;
           attribute DOMString download;

           attribute DOMString rel;
  readonly attribute <ref>DOMTokenList</ref> relList;
           attribute DOMString hreflang;
           attribute DOMString type;

           attribute DOMString text;
};</webidl>
    <InterfaceInheritance>
      <Name name="HTMLElement"/>
    </InterfaceInheritance>
    <Attribute name="target" id="::HTMLAnchorElement::target">
      <webidl>           attribute DOMString target;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="download" id="::HTMLAnchorElement::download">
      <webidl>           attribute DOMString download;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="rel" id="::HTMLAnchorElement::rel">
      <webidl>           attribute DOMString rel;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute readonly="readonly" name="relList" id="::HTMLAnchorElement::relList">
      <webidl>  readonly attribute <ref>DOMTokenList</ref> relList;</webidl>
      <Type name="DOMTokenList"/>
    </Attribute>
    <Attribute name="hreflang" id="::HTMLAnchorElement::hreflang">
      <webidl>           attribute DOMString hreflang;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="type" id="::HTMLAnchorElement::type">
      <webidl>           attribute DOMString type;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="text" id="::HTMLAnchorElement::text">
      <webidl>           attribute DOMString text;</webidl>
      <Type type="DOMString"/>
    </Attribute>
  </Interface>
  <Implements name1="HTMLAnchorElement" name2="URLUtils">
    <webidl><ref>HTMLAnchorElement</ref> implements <ref>URLUtils</ref>;</webidl>
  </Implements>
  <Interface name="HTMLDataElement" id="::HTMLDataElement">
    <webidl>interface HTMLDataElement : <ref>HTMLElement</ref> {
           attribute DOMString value;
};</webidl>
    <InterfaceInheritance>
      <Name name="HTMLElement"/>
    </InterfaceInheritance>
    <Attribute name="value" id="::HTMLDataElement::value">
      <webidl>           attribute DOMString value;</webidl>
      <Type type="DOMString"/>
    </Attribute>
  </Interface>
  <Interface name="HTMLTimeElement" id="::HTMLTimeElement">
    <webidl>interface HTMLTimeElement : <ref>HTMLElement</ref> {
           attribute DOMString dateTime;
};</webidl>
    <InterfaceInheritance>
      <Name name="HTMLElement"/>
    </InterfaceInheritance>
    <Attribute name="dateTime" id="::HTMLTimeElement::dateTime">
      <webidl>           attribute DOMString dateTime;</webidl>
      <Type type="DOMString"/>
    </Attribute>
  </Interface>
  <Interface name="HTMLSpanElement" id="::HTMLSpanElement">
    <webidl>interface HTMLSpanElement : <ref>HTMLElement</ref> {};</webidl>
    <InterfaceInheritance>
      <Name name="HTMLElement"/>
    </InterfaceInheritance>
  </Interface>
  <Interface name="HTMLBRElement" id="::HTMLBRElement">
    <webidl>interface HTMLBRElement : <ref>HTMLElement</ref> {};</webidl>
    <InterfaceInheritance>
      <Name name="HTMLElement"/>
    </InterfaceInheritance>
  </Interface>
  <Interface name="HTMLModElement" id="::HTMLModElement">
    <webidl>interface HTMLModElement : <ref>HTMLElement</ref> {
           attribute DOMString cite;
           attribute DOMString dateTime;
};</webidl>
    <InterfaceInheritance>
      <Name name="HTMLElement"/>
    </InterfaceInheritance>
    <Attribute name="cite" id="::HTMLModElement::cite">
      <webidl>           attribute DOMString cite;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="dateTime" id="::HTMLModElement::dateTime">
      <webidl>           attribute DOMString dateTime;</webidl>
      <Type type="DOMString"/>
    </Attribute>
  </Interface>
  <Interface name="HTMLImageElement" id="::HTMLImageElement">
    <webidl>[NamedConstructor=Image(optional unsigned long width, optional unsigned long height)]
interface HTMLImageElement : <ref>HTMLElement</ref> {
           attribute DOMString alt;
           attribute DOMString src;

           attribute DOMString crossOrigin;
           attribute DOMString useMap;
           attribute boolean isMap;
           attribute unsigned long width;
           attribute unsigned long height;
  readonly attribute unsigned long naturalWidth;
  readonly attribute unsigned long naturalHeight;
  readonly attribute boolean complete;
};</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="NamedConstructor" value="Image">
        <webidl>NamedConstructor=Image(optional unsigned long width, optional unsigned long height)</webidl>
        <ArgumentList>
          <Argument optional="optional" name="width">
            <Type type="unsigned long"/>
          </Argument>
          <Argument optional="optional" name="height">
            <Type type="unsigned long"/>
          </Argument>
        </ArgumentList>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <InterfaceInheritance>
      <Name name="HTMLElement"/>
    </InterfaceInheritance>
    <Attribute name="alt" id="::HTMLImageElement::alt">
      <webidl>           attribute DOMString alt;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="src" id="::HTMLImageElement::src">
      <webidl>           attribute DOMString src;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="crossOrigin" id="::HTMLImageElement::crossOrigin">
      <webidl>           attribute DOMString crossOrigin;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="useMap" id="::HTMLImageElement::useMap">
      <webidl>           attribute DOMString useMap;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="isMap" id="::HTMLImageElement::isMap">
      <webidl>           attribute boolean isMap;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute name="width" id="::HTMLImageElement::width">
      <webidl>           attribute unsigned long width;</webidl>
      <Type type="unsigned long"/>
    </Attribute>
    <Attribute name="height" id="::HTMLImageElement::height">
      <webidl>           attribute unsigned long height;</webidl>
      <Type type="unsigned long"/>
    </Attribute>
    <Attribute readonly="readonly" name="naturalWidth" id="::HTMLImageElement::naturalWidth">
      <webidl>  readonly attribute unsigned long naturalWidth;</webidl>
      <Type type="unsigned long"/>
    </Attribute>
    <Attribute readonly="readonly" name="naturalHeight" id="::HTMLImageElement::naturalHeight">
      <webidl>  readonly attribute unsigned long naturalHeight;</webidl>
      <Type type="unsigned long"/>
    </Attribute>
    <Attribute readonly="readonly" name="complete" id="::HTMLImageElement::complete">
      <webidl>  readonly attribute boolean complete;</webidl>
      <Type type="boolean"/>
    </Attribute>
  </Interface>
  <Interface name="HTMLIFrameElement" id="::HTMLIFrameElement">
    <webidl>interface HTMLIFrameElement : <ref>HTMLElement</ref> {
           attribute DOMString src;
           attribute DOMString srcdoc;
           attribute DOMString name;
  [PutForwards=value] readonly attribute <ref>DOMSettableTokenList</ref> sandbox;
           attribute boolean seamless;
           attribute boolean allowFullscreen;
           attribute DOMString width;
           attribute DOMString height;
  readonly attribute <ref>Document</ref>? contentDocument;
  readonly attribute <ref>WindowProxy</ref>? contentWindow;
};</webidl>
    <InterfaceInheritance>
      <Name name="HTMLElement"/>
    </InterfaceInheritance>
    <Attribute name="src" id="::HTMLIFrameElement::src">
      <webidl>           attribute DOMString src;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="srcdoc" id="::HTMLIFrameElement::srcdoc">
      <webidl>           attribute DOMString srcdoc;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="name" id="::HTMLIFrameElement::name">
      <webidl>           attribute DOMString name;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute readonly="readonly" name="sandbox" id="::HTMLIFrameElement::sandbox">
      <webidl>  [PutForwards=value] readonly attribute <ref>DOMSettableTokenList</ref> sandbox;</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="PutForwards" value="value">
          <webidl>PutForwards</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type name="DOMSettableTokenList"/>
    </Attribute>
    <Attribute name="seamless" id="::HTMLIFrameElement::seamless">
      <webidl>           attribute boolean seamless;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute name="allowFullscreen" id="::HTMLIFrameElement::allowFullscreen">
      <webidl>           attribute boolean allowFullscreen;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute name="width" id="::HTMLIFrameElement::width">
      <webidl>           attribute DOMString width;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="height" id="::HTMLIFrameElement::height">
      <webidl>           attribute DOMString height;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute readonly="readonly" name="contentDocument" id="::HTMLIFrameElement::contentDocument">
      <webidl>  readonly attribute <ref>Document</ref>? contentDocument;</webidl>
      <Type name="Document" nullable="nullable"/>
    </Attribute>
    <Attribute readonly="readonly" name="contentWindow" id="::HTMLIFrameElement::contentWindow">
      <webidl>  readonly attribute <ref>WindowProxy</ref>? contentWindow;</webidl>
      <Type name="WindowProxy" nullable="nullable"/>
    </Attribute>
  </Interface>
  <Interface name="HTMLEmbedElement" id="::HTMLEmbedElement">
    <webidl>interface HTMLEmbedElement : <ref>HTMLElement</ref> {
           attribute DOMString src;
           attribute DOMString type;
           attribute DOMString width;
           attribute DOMString height;
  legacycaller any (any... arguments);
};</webidl>
    <InterfaceInheritance>
      <Name name="HTMLElement"/>
    </InterfaceInheritance>
    <Attribute name="src" id="::HTMLEmbedElement::src">
      <webidl>           attribute DOMString src;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="type" id="::HTMLEmbedElement::type">
      <webidl>           attribute DOMString type;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="width" id="::HTMLEmbedElement::width">
      <webidl>           attribute DOMString width;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="height" id="::HTMLEmbedElement::height">
      <webidl>           attribute DOMString height;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Operation legacycaller="legacycaller">
      <webidl>  legacycaller any (any... arguments);</webidl>
      <Type type="any"/>
      <ArgumentList>
        <Argument ellipsis="ellipsis" name="arguments">
          <Type type="any"/>
        </Argument>
      </ArgumentList>
    </Operation>
  </Interface>
  <Interface name="HTMLObjectElement" id="::HTMLObjectElement">
    <webidl>interface HTMLObjectElement : <ref>HTMLElement</ref> {
           attribute DOMString data;
           attribute DOMString type;
           attribute boolean typeMustMatch;
           attribute DOMString name;
           attribute DOMString useMap;
  readonly attribute <ref>HTMLFormElement</ref>? form;
           attribute DOMString width;
           attribute DOMString height;
  readonly attribute <ref>Document</ref>? contentDocument;
  readonly attribute <ref>WindowProxy</ref>? contentWindow;

  readonly attribute boolean willValidate;
  readonly attribute <ref>ValidityState</ref> validity;
  readonly attribute DOMString validationMessage;
  boolean checkValidity();
  void setCustomValidity(DOMString error);

  legacycaller any (any... arguments);
};</webidl>
    <InterfaceInheritance>
      <Name name="HTMLElement"/>
    </InterfaceInheritance>
    <Attribute name="data" id="::HTMLObjectElement::data">
      <webidl>           attribute DOMString data;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="type" id="::HTMLObjectElement::type">
      <webidl>           attribute DOMString type;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="typeMustMatch" id="::HTMLObjectElement::typeMustMatch">
      <webidl>           attribute boolean typeMustMatch;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute name="name" id="::HTMLObjectElement::name">
      <webidl>           attribute DOMString name;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="useMap" id="::HTMLObjectElement::useMap">
      <webidl>           attribute DOMString useMap;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute readonly="readonly" name="form" id="::HTMLObjectElement::form">
      <webidl>  readonly attribute <ref>HTMLFormElement</ref>? form;</webidl>
      <Type name="HTMLFormElement" nullable="nullable"/>
    </Attribute>
    <Attribute name="width" id="::HTMLObjectElement::width">
      <webidl>           attribute DOMString width;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="height" id="::HTMLObjectElement::height">
      <webidl>           attribute DOMString height;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute readonly="readonly" name="contentDocument" id="::HTMLObjectElement::contentDocument">
      <webidl>  readonly attribute <ref>Document</ref>? contentDocument;</webidl>
      <Type name="Document" nullable="nullable"/>
    </Attribute>
    <Attribute readonly="readonly" name="contentWindow" id="::HTMLObjectElement::contentWindow">
      <webidl>  readonly attribute <ref>WindowProxy</ref>? contentWindow;</webidl>
      <Type name="WindowProxy" nullable="nullable"/>
    </Attribute>
    <Attribute readonly="readonly" name="willValidate" id="::HTMLObjectElement::willValidate">
      <webidl>  readonly attribute boolean willValidate;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute readonly="readonly" name="validity" id="::HTMLObjectElement::validity">
      <webidl>  readonly attribute <ref>ValidityState</ref> validity;</webidl>
      <Type name="ValidityState"/>
    </Attribute>
    <Attribute readonly="readonly" name="validationMessage" id="::HTMLObjectElement::validationMessage">
      <webidl>  readonly attribute DOMString validationMessage;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Operation name="checkValidity" id="::HTMLObjectElement::checkValidity">
      <webidl>  boolean checkValidity();</webidl>
      <Type type="boolean"/>
      <ArgumentList/>
    </Operation>
    <Operation name="setCustomValidity" id="::HTMLObjectElement::setCustomValidity">
      <webidl>  void setCustomValidity(DOMString error);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument name="error">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation legacycaller="legacycaller">
      <webidl>  legacycaller any (any... arguments);</webidl>
      <Type type="any"/>
      <ArgumentList>
        <Argument ellipsis="ellipsis" name="arguments">
          <Type type="any"/>
        </Argument>
      </ArgumentList>
    </Operation>
  </Interface>
  <Interface name="HTMLParamElement" id="::HTMLParamElement">
    <webidl>interface HTMLParamElement : <ref>HTMLElement</ref> {
           attribute DOMString name;
           attribute DOMString value;
};</webidl>
    <InterfaceInheritance>
      <Name name="HTMLElement"/>
    </InterfaceInheritance>
    <Attribute name="name" id="::HTMLParamElement::name">
      <webidl>           attribute DOMString name;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="value" id="::HTMLParamElement::value">
      <webidl>           attribute DOMString value;</webidl>
      <Type type="DOMString"/>
    </Attribute>
  </Interface>
  <Interface name="HTMLVideoElement" id="::HTMLVideoElement">
    <webidl>interface HTMLVideoElement : <ref>HTMLMediaElement</ref> {
           attribute unsigned long width;
           attribute unsigned long height;
  readonly attribute unsigned long videoWidth;
  readonly attribute unsigned long videoHeight;
           attribute DOMString poster;
};</webidl>
    <InterfaceInheritance>
      <Name name="HTMLMediaElement"/>
    </InterfaceInheritance>
    <Attribute name="width" id="::HTMLVideoElement::width">
      <webidl>           attribute unsigned long width;</webidl>
      <Type type="unsigned long"/>
    </Attribute>
    <Attribute name="height" id="::HTMLVideoElement::height">
      <webidl>           attribute unsigned long height;</webidl>
      <Type type="unsigned long"/>
    </Attribute>
    <Attribute readonly="readonly" name="videoWidth" id="::HTMLVideoElement::videoWidth">
      <webidl>  readonly attribute unsigned long videoWidth;</webidl>
      <Type type="unsigned long"/>
    </Attribute>
    <Attribute readonly="readonly" name="videoHeight" id="::HTMLVideoElement::videoHeight">
      <webidl>  readonly attribute unsigned long videoHeight;</webidl>
      <Type type="unsigned long"/>
    </Attribute>
    <Attribute name="poster" id="::HTMLVideoElement::poster">
      <webidl>           attribute DOMString poster;</webidl>
      <Type type="DOMString"/>
    </Attribute>
  </Interface>
  <Interface name="HTMLAudioElement" id="::HTMLAudioElement">
    <webidl>[NamedConstructor=Audio(optional DOMString src)]
interface HTMLAudioElement : <ref>HTMLMediaElement</ref> {};</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="NamedConstructor" value="Audio">
        <webidl>NamedConstructor=Audio(optional DOMString src)</webidl>
        <ArgumentList>
          <Argument optional="optional" name="src">
            <Type type="DOMString"/>
          </Argument>
        </ArgumentList>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <InterfaceInheritance>
      <Name name="HTMLMediaElement"/>
    </InterfaceInheritance>
  </Interface>
  <Interface name="HTMLSourceElement" id="::HTMLSourceElement">
    <webidl>interface HTMLSourceElement : <ref>HTMLElement</ref> {
           attribute DOMString src;
           attribute DOMString type;
           attribute DOMString media;
};</webidl>
    <InterfaceInheritance>
      <Name name="HTMLElement"/>
    </InterfaceInheritance>
    <Attribute name="src" id="::HTMLSourceElement::src">
      <webidl>           attribute DOMString src;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="type" id="::HTMLSourceElement::type">
      <webidl>           attribute DOMString type;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="media" id="::HTMLSourceElement::media">
      <webidl>           attribute DOMString media;</webidl>
      <Type type="DOMString"/>
    </Attribute>
  </Interface>
  <Interface name="HTMLTrackElement" id="::HTMLTrackElement">
    <webidl>interface HTMLTrackElement : <ref>HTMLElement</ref> {
           attribute <ref>TextTrackKind</ref> kind;
           attribute DOMString src;
           attribute DOMString srclang;
           attribute DOMString label;
           attribute boolean default;

  const unsigned short NONE = 0;
  const unsigned short LOADING = 1;
  const unsigned short LOADED = 2;
  const unsigned short ERROR = 3;
  readonly attribute unsigned short readyState;

  readonly attribute <ref>TextTrack</ref> track;
};</webidl>
    <InterfaceInheritance>
      <Name name="HTMLElement"/>
    </InterfaceInheritance>
    <Attribute name="kind" id="::HTMLTrackElement::kind">
      <webidl>           attribute <ref>TextTrackKind</ref> kind;</webidl>
      <Type name="TextTrackKind"/>
    </Attribute>
    <Attribute name="src" id="::HTMLTrackElement::src">
      <webidl>           attribute DOMString src;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="srclang" id="::HTMLTrackElement::srclang">
      <webidl>           attribute DOMString srclang;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="label" id="::HTMLTrackElement::label">
      <webidl>           attribute DOMString label;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="default" id="::HTMLTrackElement::default">
      <webidl>           attribute boolean default;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Const name="NONE" value="0" id="::HTMLTrackElement::NONE">
      <webidl>  const unsigned short NONE = 0;</webidl>
      <Type type="unsigned short"/>
    </Const>
    <Const name="LOADING" value="1" id="::HTMLTrackElement::LOADING">
      <webidl>  const unsigned short LOADING = 1;</webidl>
      <Type type="unsigned short"/>
    </Const>
    <Const name="LOADED" value="2" id="::HTMLTrackElement::LOADED">
      <webidl>  const unsigned short LOADED = 2;</webidl>
      <Type type="unsigned short"/>
    </Const>
    <Const name="ERROR" value="3" id="::HTMLTrackElement::ERROR">
      <webidl>  const unsigned short ERROR = 3;</webidl>
      <Type type="unsigned short"/>
    </Const>
    <Attribute readonly="readonly" name="readyState" id="::HTMLTrackElement::readyState">
      <webidl>  readonly attribute unsigned short readyState;</webidl>
      <Type type="unsigned short"/>
    </Attribute>
    <Attribute readonly="readonly" name="track" id="::HTMLTrackElement::track">
      <webidl>  readonly attribute <ref>TextTrack</ref> track;</webidl>
      <Type name="TextTrack"/>
    </Attribute>
  </Interface>
  <Enum name="CanPlayTypeEnum" id="::CanPlayTypeEnum">
    <webidl>enum CanPlayTypeEnum { &quot;&quot; , &quot;maybe&quot;, &quot;probably&quot; };</webidl>
    <EnumValue stringvalue="">
      <webidl> &quot;</webidl>
    </EnumValue>
    <EnumValue stringvalue="maybe">
      <webidl> &quot;maybe</webidl>
    </EnumValue>
    <EnumValue stringvalue="probably">
      <webidl> &quot;probably</webidl>
    </EnumValue>
  </Enum>
  <Interface name="HTMLMediaElement" id="::HTMLMediaElement">
    <webidl>interface HTMLMediaElement : <ref>HTMLElement</ref> {

  readonly attribute <ref>MediaError</ref>? error;

           attribute DOMString src;
  readonly attribute DOMString currentSrc;
           attribute DOMString crossOrigin;
  const unsigned short NETWORK_EMPTY = 0;
  const unsigned short NETWORK_IDLE = 1;
  const unsigned short NETWORK_LOADING = 2;
  const unsigned short NETWORK_NO_SOURCE = 3;
  readonly attribute unsigned short networkState;
           attribute DOMString preload;
  readonly attribute <ref>TimeRanges</ref> buffered;
  void load();
  <ref>CanPlayTypeEnum</ref> canPlayType(DOMString type);

  const unsigned short HAVE_NOTHING = 0;
  const unsigned short HAVE_METADATA = 1;
  const unsigned short HAVE_CURRENT_DATA = 2;
  const unsigned short HAVE_FUTURE_DATA = 3;
  const unsigned short HAVE_ENOUGH_DATA = 4;
  readonly attribute unsigned short readyState;
  readonly attribute boolean seeking;

           attribute double currentTime;
  void fastSeek(double time);
  readonly attribute unrestricted double duration;
  readonly attribute Date startDate;
  readonly attribute boolean paused;
           attribute double defaultPlaybackRate;
           attribute double playbackRate;
  readonly attribute <ref>TimeRanges</ref> played;
  readonly attribute <ref>TimeRanges</ref> seekable;
  readonly attribute boolean ended;
           attribute boolean autoplay;
           attribute boolean loop;
  void play();
  void pause();

           attribute DOMString mediaGroup;
           attribute <ref>MediaController</ref>? controller;

           attribute boolean controls;
           attribute double volume;
           attribute boolean muted;
           attribute boolean defaultMuted;

  readonly attribute <ref>AudioTrackList</ref> audioTracks;
  readonly attribute <ref>VideoTrackList</ref> videoTracks;
  readonly attribute <ref>TextTrackList</ref> textTracks;
  <ref>TextTrack</ref> addTextTrack(<ref>TextTrackKind</ref> kind, optional DOMString label = &quot;&quot;, optional DOMString language = &quot;&quot;);
};</webidl>
    <InterfaceInheritance>
      <Name name="HTMLElement"/>
    </InterfaceInheritance>
    <Attribute readonly="readonly" name="error" id="::HTMLMediaElement::error">
      <webidl>  readonly attribute <ref>MediaError</ref>? error;</webidl>
      <Type name="MediaError" nullable="nullable"/>
    </Attribute>
    <Attribute name="src" id="::HTMLMediaElement::src">
      <webidl>           attribute DOMString src;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute readonly="readonly" name="currentSrc" id="::HTMLMediaElement::currentSrc">
      <webidl>  readonly attribute DOMString currentSrc;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="crossOrigin" id="::HTMLMediaElement::crossOrigin">
      <webidl>           attribute DOMString crossOrigin;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Const name="NETWORK_EMPTY" value="0" id="::HTMLMediaElement::NETWORK_EMPTY">
      <webidl>  const unsigned short NETWORK_EMPTY = 0;</webidl>
      <Type type="unsigned short"/>
    </Const>
    <Const name="NETWORK_IDLE" value="1" id="::HTMLMediaElement::NETWORK_IDLE">
      <webidl>  const unsigned short NETWORK_IDLE = 1;</webidl>
      <Type type="unsigned short"/>
    </Const>
    <Const name="NETWORK_LOADING" value="2" id="::HTMLMediaElement::NETWORK_LOADING">
      <webidl>  const unsigned short NETWORK_LOADING = 2;</webidl>
      <Type type="unsigned short"/>
    </Const>
    <Const name="NETWORK_NO_SOURCE" value="3" id="::HTMLMediaElement::NETWORK_NO_SOURCE">
      <webidl>  const unsigned short NETWORK_NO_SOURCE = 3;</webidl>
      <Type type="unsigned short"/>
    </Const>
    <Attribute readonly="readonly" name="networkState" id="::HTMLMediaElement::networkState">
      <webidl>  readonly attribute unsigned short networkState;</webidl>
      <Type type="unsigned short"/>
    </Attribute>
    <Attribute name="preload" id="::HTMLMediaElement::preload">
      <webidl>           attribute DOMString preload;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute readonly="readonly" name="buffered" id="::HTMLMediaElement::buffered">
      <webidl>  readonly attribute <ref>TimeRanges</ref> buffered;</webidl>
      <Type name="TimeRanges"/>
    </Attribute>
    <Operation name="load" id="::HTMLMediaElement::load">
      <webidl>  void load();</webidl>
      <Type type="void"/>
      <ArgumentList/>
    </Operation>
    <Operation name="canPlayType" id="::HTMLMediaElement::canPlayType">
      <webidl>  <ref>CanPlayTypeEnum</ref> canPlayType(DOMString type);</webidl>
      <Type name="CanPlayTypeEnum"/>
      <ArgumentList>
        <Argument name="type">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Const name="HAVE_NOTHING" value="0" id="::HTMLMediaElement::HAVE_NOTHING">
      <webidl>  const unsigned short HAVE_NOTHING = 0;</webidl>
      <Type type="unsigned short"/>
    </Const>
    <Const name="HAVE_METADATA" value="1" id="::HTMLMediaElement::HAVE_METADATA">
      <webidl>  const unsigned short HAVE_METADATA = 1;</webidl>
      <Type type="unsigned short"/>
    </Const>
    <Const name="HAVE_CURRENT_DATA" value="2" id="::HTMLMediaElement::HAVE_CURRENT_DATA">
      <webidl>  const unsigned short HAVE_CURRENT_DATA = 2;</webidl>
      <Type type="unsigned short"/>
    </Const>
    <Const name="HAVE_FUTURE_DATA" value="3" id="::HTMLMediaElement::HAVE_FUTURE_DATA">
      <webidl>  const unsigned short HAVE_FUTURE_DATA = 3;</webidl>
      <Type type="unsigned short"/>
    </Const>
    <Const name="HAVE_ENOUGH_DATA" value="4" id="::HTMLMediaElement::HAVE_ENOUGH_DATA">
      <webidl>  const unsigned short HAVE_ENOUGH_DATA = 4;</webidl>
      <Type type="unsigned short"/>
    </Const>
    <Attribute readonly="readonly" name="readyState" id="::HTMLMediaElement::readyState">
      <webidl>  readonly attribute unsigned short readyState;</webidl>
      <Type type="unsigned short"/>
    </Attribute>
    <Attribute readonly="readonly" name="seeking" id="::HTMLMediaElement::seeking">
      <webidl>  readonly attribute boolean seeking;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute name="currentTime" id="::HTMLMediaElement::currentTime">
      <webidl>           attribute double currentTime;</webidl>
      <Type type="double"/>
    </Attribute>
    <Operation name="fastSeek" id="::HTMLMediaElement::fastSeek">
      <webidl>  void fastSeek(double time);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument name="time">
          <Type type="double"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Attribute readonly="readonly" name="duration" id="::HTMLMediaElement::duration">
      <webidl>  readonly attribute unrestricted double duration;</webidl>
      <Type type="unrestricted double"/>
    </Attribute>
    <Attribute readonly="readonly" name="startDate" id="::HTMLMediaElement::startDate">
      <webidl>  readonly attribute Date startDate;</webidl>
      <Type type="Date"/>
    </Attribute>
    <Attribute readonly="readonly" name="paused" id="::HTMLMediaElement::paused">
      <webidl>  readonly attribute boolean paused;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute name="defaultPlaybackRate" id="::HTMLMediaElement::defaultPlaybackRate">
      <webidl>           attribute double defaultPlaybackRate;</webidl>
      <Type type="double"/>
    </Attribute>
    <Attribute name="playbackRate" id="::HTMLMediaElement::playbackRate">
      <webidl>           attribute double playbackRate;</webidl>
      <Type type="double"/>
    </Attribute>
    <Attribute readonly="readonly" name="played" id="::HTMLMediaElement::played">
      <webidl>  readonly attribute <ref>TimeRanges</ref> played;</webidl>
      <Type name="TimeRanges"/>
    </Attribute>
    <Attribute readonly="readonly" name="seekable" id="::HTMLMediaElement::seekable">
      <webidl>  readonly attribute <ref>TimeRanges</ref> seekable;</webidl>
      <Type name="TimeRanges"/>
    </Attribute>
    <Attribute readonly="readonly" name="ended" id="::HTMLMediaElement::ended">
      <webidl>  readonly attribute boolean ended;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute name="autoplay" id="::HTMLMediaElement::autoplay">
      <webidl>           attribute boolean autoplay;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute name="loop" id="::HTMLMediaElement::loop">
      <webidl>           attribute boolean loop;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Operation name="play" id="::HTMLMediaElement::play">
      <webidl>  void play();</webidl>
      <Type type="void"/>
      <ArgumentList/>
    </Operation>
    <Operation name="pause" id="::HTMLMediaElement::pause">
      <webidl>  void pause();</webidl>
      <Type type="void"/>
      <ArgumentList/>
    </Operation>
    <Attribute name="mediaGroup" id="::HTMLMediaElement::mediaGroup">
      <webidl>           attribute DOMString mediaGroup;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="controller" id="::HTMLMediaElement::controller">
      <webidl>           attribute <ref>MediaController</ref>? controller;</webidl>
      <Type name="MediaController" nullable="nullable"/>
    </Attribute>
    <Attribute name="controls" id="::HTMLMediaElement::controls">
      <webidl>           attribute boolean controls;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute name="volume" id="::HTMLMediaElement::volume">
      <webidl>           attribute double volume;</webidl>
      <Type type="double"/>
    </Attribute>
    <Attribute name="muted" id="::HTMLMediaElement::muted">
      <webidl>           attribute boolean muted;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute name="defaultMuted" id="::HTMLMediaElement::defaultMuted">
      <webidl>           attribute boolean defaultMuted;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute readonly="readonly" name="audioTracks" id="::HTMLMediaElement::audioTracks">
      <webidl>  readonly attribute <ref>AudioTrackList</ref> audioTracks;</webidl>
      <Type name="AudioTrackList"/>
    </Attribute>
    <Attribute readonly="readonly" name="videoTracks" id="::HTMLMediaElement::videoTracks">
      <webidl>  readonly attribute <ref>VideoTrackList</ref> videoTracks;</webidl>
      <Type name="VideoTrackList"/>
    </Attribute>
    <Attribute readonly="readonly" name="textTracks" id="::HTMLMediaElement::textTracks">
      <webidl>  readonly attribute <ref>TextTrackList</ref> textTracks;</webidl>
      <Type name="TextTrackList"/>
    </Attribute>
    <Operation name="addTextTrack" id="::HTMLMediaElement::addTextTrack">
      <webidl>  <ref>TextTrack</ref> addTextTrack(<ref>TextTrackKind</ref> kind, optional DOMString label = &quot;&quot;, optional DOMString language = &quot;&quot;);</webidl>
      <Type name="TextTrack"/>
      <ArgumentList>
        <Argument name="kind">
          <Type name="TextTrackKind"/>
        </Argument>
        <Argument optional="optional" name="label" stringvalue="">
          <Type type="DOMString"/>
        </Argument>
        <Argument optional="optional" name="language" stringvalue="">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
  </Interface>
  <Interface name="MediaError" id="::MediaError">
    <webidl>interface MediaError {
  const unsigned short MEDIA_ERR_ABORTED = 1;
  const unsigned short MEDIA_ERR_NETWORK = 2;
  const unsigned short MEDIA_ERR_DECODE = 3;
  const unsigned short MEDIA_ERR_SRC_NOT_SUPPORTED = 4;
  readonly attribute unsigned short code;
};</webidl>
    <Const name="MEDIA_ERR_ABORTED" value="1" id="::MediaError::MEDIA_ERR_ABORTED">
      <webidl>  const unsigned short MEDIA_ERR_ABORTED = 1;</webidl>
      <Type type="unsigned short"/>
    </Const>
    <Const name="MEDIA_ERR_NETWORK" value="2" id="::MediaError::MEDIA_ERR_NETWORK">
      <webidl>  const unsigned short MEDIA_ERR_NETWORK = 2;</webidl>
      <Type type="unsigned short"/>
    </Const>
    <Const name="MEDIA_ERR_DECODE" value="3" id="::MediaError::MEDIA_ERR_DECODE">
      <webidl>  const unsigned short MEDIA_ERR_DECODE = 3;</webidl>
      <Type type="unsigned short"/>
    </Const>
    <Const name="MEDIA_ERR_SRC_NOT_SUPPORTED" value="4" id="::MediaError::MEDIA_ERR_SRC_NOT_SUPPORTED">
      <webidl>  const unsigned short MEDIA_ERR_SRC_NOT_SUPPORTED = 4;</webidl>
      <Type type="unsigned short"/>
    </Const>
    <Attribute readonly="readonly" name="code" id="::MediaError::code">
      <webidl>  readonly attribute unsigned short code;</webidl>
      <Type type="unsigned short"/>
    </Attribute>
  </Interface>
  <Interface name="AudioTrackList" id="::AudioTrackList">
    <webidl>interface AudioTrackList : <ref>EventTarget</ref> {
  readonly attribute unsigned long length;
  getter <ref>AudioTrack</ref> (unsigned long index);
  <ref>AudioTrack</ref>? getTrackById(DOMString id);

           attribute <ref>EventHandler</ref> onchange;
           attribute <ref>EventHandler</ref> onaddtrack;
           attribute <ref>EventHandler</ref> onremovetrack;
};</webidl>
    <InterfaceInheritance>
      <Name name="EventTarget"/>
    </InterfaceInheritance>
    <Attribute readonly="readonly" name="length" id="::AudioTrackList::length">
      <webidl>  readonly attribute unsigned long length;</webidl>
      <Type type="unsigned long"/>
    </Attribute>
    <Operation getter="getter">
      <webidl>  getter <ref>AudioTrack</ref> (unsigned long index);</webidl>
      <Type name="AudioTrack"/>
      <ArgumentList>
        <Argument name="index">
          <Type type="unsigned long"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="getTrackById" id="::AudioTrackList::getTrackById">
      <webidl>  <ref>AudioTrack</ref>? getTrackById(DOMString id);</webidl>
      <Type name="AudioTrack" nullable="nullable"/>
      <ArgumentList>
        <Argument name="id">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Attribute name="onchange" id="::AudioTrackList::onchange">
      <webidl>           attribute <ref>EventHandler</ref> onchange;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="onaddtrack" id="::AudioTrackList::onaddtrack">
      <webidl>           attribute <ref>EventHandler</ref> onaddtrack;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="onremovetrack" id="::AudioTrackList::onremovetrack">
      <webidl>           attribute <ref>EventHandler</ref> onremovetrack;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
  </Interface>
  <Interface name="AudioTrack" id="::AudioTrack">
    <webidl>interface AudioTrack {
  readonly attribute DOMString id;
  readonly attribute DOMString kind;
  readonly attribute DOMString label;
  readonly attribute DOMString language;
           attribute boolean enabled;
};</webidl>
    <Attribute readonly="readonly" name="id" id="::AudioTrack::id">
      <webidl>  readonly attribute DOMString id;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute readonly="readonly" name="kind" id="::AudioTrack::kind">
      <webidl>  readonly attribute DOMString kind;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute readonly="readonly" name="label" id="::AudioTrack::label">
      <webidl>  readonly attribute DOMString label;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute readonly="readonly" name="language" id="::AudioTrack::language">
      <webidl>  readonly attribute DOMString language;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="enabled" id="::AudioTrack::enabled">
      <webidl>           attribute boolean enabled;</webidl>
      <Type type="boolean"/>
    </Attribute>
  </Interface>
  <Interface name="VideoTrackList" id="::VideoTrackList">
    <webidl>interface VideoTrackList : <ref>EventTarget</ref> {
  readonly attribute unsigned long length;
  getter <ref>VideoTrack</ref> (unsigned long index);
  <ref>VideoTrack</ref>? getTrackById(DOMString id);
  readonly attribute long selectedIndex;

           attribute <ref>EventHandler</ref> onchange;
           attribute <ref>EventHandler</ref> onaddtrack;
           attribute <ref>EventHandler</ref> onremovetrack;
};</webidl>
    <InterfaceInheritance>
      <Name name="EventTarget"/>
    </InterfaceInheritance>
    <Attribute readonly="readonly" name="length" id="::VideoTrackList::length">
      <webidl>  readonly attribute unsigned long length;</webidl>
      <Type type="unsigned long"/>
    </Attribute>
    <Operation getter="getter">
      <webidl>  getter <ref>VideoTrack</ref> (unsigned long index);</webidl>
      <Type name="VideoTrack"/>
      <ArgumentList>
        <Argument name="index">
          <Type type="unsigned long"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="getTrackById" id="::VideoTrackList::getTrackById">
      <webidl>  <ref>VideoTrack</ref>? getTrackById(DOMString id);</webidl>
      <Type name="VideoTrack" nullable="nullable"/>
      <ArgumentList>
        <Argument name="id">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Attribute readonly="readonly" name="selectedIndex" id="::VideoTrackList::selectedIndex">
      <webidl>  readonly attribute long selectedIndex;</webidl>
      <Type type="long"/>
    </Attribute>
    <Attribute name="onchange" id="::VideoTrackList::onchange">
      <webidl>           attribute <ref>EventHandler</ref> onchange;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="onaddtrack" id="::VideoTrackList::onaddtrack">
      <webidl>           attribute <ref>EventHandler</ref> onaddtrack;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="onremovetrack" id="::VideoTrackList::onremovetrack">
      <webidl>           attribute <ref>EventHandler</ref> onremovetrack;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
  </Interface>
  <Interface name="VideoTrack" id="::VideoTrack">
    <webidl>interface VideoTrack {
  readonly attribute DOMString id;
  readonly attribute DOMString kind;
  readonly attribute DOMString label;
  readonly attribute DOMString language;
           attribute boolean selected;
};</webidl>
    <Attribute readonly="readonly" name="id" id="::VideoTrack::id">
      <webidl>  readonly attribute DOMString id;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute readonly="readonly" name="kind" id="::VideoTrack::kind">
      <webidl>  readonly attribute DOMString kind;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute readonly="readonly" name="label" id="::VideoTrack::label">
      <webidl>  readonly attribute DOMString label;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute readonly="readonly" name="language" id="::VideoTrack::language">
      <webidl>  readonly attribute DOMString language;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="selected" id="::VideoTrack::selected">
      <webidl>           attribute boolean selected;</webidl>
      <Type type="boolean"/>
    </Attribute>
  </Interface>
  <Enum name="MediaControllerPlaybackState" id="::MediaControllerPlaybackState">
    <webidl>enum MediaControllerPlaybackState { &quot;waiting&quot;, &quot;playing&quot;, &quot;ended&quot; };</webidl>
    <EnumValue stringvalue="waiting">
      <webidl> &quot;waiting</webidl>
    </EnumValue>
    <EnumValue stringvalue="playing">
      <webidl> &quot;playing</webidl>
    </EnumValue>
    <EnumValue stringvalue="ended">
      <webidl> &quot;ended</webidl>
    </EnumValue>
  </Enum>
  <Interface name="MediaController" id="::MediaController">
    <webidl>[Constructor]
interface MediaController : <ref>EventTarget</ref> {
  readonly attribute unsigned short readyState; 

  readonly attribute <ref>TimeRanges</ref> buffered;
  readonly attribute <ref>TimeRanges</ref> seekable;
  readonly attribute unrestricted double duration;
           attribute double currentTime;

  readonly attribute boolean paused;
  readonly attribute <ref>MediaControllerPlaybackState</ref> playbackState;
  readonly attribute <ref>TimeRanges</ref> played;
  void pause();
  void unpause();
  void play(); 

           attribute double defaultPlaybackRate;
           attribute double playbackRate;

           attribute double volume;
           attribute boolean muted;

           attribute <ref>EventHandler</ref> onemptied;
           attribute <ref>EventHandler</ref> onloadedmetadata;
           attribute <ref>EventHandler</ref> onloadeddata;
           attribute <ref>EventHandler</ref> oncanplay;
           attribute <ref>EventHandler</ref> oncanplaythrough;
           attribute <ref>EventHandler</ref> onplaying;
           attribute <ref>EventHandler</ref> onended;
           attribute <ref>EventHandler</ref> onwaiting;

           attribute <ref>EventHandler</ref> ondurationchange;
           attribute <ref>EventHandler</ref> ontimeupdate;
           attribute <ref>EventHandler</ref> onplay;
           attribute <ref>EventHandler</ref> onpause;
           attribute <ref>EventHandler</ref> onratechange;
           attribute <ref>EventHandler</ref> onvolumechange;
};</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="Constructor">
        <webidl>Constructor</webidl>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <InterfaceInheritance>
      <Name name="EventTarget"/>
    </InterfaceInheritance>
    <Attribute readonly="readonly" name="readyState" id="::MediaController::readyState">
      <webidl>  readonly attribute unsigned short readyState;</webidl>
      <Type type="unsigned short"/>
    </Attribute>
    <Attribute readonly="readonly" name="buffered" id="::MediaController::buffered">
      <webidl>  readonly attribute <ref>TimeRanges</ref> buffered;</webidl>
      <Type name="TimeRanges"/>
    </Attribute>
    <Attribute readonly="readonly" name="seekable" id="::MediaController::seekable">
      <webidl>  readonly attribute <ref>TimeRanges</ref> seekable;</webidl>
      <Type name="TimeRanges"/>
    </Attribute>
    <Attribute readonly="readonly" name="duration" id="::MediaController::duration">
      <webidl>  readonly attribute unrestricted double duration;</webidl>
      <Type type="unrestricted double"/>
    </Attribute>
    <Attribute name="currentTime" id="::MediaController::currentTime">
      <webidl>           attribute double currentTime;</webidl>
      <Type type="double"/>
    </Attribute>
    <Attribute readonly="readonly" name="paused" id="::MediaController::paused">
      <webidl>  readonly attribute boolean paused;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute readonly="readonly" name="playbackState" id="::MediaController::playbackState">
      <webidl>  readonly attribute <ref>MediaControllerPlaybackState</ref> playbackState;</webidl>
      <Type name="MediaControllerPlaybackState"/>
    </Attribute>
    <Attribute readonly="readonly" name="played" id="::MediaController::played">
      <webidl>  readonly attribute <ref>TimeRanges</ref> played;</webidl>
      <Type name="TimeRanges"/>
    </Attribute>
    <Operation name="pause" id="::MediaController::pause">
      <webidl>  void pause();</webidl>
      <Type type="void"/>
      <ArgumentList/>
    </Operation>
    <Operation name="unpause" id="::MediaController::unpause">
      <webidl>  void unpause();</webidl>
      <Type type="void"/>
      <ArgumentList/>
    </Operation>
    <Operation name="play" id="::MediaController::play">
      <webidl>  void play();</webidl>
      <Type type="void"/>
      <ArgumentList/>
    </Operation>
    <Attribute name="defaultPlaybackRate" id="::MediaController::defaultPlaybackRate">
      <webidl>           attribute double defaultPlaybackRate;</webidl>
      <Type type="double"/>
    </Attribute>
    <Attribute name="playbackRate" id="::MediaController::playbackRate">
      <webidl>           attribute double playbackRate;</webidl>
      <Type type="double"/>
    </Attribute>
    <Attribute name="volume" id="::MediaController::volume">
      <webidl>           attribute double volume;</webidl>
      <Type type="double"/>
    </Attribute>
    <Attribute name="muted" id="::MediaController::muted">
      <webidl>           attribute boolean muted;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute name="onemptied" id="::MediaController::onemptied">
      <webidl>           attribute <ref>EventHandler</ref> onemptied;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="onloadedmetadata" id="::MediaController::onloadedmetadata">
      <webidl>           attribute <ref>EventHandler</ref> onloadedmetadata;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="onloadeddata" id="::MediaController::onloadeddata">
      <webidl>           attribute <ref>EventHandler</ref> onloadeddata;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="oncanplay" id="::MediaController::oncanplay">
      <webidl>           attribute <ref>EventHandler</ref> oncanplay;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="oncanplaythrough" id="::MediaController::oncanplaythrough">
      <webidl>           attribute <ref>EventHandler</ref> oncanplaythrough;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="onplaying" id="::MediaController::onplaying">
      <webidl>           attribute <ref>EventHandler</ref> onplaying;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="onended" id="::MediaController::onended">
      <webidl>           attribute <ref>EventHandler</ref> onended;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="onwaiting" id="::MediaController::onwaiting">
      <webidl>           attribute <ref>EventHandler</ref> onwaiting;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="ondurationchange" id="::MediaController::ondurationchange">
      <webidl>           attribute <ref>EventHandler</ref> ondurationchange;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="ontimeupdate" id="::MediaController::ontimeupdate">
      <webidl>           attribute <ref>EventHandler</ref> ontimeupdate;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="onplay" id="::MediaController::onplay">
      <webidl>           attribute <ref>EventHandler</ref> onplay;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="onpause" id="::MediaController::onpause">
      <webidl>           attribute <ref>EventHandler</ref> onpause;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="onratechange" id="::MediaController::onratechange">
      <webidl>           attribute <ref>EventHandler</ref> onratechange;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="onvolumechange" id="::MediaController::onvolumechange">
      <webidl>           attribute <ref>EventHandler</ref> onvolumechange;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
  </Interface>
  <Interface name="TextTrackList" id="::TextTrackList">
    <webidl>interface TextTrackList : <ref>EventTarget</ref> {
  readonly attribute unsigned long length;
  getter <ref>TextTrack</ref> (unsigned long index);

           attribute <ref>EventHandler</ref> onaddtrack;
           attribute <ref>EventHandler</ref> onremovetrack;
};</webidl>
    <InterfaceInheritance>
      <Name name="EventTarget"/>
    </InterfaceInheritance>
    <Attribute readonly="readonly" name="length" id="::TextTrackList::length">
      <webidl>  readonly attribute unsigned long length;</webidl>
      <Type type="unsigned long"/>
    </Attribute>
    <Operation getter="getter">
      <webidl>  getter <ref>TextTrack</ref> (unsigned long index);</webidl>
      <Type name="TextTrack"/>
      <ArgumentList>
        <Argument name="index">
          <Type type="unsigned long"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Attribute name="onaddtrack" id="::TextTrackList::onaddtrack">
      <webidl>           attribute <ref>EventHandler</ref> onaddtrack;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="onremovetrack" id="::TextTrackList::onremovetrack">
      <webidl>           attribute <ref>EventHandler</ref> onremovetrack;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
  </Interface>
  <Enum name="TextTrackMode" id="::TextTrackMode">
    <webidl>enum TextTrackMode { &quot;disabled&quot;,  &quot;hidden&quot;,  &quot;showing&quot; };</webidl>
    <EnumValue stringvalue="disabled">
      <webidl> &quot;disabled</webidl>
    </EnumValue>
    <EnumValue stringvalue="hidden">
      <webidl>  &quot;hidden</webidl>
    </EnumValue>
    <EnumValue stringvalue="showing">
      <webidl>  &quot;showing</webidl>
    </EnumValue>
  </Enum>
  <Enum name="TextTrackKind" id="::TextTrackKind">
    <webidl>enum TextTrackKind { &quot;subtitles&quot;,  &quot;captions&quot;,  &quot;descriptions&quot;,  &quot;chapters&quot;,  &quot;metadata&quot; };</webidl>
    <EnumValue stringvalue="subtitles">
      <webidl> &quot;subtitles</webidl>
    </EnumValue>
    <EnumValue stringvalue="captions">
      <webidl>  &quot;captions</webidl>
    </EnumValue>
    <EnumValue stringvalue="descriptions">
      <webidl>  &quot;descriptions</webidl>
    </EnumValue>
    <EnumValue stringvalue="chapters">
      <webidl>  &quot;chapters</webidl>
    </EnumValue>
    <EnumValue stringvalue="metadata">
      <webidl>  &quot;metadata</webidl>
    </EnumValue>
  </Enum>
  <Interface name="TextTrack" id="::TextTrack">
    <webidl>interface TextTrack : <ref>EventTarget</ref> {
  readonly attribute <ref>TextTrackKind</ref> kind;
  readonly attribute DOMString label;
  readonly attribute DOMString language;
  readonly attribute DOMString inBandMetadataTrackDispatchType;

           attribute <ref>TextTrackMode</ref> mode;

  readonly attribute <ref>TextTrackCueList</ref>? cues;
  readonly attribute <ref>TextTrackCueList</ref>? activeCues;

  void addCue(<ref>TextTrackCue</ref> cue);
  void removeCue(<ref>TextTrackCue</ref> cue);

           attribute <ref>EventHandler</ref> oncuechange;
};</webidl>
    <InterfaceInheritance>
      <Name name="EventTarget"/>
    </InterfaceInheritance>
    <Attribute readonly="readonly" name="kind" id="::TextTrack::kind">
      <webidl>  readonly attribute <ref>TextTrackKind</ref> kind;</webidl>
      <Type name="TextTrackKind"/>
    </Attribute>
    <Attribute readonly="readonly" name="label" id="::TextTrack::label">
      <webidl>  readonly attribute DOMString label;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute readonly="readonly" name="language" id="::TextTrack::language">
      <webidl>  readonly attribute DOMString language;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute readonly="readonly" name="inBandMetadataTrackDispatchType" id="::TextTrack::inBandMetadataTrackDispatchType">
      <webidl>  readonly attribute DOMString inBandMetadataTrackDispatchType;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="mode" id="::TextTrack::mode">
      <webidl>           attribute <ref>TextTrackMode</ref> mode;</webidl>
      <Type name="TextTrackMode"/>
    </Attribute>
    <Attribute readonly="readonly" name="cues" id="::TextTrack::cues">
      <webidl>  readonly attribute <ref>TextTrackCueList</ref>? cues;</webidl>
      <Type name="TextTrackCueList" nullable="nullable"/>
    </Attribute>
    <Attribute readonly="readonly" name="activeCues" id="::TextTrack::activeCues">
      <webidl>  readonly attribute <ref>TextTrackCueList</ref>? activeCues;</webidl>
      <Type name="TextTrackCueList" nullable="nullable"/>
    </Attribute>
    <Operation name="addCue" id="::TextTrack::addCue">
      <webidl>  void addCue(<ref>TextTrackCue</ref> cue);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument name="cue">
          <Type name="TextTrackCue"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="removeCue" id="::TextTrack::removeCue">
      <webidl>  void removeCue(<ref>TextTrackCue</ref> cue);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument name="cue">
          <Type name="TextTrackCue"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Attribute name="oncuechange" id="::TextTrack::oncuechange">
      <webidl>           attribute <ref>EventHandler</ref> oncuechange;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
  </Interface>
  <Interface name="TextTrackCueList" id="::TextTrackCueList">
    <webidl>interface TextTrackCueList {
  readonly attribute unsigned long length;
  getter <ref>TextTrackCue</ref> (unsigned long index);
  <ref>TextTrackCue</ref>? getCueById(DOMString id);
};</webidl>
    <Attribute readonly="readonly" name="length" id="::TextTrackCueList::length">
      <webidl>  readonly attribute unsigned long length;</webidl>
      <Type type="unsigned long"/>
    </Attribute>
    <Operation getter="getter">
      <webidl>  getter <ref>TextTrackCue</ref> (unsigned long index);</webidl>
      <Type name="TextTrackCue"/>
      <ArgumentList>
        <Argument name="index">
          <Type type="unsigned long"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="getCueById" id="::TextTrackCueList::getCueById">
      <webidl>  <ref>TextTrackCue</ref>? getCueById(DOMString id);</webidl>
      <Type name="TextTrackCue" nullable="nullable"/>
      <ArgumentList>
        <Argument name="id">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
  </Interface>
  <Interface name="TextTrackCue" id="::TextTrackCue">
    <webidl>interface TextTrackCue : <ref>EventTarget</ref> {
  readonly attribute <ref>TextTrack</ref>? track;

           attribute DOMString id;
           attribute double startTime;
           attribute double endTime;
           attribute boolean pauseOnExit;

           attribute <ref>EventHandler</ref> onenter;
           attribute <ref>EventHandler</ref> onexit;
};</webidl>
    <InterfaceInheritance>
      <Name name="EventTarget"/>
    </InterfaceInheritance>
    <Attribute readonly="readonly" name="track" id="::TextTrackCue::track">
      <webidl>  readonly attribute <ref>TextTrack</ref>? track;</webidl>
      <Type name="TextTrack" nullable="nullable"/>
    </Attribute>
    <Attribute name="id" id="::TextTrackCue::id">
      <webidl>           attribute DOMString id;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="startTime" id="::TextTrackCue::startTime">
      <webidl>           attribute double startTime;</webidl>
      <Type type="double"/>
    </Attribute>
    <Attribute name="endTime" id="::TextTrackCue::endTime">
      <webidl>           attribute double endTime;</webidl>
      <Type type="double"/>
    </Attribute>
    <Attribute name="pauseOnExit" id="::TextTrackCue::pauseOnExit">
      <webidl>           attribute boolean pauseOnExit;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute name="onenter" id="::TextTrackCue::onenter">
      <webidl>           attribute <ref>EventHandler</ref> onenter;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="onexit" id="::TextTrackCue::onexit">
      <webidl>           attribute <ref>EventHandler</ref> onexit;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
  </Interface>
  <Interface name="TimeRanges" id="::TimeRanges">
    <webidl>interface TimeRanges {
  readonly attribute unsigned long length;
  double start(unsigned long index);
  double end(unsigned long index);
};</webidl>
    <Attribute readonly="readonly" name="length" id="::TimeRanges::length">
      <webidl>  readonly attribute unsigned long length;</webidl>
      <Type type="unsigned long"/>
    </Attribute>
    <Operation name="start" id="::TimeRanges::start">
      <webidl>  double start(unsigned long index);</webidl>
      <Type type="double"/>
      <ArgumentList>
        <Argument name="index">
          <Type type="unsigned long"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="end" id="::TimeRanges::end">
      <webidl>  double end(unsigned long index);</webidl>
      <Type type="double"/>
      <ArgumentList>
        <Argument name="index">
          <Type type="unsigned long"/>
        </Argument>
      </ArgumentList>
    </Operation>
  </Interface>
  <Interface name="TrackEvent" id="::TrackEvent">
    <webidl>[Constructor(DOMString type, optional <ref>TrackEventInit</ref> eventInitDict)]
interface TrackEvent : <ref>Event</ref> {
  readonly attribute object? track;
};</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="Constructor">
        <webidl>Constructor(DOMString type, optional <ref>TrackEventInit</ref> eventInitDict)</webidl>
        <ArgumentList>
          <Argument name="type">
            <Type type="DOMString"/>
          </Argument>
          <Argument optional="optional" name="eventInitDict">
            <Type name="TrackEventInit"/>
          </Argument>
        </ArgumentList>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <InterfaceInheritance>
      <Name name="Event"/>
    </InterfaceInheritance>
    <Attribute readonly="readonly" name="track" id="::TrackEvent::track">
      <webidl>  readonly attribute object? track;</webidl>
      <Type type="object" nullable="nullable"/>
    </Attribute>
  </Interface>
  <Dictionary name="TrackEventInit" id="::TrackEventInit">
    <webidl>dictionary TrackEventInit : <ref>EventInit</ref> {
  object? track;
};</webidl>
    <DictionaryInheritance>
      <Name name="EventInit"/>
    </DictionaryInheritance>
    <DictionaryMember name="track" id="::TrackEventInit::track">
      <webidl>  object? track;</webidl>
      <Type type="object" nullable="nullable"/>
    </DictionaryMember>
  </Dictionary>
  <Typedef name="RenderingContext" id="::RenderingContext">
    <webidl>typedef (<ref>CanvasRenderingContext2D</ref> or <ref>WebGLRenderingContext</ref>) RenderingContext;</webidl>
    <Type type="union">
      <Type name="CanvasRenderingContext2D"/>
      <Type name="WebGLRenderingContext"/>
    </Type>
  </Typedef>
  <Interface name="HTMLCanvasElement" id="::HTMLCanvasElement">
    <webidl>interface HTMLCanvasElement : <ref>HTMLElement</ref> {
           attribute unsigned long width;
           attribute unsigned long height;

  <ref>RenderingContext</ref>? getContext(DOMString contextId, any... arguments);
  boolean supportsContext(DOMString contextId, any... arguments);

  void setContext(<ref>RenderingContext</ref> context);
  <ref>CanvasProxy</ref> transferControlToProxy();

  DOMString toDataURL(optional DOMString type, any... arguments);
  void toBlob(<ref>FileCallback</ref>? _callback, optional DOMString type, any... arguments);
};</webidl>
    <InterfaceInheritance>
      <Name name="HTMLElement"/>
    </InterfaceInheritance>
    <Attribute name="width" id="::HTMLCanvasElement::width">
      <webidl>           attribute unsigned long width;</webidl>
      <Type type="unsigned long"/>
    </Attribute>
    <Attribute name="height" id="::HTMLCanvasElement::height">
      <webidl>           attribute unsigned long height;</webidl>
      <Type type="unsigned long"/>
    </Attribute>
    <Operation name="getContext" id="::HTMLCanvasElement::getContext">
      <webidl>  <ref>RenderingContext</ref>? getContext(DOMString contextId, any... arguments);</webidl>
      <Type name="RenderingContext" nullable="nullable"/>
      <ArgumentList>
        <Argument name="contextId">
          <Type type="DOMString"/>
        </Argument>
        <Argument ellipsis="ellipsis" name="arguments">
          <Type type="any"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="supportsContext" id="::HTMLCanvasElement::supportsContext">
      <webidl>  boolean supportsContext(DOMString contextId, any... arguments);</webidl>
      <Type type="boolean"/>
      <ArgumentList>
        <Argument name="contextId">
          <Type type="DOMString"/>
        </Argument>
        <Argument ellipsis="ellipsis" name="arguments">
          <Type type="any"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="setContext" id="::HTMLCanvasElement::setContext">
      <webidl>  void setContext(<ref>RenderingContext</ref> context);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument name="context">
          <Type name="RenderingContext"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="transferControlToProxy" id="::HTMLCanvasElement::transferControlToProxy">
      <webidl>  <ref>CanvasProxy</ref> transferControlToProxy();</webidl>
      <Type name="CanvasProxy"/>
      <ArgumentList/>
    </Operation>
    <Operation name="toDataURL" id="::HTMLCanvasElement::toDataURL">
      <webidl>  DOMString toDataURL(optional DOMString type, any... arguments);</webidl>
      <Type type="DOMString"/>
      <ArgumentList>
        <Argument optional="optional" name="type">
          <Type type="DOMString"/>
        </Argument>
        <Argument ellipsis="ellipsis" name="arguments">
          <Type type="any"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="toBlob" id="::HTMLCanvasElement::toBlob">
      <webidl>  void toBlob(<ref>FileCallback</ref>? _callback, optional DOMString type, any... arguments);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument name="_callback">
          <Type name="FileCallback" nullable="nullable"/>
        </Argument>
        <Argument optional="optional" name="type">
          <Type type="DOMString"/>
        </Argument>
        <Argument ellipsis="ellipsis" name="arguments">
          <Type type="any"/>
        </Argument>
      </ArgumentList>
    </Operation>
  </Interface>
  <Interface name="CanvasProxy" id="::CanvasProxy">
    <webidl>interface CanvasProxy {
  void setContext(<ref>RenderingContext</ref> context);
};</webidl>
    <Operation name="setContext" id="::CanvasProxy::setContext">
      <webidl>  void setContext(<ref>RenderingContext</ref> context);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument name="context">
          <Type name="RenderingContext"/>
        </Argument>
      </ArgumentList>
    </Operation>
  </Interface>
  <Implements name1="CanvasProxy" name2="Transferable">
    <webidl><ref>CanvasProxy</ref> implements <ref>Transferable</ref>;</webidl>
  </Implements>
  <Interface name="HTMLMapElement" id="::HTMLMapElement">
    <webidl>interface HTMLMapElement : <ref>HTMLElement</ref> {
           attribute DOMString name;
  readonly attribute <ref>HTMLCollection</ref> areas;
  readonly attribute <ref>HTMLCollection</ref> images;
};</webidl>
    <InterfaceInheritance>
      <Name name="HTMLElement"/>
    </InterfaceInheritance>
    <Attribute name="name" id="::HTMLMapElement::name">
      <webidl>           attribute DOMString name;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute readonly="readonly" name="areas" id="::HTMLMapElement::areas">
      <webidl>  readonly attribute <ref>HTMLCollection</ref> areas;</webidl>
      <Type name="HTMLCollection"/>
    </Attribute>
    <Attribute readonly="readonly" name="images" id="::HTMLMapElement::images">
      <webidl>  readonly attribute <ref>HTMLCollection</ref> images;</webidl>
      <Type name="HTMLCollection"/>
    </Attribute>
  </Interface>
  <Interface name="HTMLAreaElement" id="::HTMLAreaElement">
    <webidl>interface HTMLAreaElement : <ref>HTMLElement</ref> {
           attribute DOMString alt;
           attribute DOMString coords;
           attribute DOMString shape;
           attribute DOMString target;
           attribute DOMString download;

           attribute DOMString rel;
  readonly attribute <ref>DOMTokenList</ref> relList;
           attribute DOMString hreflang;
           attribute DOMString type;
};</webidl>
    <InterfaceInheritance>
      <Name name="HTMLElement"/>
    </InterfaceInheritance>
    <Attribute name="alt" id="::HTMLAreaElement::alt">
      <webidl>           attribute DOMString alt;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="coords" id="::HTMLAreaElement::coords">
      <webidl>           attribute DOMString coords;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="shape" id="::HTMLAreaElement::shape">
      <webidl>           attribute DOMString shape;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="target" id="::HTMLAreaElement::target">
      <webidl>           attribute DOMString target;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="download" id="::HTMLAreaElement::download">
      <webidl>           attribute DOMString download;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="rel" id="::HTMLAreaElement::rel">
      <webidl>           attribute DOMString rel;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute readonly="readonly" name="relList" id="::HTMLAreaElement::relList">
      <webidl>  readonly attribute <ref>DOMTokenList</ref> relList;</webidl>
      <Type name="DOMTokenList"/>
    </Attribute>
    <Attribute name="hreflang" id="::HTMLAreaElement::hreflang">
      <webidl>           attribute DOMString hreflang;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="type" id="::HTMLAreaElement::type">
      <webidl>           attribute DOMString type;</webidl>
      <Type type="DOMString"/>
    </Attribute>
  </Interface>
  <Implements name1="HTMLAreaElement" name2="URLUtils">
    <webidl><ref>HTMLAreaElement</ref> implements <ref>URLUtils</ref>;</webidl>
  </Implements>
  <Interface name="HTMLTableElement" id="::HTMLTableElement">
    <webidl>interface HTMLTableElement : <ref>HTMLElement</ref> {
           attribute <ref>HTMLTableCaptionElement</ref>? caption;
  <ref>HTMLElement</ref> createCaption();
  void deleteCaption();
           attribute <ref>HTMLTableSectionElement</ref>? tHead;
  <ref>HTMLElement</ref> createTHead();
  void deleteTHead();
           attribute <ref>HTMLTableSectionElement</ref>? tFoot;
  <ref>HTMLElement</ref> createTFoot();
  void deleteTFoot();
  readonly attribute <ref>HTMLCollection</ref> tBodies;
  <ref>HTMLElement</ref> createTBody();
  readonly attribute <ref>HTMLCollection</ref> rows;
  <ref>HTMLElement</ref> insertRow(optional long index = -1);
  void deleteRow(long index);
           attribute DOMString border;
           attribute boolean sortable;
  void stopSorting();
};</webidl>
    <InterfaceInheritance>
      <Name name="HTMLElement"/>
    </InterfaceInheritance>
    <Attribute name="caption" id="::HTMLTableElement::caption">
      <webidl>           attribute <ref>HTMLTableCaptionElement</ref>? caption;</webidl>
      <Type name="HTMLTableCaptionElement" nullable="nullable"/>
    </Attribute>
    <Operation name="createCaption" id="::HTMLTableElement::createCaption">
      <webidl>  <ref>HTMLElement</ref> createCaption();</webidl>
      <Type name="HTMLElement"/>
      <ArgumentList/>
    </Operation>
    <Operation name="deleteCaption" id="::HTMLTableElement::deleteCaption">
      <webidl>  void deleteCaption();</webidl>
      <Type type="void"/>
      <ArgumentList/>
    </Operation>
    <Attribute name="tHead" id="::HTMLTableElement::tHead">
      <webidl>           attribute <ref>HTMLTableSectionElement</ref>? tHead;</webidl>
      <Type name="HTMLTableSectionElement" nullable="nullable"/>
    </Attribute>
    <Operation name="createTHead" id="::HTMLTableElement::createTHead">
      <webidl>  <ref>HTMLElement</ref> createTHead();</webidl>
      <Type name="HTMLElement"/>
      <ArgumentList/>
    </Operation>
    <Operation name="deleteTHead" id="::HTMLTableElement::deleteTHead">
      <webidl>  void deleteTHead();</webidl>
      <Type type="void"/>
      <ArgumentList/>
    </Operation>
    <Attribute name="tFoot" id="::HTMLTableElement::tFoot">
      <webidl>           attribute <ref>HTMLTableSectionElement</ref>? tFoot;</webidl>
      <Type name="HTMLTableSectionElement" nullable="nullable"/>
    </Attribute>
    <Operation name="createTFoot" id="::HTMLTableElement::createTFoot">
      <webidl>  <ref>HTMLElement</ref> createTFoot();</webidl>
      <Type name="HTMLElement"/>
      <ArgumentList/>
    </Operation>
    <Operation name="deleteTFoot" id="::HTMLTableElement::deleteTFoot">
      <webidl>  void deleteTFoot();</webidl>
      <Type type="void"/>
      <ArgumentList/>
    </Operation>
    <Attribute readonly="readonly" name="tBodies" id="::HTMLTableElement::tBodies">
      <webidl>  readonly attribute <ref>HTMLCollection</ref> tBodies;</webidl>
      <Type name="HTMLCollection"/>
    </Attribute>
    <Operation name="createTBody" id="::HTMLTableElement::createTBody">
      <webidl>  <ref>HTMLElement</ref> createTBody();</webidl>
      <Type name="HTMLElement"/>
      <ArgumentList/>
    </Operation>
    <Attribute readonly="readonly" name="rows" id="::HTMLTableElement::rows">
      <webidl>  readonly attribute <ref>HTMLCollection</ref> rows;</webidl>
      <Type name="HTMLCollection"/>
    </Attribute>
    <Operation name="insertRow" id="::HTMLTableElement::insertRow">
      <webidl>  <ref>HTMLElement</ref> insertRow(optional long index = -1);</webidl>
      <Type name="HTMLElement"/>
      <ArgumentList>
        <Argument optional="optional" name="index" value="-1">
          <Type type="long"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="deleteRow" id="::HTMLTableElement::deleteRow">
      <webidl>  void deleteRow(long index);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument name="index">
          <Type type="long"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Attribute name="border" id="::HTMLTableElement::border">
      <webidl>           attribute DOMString border;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="sortable" id="::HTMLTableElement::sortable">
      <webidl>           attribute boolean sortable;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Operation name="stopSorting" id="::HTMLTableElement::stopSorting">
      <webidl>  void stopSorting();</webidl>
      <Type type="void"/>
      <ArgumentList/>
    </Operation>
  </Interface>
  <Interface name="HTMLTableCaptionElement" id="::HTMLTableCaptionElement">
    <webidl>interface HTMLTableCaptionElement : <ref>HTMLElement</ref> {};</webidl>
    <InterfaceInheritance>
      <Name name="HTMLElement"/>
    </InterfaceInheritance>
  </Interface>
  <Interface name="HTMLTableColElement" id="::HTMLTableColElement">
    <webidl>interface HTMLTableColElement : <ref>HTMLElement</ref> {
           attribute unsigned long span;
};</webidl>
    <InterfaceInheritance>
      <Name name="HTMLElement"/>
    </InterfaceInheritance>
    <Attribute name="span" id="::HTMLTableColElement::span">
      <webidl>           attribute unsigned long span;</webidl>
      <Type type="unsigned long"/>
    </Attribute>
  </Interface>
  <Interface name="HTMLTableSectionElement" id="::HTMLTableSectionElement">
    <webidl>interface HTMLTableSectionElement : <ref>HTMLElement</ref> {
  readonly attribute <ref>HTMLCollection</ref> rows;
  <ref>HTMLElement</ref> insertRow(optional long index = -1);
  void deleteRow(long index);
};</webidl>
    <InterfaceInheritance>
      <Name name="HTMLElement"/>
    </InterfaceInheritance>
    <Attribute readonly="readonly" name="rows" id="::HTMLTableSectionElement::rows">
      <webidl>  readonly attribute <ref>HTMLCollection</ref> rows;</webidl>
      <Type name="HTMLCollection"/>
    </Attribute>
    <Operation name="insertRow" id="::HTMLTableSectionElement::insertRow">
      <webidl>  <ref>HTMLElement</ref> insertRow(optional long index = -1);</webidl>
      <Type name="HTMLElement"/>
      <ArgumentList>
        <Argument optional="optional" name="index" value="-1">
          <Type type="long"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="deleteRow" id="::HTMLTableSectionElement::deleteRow">
      <webidl>  void deleteRow(long index);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument name="index">
          <Type type="long"/>
        </Argument>
      </ArgumentList>
    </Operation>
  </Interface>
  <Interface name="HTMLTableRowElement" id="::HTMLTableRowElement">
    <webidl>interface HTMLTableRowElement : <ref>HTMLElement</ref> {
  readonly attribute long rowIndex;
  readonly attribute long sectionRowIndex;
  readonly attribute <ref>HTMLCollection</ref> cells;
  <ref>HTMLElement</ref> insertCell(optional long index = -1);
  void deleteCell(long index);
};</webidl>
    <InterfaceInheritance>
      <Name name="HTMLElement"/>
    </InterfaceInheritance>
    <Attribute readonly="readonly" name="rowIndex" id="::HTMLTableRowElement::rowIndex">
      <webidl>  readonly attribute long rowIndex;</webidl>
      <Type type="long"/>
    </Attribute>
    <Attribute readonly="readonly" name="sectionRowIndex" id="::HTMLTableRowElement::sectionRowIndex">
      <webidl>  readonly attribute long sectionRowIndex;</webidl>
      <Type type="long"/>
    </Attribute>
    <Attribute readonly="readonly" name="cells" id="::HTMLTableRowElement::cells">
      <webidl>  readonly attribute <ref>HTMLCollection</ref> cells;</webidl>
      <Type name="HTMLCollection"/>
    </Attribute>
    <Operation name="insertCell" id="::HTMLTableRowElement::insertCell">
      <webidl>  <ref>HTMLElement</ref> insertCell(optional long index = -1);</webidl>
      <Type name="HTMLElement"/>
      <ArgumentList>
        <Argument optional="optional" name="index" value="-1">
          <Type type="long"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="deleteCell" id="::HTMLTableRowElement::deleteCell">
      <webidl>  void deleteCell(long index);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument name="index">
          <Type type="long"/>
        </Argument>
      </ArgumentList>
    </Operation>
  </Interface>
  <Interface name="HTMLTableDataCellElement" id="::HTMLTableDataCellElement">
    <webidl>interface HTMLTableDataCellElement : <ref>HTMLTableCellElement</ref> {};</webidl>
    <InterfaceInheritance>
      <Name name="HTMLTableCellElement"/>
    </InterfaceInheritance>
  </Interface>
  <Interface name="HTMLTableHeaderCellElement" id="::HTMLTableHeaderCellElement">
    <webidl>interface HTMLTableHeaderCellElement : <ref>HTMLTableCellElement</ref> {
           attribute DOMString scope;
           attribute DOMString abbr;
           attribute DOMString sorted;
  void sort();
};</webidl>
    <InterfaceInheritance>
      <Name name="HTMLTableCellElement"/>
    </InterfaceInheritance>
    <Attribute name="scope" id="::HTMLTableHeaderCellElement::scope">
      <webidl>           attribute DOMString scope;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="abbr" id="::HTMLTableHeaderCellElement::abbr">
      <webidl>           attribute DOMString abbr;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="sorted" id="::HTMLTableHeaderCellElement::sorted">
      <webidl>           attribute DOMString sorted;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Operation name="sort" id="::HTMLTableHeaderCellElement::sort">
      <webidl>  void sort();</webidl>
      <Type type="void"/>
      <ArgumentList/>
    </Operation>
  </Interface>
  <Interface name="HTMLTableCellElement" id="::HTMLTableCellElement">
    <webidl>interface HTMLTableCellElement : <ref>HTMLElement</ref> {
           attribute unsigned long colSpan;
           attribute unsigned long rowSpan;
  [PutForwards=value] readonly attribute <ref>DOMSettableTokenList</ref> headers;
  readonly attribute long cellIndex;
};</webidl>
    <InterfaceInheritance>
      <Name name="HTMLElement"/>
    </InterfaceInheritance>
    <Attribute name="colSpan" id="::HTMLTableCellElement::colSpan">
      <webidl>           attribute unsigned long colSpan;</webidl>
      <Type type="unsigned long"/>
    </Attribute>
    <Attribute name="rowSpan" id="::HTMLTableCellElement::rowSpan">
      <webidl>           attribute unsigned long rowSpan;</webidl>
      <Type type="unsigned long"/>
    </Attribute>
    <Attribute readonly="readonly" name="headers" id="::HTMLTableCellElement::headers">
      <webidl>  [PutForwards=value] readonly attribute <ref>DOMSettableTokenList</ref> headers;</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="PutForwards" value="value">
          <webidl>PutForwards</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type name="DOMSettableTokenList"/>
    </Attribute>
    <Attribute readonly="readonly" name="cellIndex" id="::HTMLTableCellElement::cellIndex">
      <webidl>  readonly attribute long cellIndex;</webidl>
      <Type type="long"/>
    </Attribute>
  </Interface>
  <Interface name="HTMLFormElement" id="::HTMLFormElement">
    <webidl>[OverrideBuiltins]
interface HTMLFormElement : <ref>HTMLElement</ref> {
           attribute DOMString acceptCharset;
           attribute DOMString action;
           attribute DOMString autocomplete;
           attribute DOMString enctype;
           attribute DOMString encoding;
           attribute DOMString method;
           attribute DOMString name;
           attribute boolean noValidate;
           attribute DOMString target;

  readonly attribute <ref>HTMLFormControlsCollection</ref> elements;
  readonly attribute long length;
  getter <ref>Element</ref> (unsigned long index);
  getter object (DOMString name);

  void submit();
  void reset();
  boolean checkValidity();
};</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="OverrideBuiltins">
        <webidl>OverrideBuiltins</webidl>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <InterfaceInheritance>
      <Name name="HTMLElement"/>
    </InterfaceInheritance>
    <Attribute name="acceptCharset" id="::HTMLFormElement::acceptCharset">
      <webidl>           attribute DOMString acceptCharset;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="action" id="::HTMLFormElement::action">
      <webidl>           attribute DOMString action;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="autocomplete" id="::HTMLFormElement::autocomplete">
      <webidl>           attribute DOMString autocomplete;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="enctype" id="::HTMLFormElement::enctype">
      <webidl>           attribute DOMString enctype;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="encoding" id="::HTMLFormElement::encoding">
      <webidl>           attribute DOMString encoding;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="method" id="::HTMLFormElement::method">
      <webidl>           attribute DOMString method;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="name" id="::HTMLFormElement::name">
      <webidl>           attribute DOMString name;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="noValidate" id="::HTMLFormElement::noValidate">
      <webidl>           attribute boolean noValidate;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute name="target" id="::HTMLFormElement::target">
      <webidl>           attribute DOMString target;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute readonly="readonly" name="elements" id="::HTMLFormElement::elements">
      <webidl>  readonly attribute <ref>HTMLFormControlsCollection</ref> elements;</webidl>
      <Type name="HTMLFormControlsCollection"/>
    </Attribute>
    <Attribute readonly="readonly" name="length" id="::HTMLFormElement::length">
      <webidl>  readonly attribute long length;</webidl>
      <Type type="long"/>
    </Attribute>
    <Operation getter="getter">
      <webidl>  getter <ref>Element</ref> (unsigned long index);</webidl>
      <Type name="Element"/>
      <ArgumentList>
        <Argument name="index">
          <Type type="unsigned long"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation getter="getter">
      <webidl>  getter object (DOMString name);</webidl>
      <Type type="object"/>
      <ArgumentList>
        <Argument name="name">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="submit" id="::HTMLFormElement::submit">
      <webidl>  void submit();</webidl>
      <Type type="void"/>
      <ArgumentList/>
    </Operation>
    <Operation name="reset" id="::HTMLFormElement::reset">
      <webidl>  void reset();</webidl>
      <Type type="void"/>
      <ArgumentList/>
    </Operation>
    <Operation name="checkValidity" id="::HTMLFormElement::checkValidity">
      <webidl>  boolean checkValidity();</webidl>
      <Type type="boolean"/>
      <ArgumentList/>
    </Operation>
  </Interface>
  <Interface name="HTMLFieldSetElement" id="::HTMLFieldSetElement">
    <webidl>interface HTMLFieldSetElement : <ref>HTMLElement</ref> {
           attribute boolean disabled;
  readonly attribute <ref>HTMLFormElement</ref>? form;
           attribute DOMString name;

  readonly attribute DOMString type;

  readonly attribute <ref>HTMLFormControlsCollection</ref> elements;

  readonly attribute boolean willValidate;
  readonly attribute <ref>ValidityState</ref> validity;
  readonly attribute DOMString validationMessage;
  boolean checkValidity();
  void setCustomValidity(DOMString error);
};</webidl>
    <InterfaceInheritance>
      <Name name="HTMLElement"/>
    </InterfaceInheritance>
    <Attribute name="disabled" id="::HTMLFieldSetElement::disabled">
      <webidl>           attribute boolean disabled;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute readonly="readonly" name="form" id="::HTMLFieldSetElement::form">
      <webidl>  readonly attribute <ref>HTMLFormElement</ref>? form;</webidl>
      <Type name="HTMLFormElement" nullable="nullable"/>
    </Attribute>
    <Attribute name="name" id="::HTMLFieldSetElement::name">
      <webidl>           attribute DOMString name;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute readonly="readonly" name="type" id="::HTMLFieldSetElement::type">
      <webidl>  readonly attribute DOMString type;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute readonly="readonly" name="elements" id="::HTMLFieldSetElement::elements">
      <webidl>  readonly attribute <ref>HTMLFormControlsCollection</ref> elements;</webidl>
      <Type name="HTMLFormControlsCollection"/>
    </Attribute>
    <Attribute readonly="readonly" name="willValidate" id="::HTMLFieldSetElement::willValidate">
      <webidl>  readonly attribute boolean willValidate;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute readonly="readonly" name="validity" id="::HTMLFieldSetElement::validity">
      <webidl>  readonly attribute <ref>ValidityState</ref> validity;</webidl>
      <Type name="ValidityState"/>
    </Attribute>
    <Attribute readonly="readonly" name="validationMessage" id="::HTMLFieldSetElement::validationMessage">
      <webidl>  readonly attribute DOMString validationMessage;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Operation name="checkValidity" id="::HTMLFieldSetElement::checkValidity">
      <webidl>  boolean checkValidity();</webidl>
      <Type type="boolean"/>
      <ArgumentList/>
    </Operation>
    <Operation name="setCustomValidity" id="::HTMLFieldSetElement::setCustomValidity">
      <webidl>  void setCustomValidity(DOMString error);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument name="error">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
  </Interface>
  <Interface name="HTMLLegendElement" id="::HTMLLegendElement">
    <webidl>interface HTMLLegendElement : <ref>HTMLElement</ref> {
  readonly attribute <ref>HTMLFormElement</ref>? form;
};</webidl>
    <InterfaceInheritance>
      <Name name="HTMLElement"/>
    </InterfaceInheritance>
    <Attribute readonly="readonly" name="form" id="::HTMLLegendElement::form">
      <webidl>  readonly attribute <ref>HTMLFormElement</ref>? form;</webidl>
      <Type name="HTMLFormElement" nullable="nullable"/>
    </Attribute>
  </Interface>
  <Interface name="HTMLLabelElement" id="::HTMLLabelElement">
    <webidl>interface HTMLLabelElement : <ref>HTMLElement</ref> {
  readonly attribute <ref>HTMLFormElement</ref>? form;
           attribute DOMString htmlFor;
  readonly attribute <ref>HTMLElement</ref>? control;
};</webidl>
    <InterfaceInheritance>
      <Name name="HTMLElement"/>
    </InterfaceInheritance>
    <Attribute readonly="readonly" name="form" id="::HTMLLabelElement::form">
      <webidl>  readonly attribute <ref>HTMLFormElement</ref>? form;</webidl>
      <Type name="HTMLFormElement" nullable="nullable"/>
    </Attribute>
    <Attribute name="htmlFor" id="::HTMLLabelElement::htmlFor">
      <webidl>           attribute DOMString htmlFor;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute readonly="readonly" name="control" id="::HTMLLabelElement::control">
      <webidl>  readonly attribute <ref>HTMLElement</ref>? control;</webidl>
      <Type name="HTMLElement" nullable="nullable"/>
    </Attribute>
  </Interface>
  <Interface name="HTMLInputElement" id="::HTMLInputElement">
    <webidl>interface HTMLInputElement : <ref>HTMLElement</ref> {
           attribute DOMString accept;
           attribute DOMString alt;
           attribute DOMString autocomplete;
           attribute boolean autofocus;
           attribute boolean defaultChecked;
           attribute boolean checked;
           attribute DOMString dirName;
           attribute boolean disabled;
  readonly attribute <ref>HTMLFormElement</ref>? form;
  readonly attribute <ref>FileList</ref>? files;
           attribute DOMString formAction;
           attribute DOMString formEnctype;
           attribute DOMString formMethod;
           attribute boolean formNoValidate;
           attribute DOMString formTarget;
           attribute unsigned long height;
           attribute boolean indeterminate;
           attribute DOMString inputMode;
  readonly attribute <ref>HTMLElement</ref>? list;
           attribute DOMString max;
           attribute long maxLength;
           attribute DOMString min;
           attribute boolean multiple;
           attribute DOMString name;
           attribute DOMString pattern;
           attribute DOMString placeholder;
           attribute boolean readOnly;
           attribute boolean required;
           attribute unsigned long size;
           attribute DOMString src;
           attribute DOMString step;
           attribute DOMString type;
           attribute DOMString defaultValue;
  [TreatNullAs=EmptyString] attribute DOMString value;
           attribute Date? valueAsDate;
           attribute unrestricted double valueAsNumber;
           attribute unsigned long width;

  void stepUp(optional long n = 1);
  void stepDown(optional long n = 1);

  readonly attribute boolean willValidate;
  readonly attribute <ref>ValidityState</ref> validity;
  readonly attribute DOMString validationMessage;
  boolean checkValidity();
  void setCustomValidity(DOMString error);

  readonly attribute <ref>NodeList</ref> labels;

  void select();
           attribute unsigned long selectionStart;
           attribute unsigned long selectionEnd;
           attribute DOMString selectionDirection;
  void setRangeText(DOMString replacement);
  void setRangeText(DOMString replacement, unsigned long start, unsigned long end, optional <ref>SelectionMode</ref> selectionMode);
  void setSelectionRange(unsigned long start, unsigned long end, optional DOMString direction);
};</webidl>
    <InterfaceInheritance>
      <Name name="HTMLElement"/>
    </InterfaceInheritance>
    <Attribute name="accept" id="::HTMLInputElement::accept">
      <webidl>           attribute DOMString accept;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="alt" id="::HTMLInputElement::alt">
      <webidl>           attribute DOMString alt;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="autocomplete" id="::HTMLInputElement::autocomplete">
      <webidl>           attribute DOMString autocomplete;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="autofocus" id="::HTMLInputElement::autofocus">
      <webidl>           attribute boolean autofocus;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute name="defaultChecked" id="::HTMLInputElement::defaultChecked">
      <webidl>           attribute boolean defaultChecked;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute name="checked" id="::HTMLInputElement::checked">
      <webidl>           attribute boolean checked;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute name="dirName" id="::HTMLInputElement::dirName">
      <webidl>           attribute DOMString dirName;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="disabled" id="::HTMLInputElement::disabled">
      <webidl>           attribute boolean disabled;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute readonly="readonly" name="form" id="::HTMLInputElement::form">
      <webidl>  readonly attribute <ref>HTMLFormElement</ref>? form;</webidl>
      <Type name="HTMLFormElement" nullable="nullable"/>
    </Attribute>
    <Attribute readonly="readonly" name="files" id="::HTMLInputElement::files">
      <webidl>  readonly attribute <ref>FileList</ref>? files;</webidl>
      <Type name="FileList" nullable="nullable"/>
    </Attribute>
    <Attribute name="formAction" id="::HTMLInputElement::formAction">
      <webidl>           attribute DOMString formAction;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="formEnctype" id="::HTMLInputElement::formEnctype">
      <webidl>           attribute DOMString formEnctype;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="formMethod" id="::HTMLInputElement::formMethod">
      <webidl>           attribute DOMString formMethod;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="formNoValidate" id="::HTMLInputElement::formNoValidate">
      <webidl>           attribute boolean formNoValidate;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute name="formTarget" id="::HTMLInputElement::formTarget">
      <webidl>           attribute DOMString formTarget;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="height" id="::HTMLInputElement::height">
      <webidl>           attribute unsigned long height;</webidl>
      <Type type="unsigned long"/>
    </Attribute>
    <Attribute name="indeterminate" id="::HTMLInputElement::indeterminate">
      <webidl>           attribute boolean indeterminate;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute name="inputMode" id="::HTMLInputElement::inputMode">
      <webidl>           attribute DOMString inputMode;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute readonly="readonly" name="list" id="::HTMLInputElement::list">
      <webidl>  readonly attribute <ref>HTMLElement</ref>? list;</webidl>
      <Type name="HTMLElement" nullable="nullable"/>
    </Attribute>
    <Attribute name="max" id="::HTMLInputElement::max">
      <webidl>           attribute DOMString max;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="maxLength" id="::HTMLInputElement::maxLength">
      <webidl>           attribute long maxLength;</webidl>
      <Type type="long"/>
    </Attribute>
    <Attribute name="min" id="::HTMLInputElement::min">
      <webidl>           attribute DOMString min;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="multiple" id="::HTMLInputElement::multiple">
      <webidl>           attribute boolean multiple;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute name="name" id="::HTMLInputElement::name">
      <webidl>           attribute DOMString name;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="pattern" id="::HTMLInputElement::pattern">
      <webidl>           attribute DOMString pattern;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="placeholder" id="::HTMLInputElement::placeholder">
      <webidl>           attribute DOMString placeholder;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="readOnly" id="::HTMLInputElement::readOnly">
      <webidl>           attribute boolean readOnly;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute name="required" id="::HTMLInputElement::required">
      <webidl>           attribute boolean required;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute name="size" id="::HTMLInputElement::size">
      <webidl>           attribute unsigned long size;</webidl>
      <Type type="unsigned long"/>
    </Attribute>
    <Attribute name="src" id="::HTMLInputElement::src">
      <webidl>           attribute DOMString src;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="step" id="::HTMLInputElement::step">
      <webidl>           attribute DOMString step;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="type" id="::HTMLInputElement::type">
      <webidl>           attribute DOMString type;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="defaultValue" id="::HTMLInputElement::defaultValue">
      <webidl>           attribute DOMString defaultValue;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="value" id="::HTMLInputElement::value">
      <webidl>  [TreatNullAs=EmptyString] attribute DOMString value;</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="TreatNullAs" value="EmptyString">
          <webidl>TreatNullAs</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="valueAsDate" id="::HTMLInputElement::valueAsDate">
      <webidl>           attribute Date? valueAsDate;</webidl>
      <Type type="Date" nullable="nullable"/>
    </Attribute>
    <Attribute name="valueAsNumber" id="::HTMLInputElement::valueAsNumber">
      <webidl>           attribute unrestricted double valueAsNumber;</webidl>
      <Type type="unrestricted double"/>
    </Attribute>
    <Attribute name="width" id="::HTMLInputElement::width">
      <webidl>           attribute unsigned long width;</webidl>
      <Type type="unsigned long"/>
    </Attribute>
    <Operation name="stepUp" id="::HTMLInputElement::stepUp">
      <webidl>  void stepUp(optional long n = 1);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument optional="optional" name="n" value="1">
          <Type type="long"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="stepDown" id="::HTMLInputElement::stepDown">
      <webidl>  void stepDown(optional long n = 1);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument optional="optional" name="n" value="1">
          <Type type="long"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Attribute readonly="readonly" name="willValidate" id="::HTMLInputElement::willValidate">
      <webidl>  readonly attribute boolean willValidate;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute readonly="readonly" name="validity" id="::HTMLInputElement::validity">
      <webidl>  readonly attribute <ref>ValidityState</ref> validity;</webidl>
      <Type name="ValidityState"/>
    </Attribute>
    <Attribute readonly="readonly" name="validationMessage" id="::HTMLInputElement::validationMessage">
      <webidl>  readonly attribute DOMString validationMessage;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Operation name="checkValidity" id="::HTMLInputElement::checkValidity">
      <webidl>  boolean checkValidity();</webidl>
      <Type type="boolean"/>
      <ArgumentList/>
    </Operation>
    <Operation name="setCustomValidity" id="::HTMLInputElement::setCustomValidity">
      <webidl>  void setCustomValidity(DOMString error);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument name="error">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Attribute readonly="readonly" name="labels" id="::HTMLInputElement::labels">
      <webidl>  readonly attribute <ref>NodeList</ref> labels;</webidl>
      <Type name="NodeList"/>
    </Attribute>
    <Operation name="select" id="::HTMLInputElement::select">
      <webidl>  void select();</webidl>
      <Type type="void"/>
      <ArgumentList/>
    </Operation>
    <Attribute name="selectionStart" id="::HTMLInputElement::selectionStart">
      <webidl>           attribute unsigned long selectionStart;</webidl>
      <Type type="unsigned long"/>
    </Attribute>
    <Attribute name="selectionEnd" id="::HTMLInputElement::selectionEnd">
      <webidl>           attribute unsigned long selectionEnd;</webidl>
      <Type type="unsigned long"/>
    </Attribute>
    <Attribute name="selectionDirection" id="::HTMLInputElement::selectionDirection">
      <webidl>           attribute DOMString selectionDirection;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Operation name="setRangeText" id="::HTMLInputElement::setRangeText">
      <webidl>  void setRangeText(DOMString replacement);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument name="replacement">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="setRangeText" id="::HTMLInputElement::setRangeText">
      <webidl>  void setRangeText(DOMString replacement, unsigned long start, unsigned long end, optional <ref>SelectionMode</ref> selectionMode);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument name="replacement">
          <Type type="DOMString"/>
        </Argument>
        <Argument name="start">
          <Type type="unsigned long"/>
        </Argument>
        <Argument name="end">
          <Type type="unsigned long"/>
        </Argument>
        <Argument optional="optional" name="selectionMode">
          <Type name="SelectionMode"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="setSelectionRange" id="::HTMLInputElement::setSelectionRange">
      <webidl>  void setSelectionRange(unsigned long start, unsigned long end, optional DOMString direction);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument name="start">
          <Type type="unsigned long"/>
        </Argument>
        <Argument name="end">
          <Type type="unsigned long"/>
        </Argument>
        <Argument optional="optional" name="direction">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
  </Interface>
  <Interface name="HTMLButtonElement" id="::HTMLButtonElement">
    <webidl>interface HTMLButtonElement : <ref>HTMLElement</ref> {
           attribute boolean autofocus;
           attribute boolean disabled;
  readonly attribute <ref>HTMLFormElement</ref>? form;
           attribute DOMString formAction;
           attribute DOMString formEnctype;
           attribute DOMString formMethod;
           attribute boolean formNoValidate;
           attribute DOMString formTarget;
           attribute DOMString name;
           attribute DOMString type;
           attribute DOMString value;
           attribute <ref>HTMLMenuElement</ref>? menu;

  readonly attribute boolean willValidate;
  readonly attribute <ref>ValidityState</ref> validity;
  readonly attribute DOMString validationMessage;
  boolean checkValidity();
  void setCustomValidity(DOMString error);

  readonly attribute <ref>NodeList</ref> labels;
};</webidl>
    <InterfaceInheritance>
      <Name name="HTMLElement"/>
    </InterfaceInheritance>
    <Attribute name="autofocus" id="::HTMLButtonElement::autofocus">
      <webidl>           attribute boolean autofocus;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute name="disabled" id="::HTMLButtonElement::disabled">
      <webidl>           attribute boolean disabled;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute readonly="readonly" name="form" id="::HTMLButtonElement::form">
      <webidl>  readonly attribute <ref>HTMLFormElement</ref>? form;</webidl>
      <Type name="HTMLFormElement" nullable="nullable"/>
    </Attribute>
    <Attribute name="formAction" id="::HTMLButtonElement::formAction">
      <webidl>           attribute DOMString formAction;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="formEnctype" id="::HTMLButtonElement::formEnctype">
      <webidl>           attribute DOMString formEnctype;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="formMethod" id="::HTMLButtonElement::formMethod">
      <webidl>           attribute DOMString formMethod;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="formNoValidate" id="::HTMLButtonElement::formNoValidate">
      <webidl>           attribute boolean formNoValidate;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute name="formTarget" id="::HTMLButtonElement::formTarget">
      <webidl>           attribute DOMString formTarget;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="name" id="::HTMLButtonElement::name">
      <webidl>           attribute DOMString name;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="type" id="::HTMLButtonElement::type">
      <webidl>           attribute DOMString type;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="value" id="::HTMLButtonElement::value">
      <webidl>           attribute DOMString value;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="menu" id="::HTMLButtonElement::menu">
      <webidl>           attribute <ref>HTMLMenuElement</ref>? menu;</webidl>
      <Type name="HTMLMenuElement" nullable="nullable"/>
    </Attribute>
    <Attribute readonly="readonly" name="willValidate" id="::HTMLButtonElement::willValidate">
      <webidl>  readonly attribute boolean willValidate;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute readonly="readonly" name="validity" id="::HTMLButtonElement::validity">
      <webidl>  readonly attribute <ref>ValidityState</ref> validity;</webidl>
      <Type name="ValidityState"/>
    </Attribute>
    <Attribute readonly="readonly" name="validationMessage" id="::HTMLButtonElement::validationMessage">
      <webidl>  readonly attribute DOMString validationMessage;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Operation name="checkValidity" id="::HTMLButtonElement::checkValidity">
      <webidl>  boolean checkValidity();</webidl>
      <Type type="boolean"/>
      <ArgumentList/>
    </Operation>
    <Operation name="setCustomValidity" id="::HTMLButtonElement::setCustomValidity">
      <webidl>  void setCustomValidity(DOMString error);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument name="error">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Attribute readonly="readonly" name="labels" id="::HTMLButtonElement::labels">
      <webidl>  readonly attribute <ref>NodeList</ref> labels;</webidl>
      <Type name="NodeList"/>
    </Attribute>
  </Interface>
  <Interface name="HTMLSelectElement" id="::HTMLSelectElement">
    <webidl>interface HTMLSelectElement : <ref>HTMLElement</ref> {
           attribute boolean autofocus;
           attribute boolean disabled;
  readonly attribute <ref>HTMLFormElement</ref>? form;
           attribute boolean multiple;
           attribute DOMString name;
           attribute boolean required;
           attribute unsigned long size;

  readonly attribute DOMString type;

  readonly attribute <ref>HTMLOptionsCollection</ref> options;
           attribute unsigned long length;
  getter <ref>Element</ref> item(unsigned long index);
  object namedItem(DOMString name);
  void add((<ref>HTMLOptionElement</ref> or <ref>HTMLOptGroupElement</ref>) element, optional (<ref>HTMLElement</ref> or long)? before = null);
  void remove(long index);
  setter creator void (unsigned long index, <ref>HTMLOptionElement</ref>? option);

  readonly attribute <ref>HTMLCollection</ref> selectedOptions;
           attribute long selectedIndex;
           attribute DOMString value;

  readonly attribute boolean willValidate;
  readonly attribute <ref>ValidityState</ref> validity;
  readonly attribute DOMString validationMessage;
  boolean checkValidity();
  void setCustomValidity(DOMString error);

  readonly attribute <ref>NodeList</ref> labels;
};</webidl>
    <InterfaceInheritance>
      <Name name="HTMLElement"/>
    </InterfaceInheritance>
    <Attribute name="autofocus" id="::HTMLSelectElement::autofocus">
      <webidl>           attribute boolean autofocus;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute name="disabled" id="::HTMLSelectElement::disabled">
      <webidl>           attribute boolean disabled;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute readonly="readonly" name="form" id="::HTMLSelectElement::form">
      <webidl>  readonly attribute <ref>HTMLFormElement</ref>? form;</webidl>
      <Type name="HTMLFormElement" nullable="nullable"/>
    </Attribute>
    <Attribute name="multiple" id="::HTMLSelectElement::multiple">
      <webidl>           attribute boolean multiple;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute name="name" id="::HTMLSelectElement::name">
      <webidl>           attribute DOMString name;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="required" id="::HTMLSelectElement::required">
      <webidl>           attribute boolean required;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute name="size" id="::HTMLSelectElement::size">
      <webidl>           attribute unsigned long size;</webidl>
      <Type type="unsigned long"/>
    </Attribute>
    <Attribute readonly="readonly" name="type" id="::HTMLSelectElement::type">
      <webidl>  readonly attribute DOMString type;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute readonly="readonly" name="options" id="::HTMLSelectElement::options">
      <webidl>  readonly attribute <ref>HTMLOptionsCollection</ref> options;</webidl>
      <Type name="HTMLOptionsCollection"/>
    </Attribute>
    <Attribute name="length" id="::HTMLSelectElement::length">
      <webidl>           attribute unsigned long length;</webidl>
      <Type type="unsigned long"/>
    </Attribute>
    <Operation getter="getter" name="item" id="::HTMLSelectElement::item">
      <webidl>  getter <ref>Element</ref> item(unsigned long index);</webidl>
      <Type name="Element"/>
      <ArgumentList>
        <Argument name="index">
          <Type type="unsigned long"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="namedItem" id="::HTMLSelectElement::namedItem">
      <webidl>  object namedItem(DOMString name);</webidl>
      <Type type="object"/>
      <ArgumentList>
        <Argument name="name">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="add" id="::HTMLSelectElement::add">
      <webidl>  void add((<ref>HTMLOptionElement</ref> or <ref>HTMLOptGroupElement</ref>) element, optional (<ref>HTMLElement</ref> or long)? before = null);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument name="element">
          <Type type="union">
            <Type name="HTMLOptionElement"/>
            <Type name="HTMLOptGroupElement"/>
          </Type>
        </Argument>
        <Argument optional="optional" name="before" value="null">
          <Type type="union" nullable="nullable">
            <Type name="HTMLElement"/>
            <Type type="long"/>
          </Type>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="remove" id="::HTMLSelectElement::remove">
      <webidl>  void remove(long index);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument name="index">
          <Type type="long"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation setter="setter" creator="creator">
      <webidl>  setter creator void (unsigned long index, <ref>HTMLOptionElement</ref>? option);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument name="index">
          <Type type="unsigned long"/>
        </Argument>
        <Argument name="option">
          <Type name="HTMLOptionElement" nullable="nullable"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Attribute readonly="readonly" name="selectedOptions" id="::HTMLSelectElement::selectedOptions">
      <webidl>  readonly attribute <ref>HTMLCollection</ref> selectedOptions;</webidl>
      <Type name="HTMLCollection"/>
    </Attribute>
    <Attribute name="selectedIndex" id="::HTMLSelectElement::selectedIndex">
      <webidl>           attribute long selectedIndex;</webidl>
      <Type type="long"/>
    </Attribute>
    <Attribute name="value" id="::HTMLSelectElement::value">
      <webidl>           attribute DOMString value;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute readonly="readonly" name="willValidate" id="::HTMLSelectElement::willValidate">
      <webidl>  readonly attribute boolean willValidate;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute readonly="readonly" name="validity" id="::HTMLSelectElement::validity">
      <webidl>  readonly attribute <ref>ValidityState</ref> validity;</webidl>
      <Type name="ValidityState"/>
    </Attribute>
    <Attribute readonly="readonly" name="validationMessage" id="::HTMLSelectElement::validationMessage">
      <webidl>  readonly attribute DOMString validationMessage;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Operation name="checkValidity" id="::HTMLSelectElement::checkValidity">
      <webidl>  boolean checkValidity();</webidl>
      <Type type="boolean"/>
      <ArgumentList/>
    </Operation>
    <Operation name="setCustomValidity" id="::HTMLSelectElement::setCustomValidity">
      <webidl>  void setCustomValidity(DOMString error);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument name="error">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Attribute readonly="readonly" name="labels" id="::HTMLSelectElement::labels">
      <webidl>  readonly attribute <ref>NodeList</ref> labels;</webidl>
      <Type name="NodeList"/>
    </Attribute>
  </Interface>
  <Interface name="HTMLDataListElement" id="::HTMLDataListElement">
    <webidl>interface HTMLDataListElement : <ref>HTMLElement</ref> {
  readonly attribute <ref>HTMLCollection</ref> options;
};</webidl>
    <InterfaceInheritance>
      <Name name="HTMLElement"/>
    </InterfaceInheritance>
    <Attribute readonly="readonly" name="options" id="::HTMLDataListElement::options">
      <webidl>  readonly attribute <ref>HTMLCollection</ref> options;</webidl>
      <Type name="HTMLCollection"/>
    </Attribute>
  </Interface>
  <Interface name="HTMLOptGroupElement" id="::HTMLOptGroupElement">
    <webidl>interface HTMLOptGroupElement : <ref>HTMLElement</ref> {
           attribute boolean disabled;
           attribute DOMString label;
};</webidl>
    <InterfaceInheritance>
      <Name name="HTMLElement"/>
    </InterfaceInheritance>
    <Attribute name="disabled" id="::HTMLOptGroupElement::disabled">
      <webidl>           attribute boolean disabled;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute name="label" id="::HTMLOptGroupElement::label">
      <webidl>           attribute DOMString label;</webidl>
      <Type type="DOMString"/>
    </Attribute>
  </Interface>
  <Interface name="HTMLOptionElement" id="::HTMLOptionElement">
    <webidl>[NamedConstructor=Option(optional DOMString text = &quot;&quot;, optional DOMString value, optional boolean defaultSelected = false, optional boolean selected = false)]
interface HTMLOptionElement : <ref>HTMLElement</ref> {
           attribute boolean disabled;
  readonly attribute <ref>HTMLFormElement</ref>? form;
           attribute DOMString label;
           attribute boolean defaultSelected;
           attribute boolean selected;
           attribute DOMString value;

           attribute DOMString text;
  readonly attribute long index;
};</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="NamedConstructor" value="Option">
        <webidl>NamedConstructor=Option(optional DOMString text = &quot;&quot;, optional DOMString value, optional boolean defaultSelected = false, optional boolean selected = false)</webidl>
        <ArgumentList>
          <Argument optional="optional" name="text" stringvalue="">
            <Type type="DOMString"/>
          </Argument>
          <Argument optional="optional" name="value">
            <Type type="DOMString"/>
          </Argument>
          <Argument optional="optional" name="defaultSelected" value="false">
            <Type type="boolean"/>
          </Argument>
          <Argument optional="optional" name="selected" value="false">
            <Type type="boolean"/>
          </Argument>
        </ArgumentList>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <InterfaceInheritance>
      <Name name="HTMLElement"/>
    </InterfaceInheritance>
    <Attribute name="disabled" id="::HTMLOptionElement::disabled">
      <webidl>           attribute boolean disabled;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute readonly="readonly" name="form" id="::HTMLOptionElement::form">
      <webidl>  readonly attribute <ref>HTMLFormElement</ref>? form;</webidl>
      <Type name="HTMLFormElement" nullable="nullable"/>
    </Attribute>
    <Attribute name="label" id="::HTMLOptionElement::label">
      <webidl>           attribute DOMString label;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="defaultSelected" id="::HTMLOptionElement::defaultSelected">
      <webidl>           attribute boolean defaultSelected;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute name="selected" id="::HTMLOptionElement::selected">
      <webidl>           attribute boolean selected;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute name="value" id="::HTMLOptionElement::value">
      <webidl>           attribute DOMString value;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="text" id="::HTMLOptionElement::text">
      <webidl>           attribute DOMString text;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute readonly="readonly" name="index" id="::HTMLOptionElement::index">
      <webidl>  readonly attribute long index;</webidl>
      <Type type="long"/>
    </Attribute>
  </Interface>
  <Interface name="HTMLTextAreaElement" id="::HTMLTextAreaElement">
    <webidl>interface HTMLTextAreaElement : <ref>HTMLElement</ref> {
           attribute DOMString autocomplete;
           attribute boolean autofocus;
           attribute unsigned long cols;
           attribute DOMString dirName;
           attribute boolean disabled;
  readonly attribute <ref>HTMLFormElement</ref>? form;
           attribute DOMString inputMode;
           attribute long maxLength;
           attribute DOMString name;
           attribute DOMString placeholder;
           attribute boolean readOnly;
           attribute boolean required;
           attribute unsigned long rows;
           attribute DOMString wrap;

  readonly attribute DOMString type;
           attribute DOMString defaultValue;
  [TreatNullAs=EmptyString] attribute DOMString value;
  readonly attribute unsigned long textLength;

  readonly attribute boolean willValidate;
  readonly attribute <ref>ValidityState</ref> validity;
  readonly attribute DOMString validationMessage;
  boolean checkValidity();
  void setCustomValidity(DOMString error);

  readonly attribute <ref>NodeList</ref> labels;

  void select();
           attribute unsigned long selectionStart;
           attribute unsigned long selectionEnd;
           attribute DOMString selectionDirection;
  void setRangeText(DOMString replacement);
  void setRangeText(DOMString replacement, unsigned long start, unsigned long end, optional <ref>SelectionMode</ref> selectionMode);
  void setSelectionRange(unsigned long start, unsigned long end, optional DOMString direction);
};</webidl>
    <InterfaceInheritance>
      <Name name="HTMLElement"/>
    </InterfaceInheritance>
    <Attribute name="autocomplete" id="::HTMLTextAreaElement::autocomplete">
      <webidl>           attribute DOMString autocomplete;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="autofocus" id="::HTMLTextAreaElement::autofocus">
      <webidl>           attribute boolean autofocus;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute name="cols" id="::HTMLTextAreaElement::cols">
      <webidl>           attribute unsigned long cols;</webidl>
      <Type type="unsigned long"/>
    </Attribute>
    <Attribute name="dirName" id="::HTMLTextAreaElement::dirName">
      <webidl>           attribute DOMString dirName;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="disabled" id="::HTMLTextAreaElement::disabled">
      <webidl>           attribute boolean disabled;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute readonly="readonly" name="form" id="::HTMLTextAreaElement::form">
      <webidl>  readonly attribute <ref>HTMLFormElement</ref>? form;</webidl>
      <Type name="HTMLFormElement" nullable="nullable"/>
    </Attribute>
    <Attribute name="inputMode" id="::HTMLTextAreaElement::inputMode">
      <webidl>           attribute DOMString inputMode;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="maxLength" id="::HTMLTextAreaElement::maxLength">
      <webidl>           attribute long maxLength;</webidl>
      <Type type="long"/>
    </Attribute>
    <Attribute name="name" id="::HTMLTextAreaElement::name">
      <webidl>           attribute DOMString name;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="placeholder" id="::HTMLTextAreaElement::placeholder">
      <webidl>           attribute DOMString placeholder;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="readOnly" id="::HTMLTextAreaElement::readOnly">
      <webidl>           attribute boolean readOnly;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute name="required" id="::HTMLTextAreaElement::required">
      <webidl>           attribute boolean required;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute name="rows" id="::HTMLTextAreaElement::rows">
      <webidl>           attribute unsigned long rows;</webidl>
      <Type type="unsigned long"/>
    </Attribute>
    <Attribute name="wrap" id="::HTMLTextAreaElement::wrap">
      <webidl>           attribute DOMString wrap;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute readonly="readonly" name="type" id="::HTMLTextAreaElement::type">
      <webidl>  readonly attribute DOMString type;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="defaultValue" id="::HTMLTextAreaElement::defaultValue">
      <webidl>           attribute DOMString defaultValue;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="value" id="::HTMLTextAreaElement::value">
      <webidl>  [TreatNullAs=EmptyString] attribute DOMString value;</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="TreatNullAs" value="EmptyString">
          <webidl>TreatNullAs</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute readonly="readonly" name="textLength" id="::HTMLTextAreaElement::textLength">
      <webidl>  readonly attribute unsigned long textLength;</webidl>
      <Type type="unsigned long"/>
    </Attribute>
    <Attribute readonly="readonly" name="willValidate" id="::HTMLTextAreaElement::willValidate">
      <webidl>  readonly attribute boolean willValidate;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute readonly="readonly" name="validity" id="::HTMLTextAreaElement::validity">
      <webidl>  readonly attribute <ref>ValidityState</ref> validity;</webidl>
      <Type name="ValidityState"/>
    </Attribute>
    <Attribute readonly="readonly" name="validationMessage" id="::HTMLTextAreaElement::validationMessage">
      <webidl>  readonly attribute DOMString validationMessage;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Operation name="checkValidity" id="::HTMLTextAreaElement::checkValidity">
      <webidl>  boolean checkValidity();</webidl>
      <Type type="boolean"/>
      <ArgumentList/>
    </Operation>
    <Operation name="setCustomValidity" id="::HTMLTextAreaElement::setCustomValidity">
      <webidl>  void setCustomValidity(DOMString error);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument name="error">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Attribute readonly="readonly" name="labels" id="::HTMLTextAreaElement::labels">
      <webidl>  readonly attribute <ref>NodeList</ref> labels;</webidl>
      <Type name="NodeList"/>
    </Attribute>
    <Operation name="select" id="::HTMLTextAreaElement::select">
      <webidl>  void select();</webidl>
      <Type type="void"/>
      <ArgumentList/>
    </Operation>
    <Attribute name="selectionStart" id="::HTMLTextAreaElement::selectionStart">
      <webidl>           attribute unsigned long selectionStart;</webidl>
      <Type type="unsigned long"/>
    </Attribute>
    <Attribute name="selectionEnd" id="::HTMLTextAreaElement::selectionEnd">
      <webidl>           attribute unsigned long selectionEnd;</webidl>
      <Type type="unsigned long"/>
    </Attribute>
    <Attribute name="selectionDirection" id="::HTMLTextAreaElement::selectionDirection">
      <webidl>           attribute DOMString selectionDirection;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Operation name="setRangeText" id="::HTMLTextAreaElement::setRangeText">
      <webidl>  void setRangeText(DOMString replacement);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument name="replacement">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="setRangeText" id="::HTMLTextAreaElement::setRangeText">
      <webidl>  void setRangeText(DOMString replacement, unsigned long start, unsigned long end, optional <ref>SelectionMode</ref> selectionMode);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument name="replacement">
          <Type type="DOMString"/>
        </Argument>
        <Argument name="start">
          <Type type="unsigned long"/>
        </Argument>
        <Argument name="end">
          <Type type="unsigned long"/>
        </Argument>
        <Argument optional="optional" name="selectionMode">
          <Type name="SelectionMode"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="setSelectionRange" id="::HTMLTextAreaElement::setSelectionRange">
      <webidl>  void setSelectionRange(unsigned long start, unsigned long end, optional DOMString direction);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument name="start">
          <Type type="unsigned long"/>
        </Argument>
        <Argument name="end">
          <Type type="unsigned long"/>
        </Argument>
        <Argument optional="optional" name="direction">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
  </Interface>
  <Interface name="HTMLKeygenElement" id="::HTMLKeygenElement">
    <webidl>interface HTMLKeygenElement : <ref>HTMLElement</ref> {
           attribute boolean autofocus;
           attribute DOMString challenge;
           attribute boolean disabled;
  readonly attribute <ref>HTMLFormElement</ref>? form;
           attribute DOMString keytype;
           attribute DOMString name;

  readonly attribute DOMString type;

  readonly attribute boolean willValidate;
  readonly attribute <ref>ValidityState</ref> validity;
  readonly attribute DOMString validationMessage;
  boolean checkValidity();
  void setCustomValidity(DOMString error);

  readonly attribute <ref>NodeList</ref> labels;
};</webidl>
    <InterfaceInheritance>
      <Name name="HTMLElement"/>
    </InterfaceInheritance>
    <Attribute name="autofocus" id="::HTMLKeygenElement::autofocus">
      <webidl>           attribute boolean autofocus;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute name="challenge" id="::HTMLKeygenElement::challenge">
      <webidl>           attribute DOMString challenge;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="disabled" id="::HTMLKeygenElement::disabled">
      <webidl>           attribute boolean disabled;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute readonly="readonly" name="form" id="::HTMLKeygenElement::form">
      <webidl>  readonly attribute <ref>HTMLFormElement</ref>? form;</webidl>
      <Type name="HTMLFormElement" nullable="nullable"/>
    </Attribute>
    <Attribute name="keytype" id="::HTMLKeygenElement::keytype">
      <webidl>           attribute DOMString keytype;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="name" id="::HTMLKeygenElement::name">
      <webidl>           attribute DOMString name;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute readonly="readonly" name="type" id="::HTMLKeygenElement::type">
      <webidl>  readonly attribute DOMString type;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute readonly="readonly" name="willValidate" id="::HTMLKeygenElement::willValidate">
      <webidl>  readonly attribute boolean willValidate;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute readonly="readonly" name="validity" id="::HTMLKeygenElement::validity">
      <webidl>  readonly attribute <ref>ValidityState</ref> validity;</webidl>
      <Type name="ValidityState"/>
    </Attribute>
    <Attribute readonly="readonly" name="validationMessage" id="::HTMLKeygenElement::validationMessage">
      <webidl>  readonly attribute DOMString validationMessage;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Operation name="checkValidity" id="::HTMLKeygenElement::checkValidity">
      <webidl>  boolean checkValidity();</webidl>
      <Type type="boolean"/>
      <ArgumentList/>
    </Operation>
    <Operation name="setCustomValidity" id="::HTMLKeygenElement::setCustomValidity">
      <webidl>  void setCustomValidity(DOMString error);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument name="error">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Attribute readonly="readonly" name="labels" id="::HTMLKeygenElement::labels">
      <webidl>  readonly attribute <ref>NodeList</ref> labels;</webidl>
      <Type name="NodeList"/>
    </Attribute>
  </Interface>
  <Interface name="HTMLOutputElement" id="::HTMLOutputElement">
    <webidl>interface HTMLOutputElement : <ref>HTMLElement</ref> {
  [PutForwards=value] readonly attribute <ref>DOMSettableTokenList</ref> htmlFor;
  readonly attribute <ref>HTMLFormElement</ref>? form;
           attribute DOMString name;

  readonly attribute DOMString type;
           attribute DOMString defaultValue;
           attribute DOMString value;

  readonly attribute boolean willValidate;
  readonly attribute <ref>ValidityState</ref> validity;
  readonly attribute DOMString validationMessage;
  boolean checkValidity();
  void setCustomValidity(DOMString error);

  readonly attribute <ref>NodeList</ref> labels;
};</webidl>
    <InterfaceInheritance>
      <Name name="HTMLElement"/>
    </InterfaceInheritance>
    <Attribute readonly="readonly" name="htmlFor" id="::HTMLOutputElement::htmlFor">
      <webidl>  [PutForwards=value] readonly attribute <ref>DOMSettableTokenList</ref> htmlFor;</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="PutForwards" value="value">
          <webidl>PutForwards</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type name="DOMSettableTokenList"/>
    </Attribute>
    <Attribute readonly="readonly" name="form" id="::HTMLOutputElement::form">
      <webidl>  readonly attribute <ref>HTMLFormElement</ref>? form;</webidl>
      <Type name="HTMLFormElement" nullable="nullable"/>
    </Attribute>
    <Attribute name="name" id="::HTMLOutputElement::name">
      <webidl>           attribute DOMString name;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute readonly="readonly" name="type" id="::HTMLOutputElement::type">
      <webidl>  readonly attribute DOMString type;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="defaultValue" id="::HTMLOutputElement::defaultValue">
      <webidl>           attribute DOMString defaultValue;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="value" id="::HTMLOutputElement::value">
      <webidl>           attribute DOMString value;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute readonly="readonly" name="willValidate" id="::HTMLOutputElement::willValidate">
      <webidl>  readonly attribute boolean willValidate;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute readonly="readonly" name="validity" id="::HTMLOutputElement::validity">
      <webidl>  readonly attribute <ref>ValidityState</ref> validity;</webidl>
      <Type name="ValidityState"/>
    </Attribute>
    <Attribute readonly="readonly" name="validationMessage" id="::HTMLOutputElement::validationMessage">
      <webidl>  readonly attribute DOMString validationMessage;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Operation name="checkValidity" id="::HTMLOutputElement::checkValidity">
      <webidl>  boolean checkValidity();</webidl>
      <Type type="boolean"/>
      <ArgumentList/>
    </Operation>
    <Operation name="setCustomValidity" id="::HTMLOutputElement::setCustomValidity">
      <webidl>  void setCustomValidity(DOMString error);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument name="error">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Attribute readonly="readonly" name="labels" id="::HTMLOutputElement::labels">
      <webidl>  readonly attribute <ref>NodeList</ref> labels;</webidl>
      <Type name="NodeList"/>
    </Attribute>
  </Interface>
  <Interface name="HTMLProgressElement" id="::HTMLProgressElement">
    <webidl>interface HTMLProgressElement : <ref>HTMLElement</ref> {
           attribute double value;
           attribute double max;
  readonly attribute double position;
  readonly attribute <ref>NodeList</ref> labels;
};</webidl>
    <InterfaceInheritance>
      <Name name="HTMLElement"/>
    </InterfaceInheritance>
    <Attribute name="value" id="::HTMLProgressElement::value">
      <webidl>           attribute double value;</webidl>
      <Type type="double"/>
    </Attribute>
    <Attribute name="max" id="::HTMLProgressElement::max">
      <webidl>           attribute double max;</webidl>
      <Type type="double"/>
    </Attribute>
    <Attribute readonly="readonly" name="position" id="::HTMLProgressElement::position">
      <webidl>  readonly attribute double position;</webidl>
      <Type type="double"/>
    </Attribute>
    <Attribute readonly="readonly" name="labels" id="::HTMLProgressElement::labels">
      <webidl>  readonly attribute <ref>NodeList</ref> labels;</webidl>
      <Type name="NodeList"/>
    </Attribute>
  </Interface>
  <Interface name="HTMLMeterElement" id="::HTMLMeterElement">
    <webidl>interface HTMLMeterElement : <ref>HTMLElement</ref> {
           attribute double value;
           attribute double min;
           attribute double max;
           attribute double low;
           attribute double high;
           attribute double optimum;
  readonly attribute <ref>NodeList</ref> labels;
};</webidl>
    <InterfaceInheritance>
      <Name name="HTMLElement"/>
    </InterfaceInheritance>
    <Attribute name="value" id="::HTMLMeterElement::value">
      <webidl>           attribute double value;</webidl>
      <Type type="double"/>
    </Attribute>
    <Attribute name="min" id="::HTMLMeterElement::min">
      <webidl>           attribute double min;</webidl>
      <Type type="double"/>
    </Attribute>
    <Attribute name="max" id="::HTMLMeterElement::max">
      <webidl>           attribute double max;</webidl>
      <Type type="double"/>
    </Attribute>
    <Attribute name="low" id="::HTMLMeterElement::low">
      <webidl>           attribute double low;</webidl>
      <Type type="double"/>
    </Attribute>
    <Attribute name="high" id="::HTMLMeterElement::high">
      <webidl>           attribute double high;</webidl>
      <Type type="double"/>
    </Attribute>
    <Attribute name="optimum" id="::HTMLMeterElement::optimum">
      <webidl>           attribute double optimum;</webidl>
      <Type type="double"/>
    </Attribute>
    <Attribute readonly="readonly" name="labels" id="::HTMLMeterElement::labels">
      <webidl>  readonly attribute <ref>NodeList</ref> labels;</webidl>
      <Type name="NodeList"/>
    </Attribute>
  </Interface>
  <Enum name="SelectionMode" id="::SelectionMode">
    <webidl>enum SelectionMode {
  &quot;select&quot;,
  &quot;start&quot;,
  &quot;end&quot;,
  &quot;preserve&quot;,
};</webidl>
    <EnumValue stringvalue="select">
      <webidl>  &quot;select</webidl>
    </EnumValue>
    <EnumValue stringvalue="start">
      <webidl>  &quot;start</webidl>
    </EnumValue>
    <EnumValue stringvalue="end">
      <webidl>  &quot;end</webidl>
    </EnumValue>
    <EnumValue stringvalue="preserve">
      <webidl>  &quot;preserve</webidl>
    </EnumValue>
  </Enum>
  <Interface name="ValidityState" id="::ValidityState">
    <webidl>interface ValidityState {
  readonly attribute boolean valueMissing;
  readonly attribute boolean typeMismatch;
  readonly attribute boolean patternMismatch;
  readonly attribute boolean tooLong;
  readonly attribute boolean rangeUnderflow;
  readonly attribute boolean rangeOverflow;
  readonly attribute boolean stepMismatch;
  readonly attribute boolean badInput;
  readonly attribute boolean customError;
  readonly attribute boolean valid;
};</webidl>
    <Attribute readonly="readonly" name="valueMissing" id="::ValidityState::valueMissing">
      <webidl>  readonly attribute boolean valueMissing;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute readonly="readonly" name="typeMismatch" id="::ValidityState::typeMismatch">
      <webidl>  readonly attribute boolean typeMismatch;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute readonly="readonly" name="patternMismatch" id="::ValidityState::patternMismatch">
      <webidl>  readonly attribute boolean patternMismatch;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute readonly="readonly" name="tooLong" id="::ValidityState::tooLong">
      <webidl>  readonly attribute boolean tooLong;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute readonly="readonly" name="rangeUnderflow" id="::ValidityState::rangeUnderflow">
      <webidl>  readonly attribute boolean rangeUnderflow;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute readonly="readonly" name="rangeOverflow" id="::ValidityState::rangeOverflow">
      <webidl>  readonly attribute boolean rangeOverflow;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute readonly="readonly" name="stepMismatch" id="::ValidityState::stepMismatch">
      <webidl>  readonly attribute boolean stepMismatch;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute readonly="readonly" name="badInput" id="::ValidityState::badInput">
      <webidl>  readonly attribute boolean badInput;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute readonly="readonly" name="customError" id="::ValidityState::customError">
      <webidl>  readonly attribute boolean customError;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute readonly="readonly" name="valid" id="::ValidityState::valid">
      <webidl>  readonly attribute boolean valid;</webidl>
      <Type type="boolean"/>
    </Attribute>
  </Interface>
  <Interface name="HTMLDetailsElement" id="::HTMLDetailsElement">
    <webidl>interface HTMLDetailsElement : <ref>HTMLElement</ref> {
           attribute boolean open;
};</webidl>
    <InterfaceInheritance>
      <Name name="HTMLElement"/>
    </InterfaceInheritance>
    <Attribute name="open" id="::HTMLDetailsElement::open">
      <webidl>           attribute boolean open;</webidl>
      <Type type="boolean"/>
    </Attribute>
  </Interface>
  <Interface name="HTMLMenuElement" id="::HTMLMenuElement">
    <webidl>interface HTMLMenuElement : <ref>HTMLElement</ref> {
           attribute DOMString type;
           attribute DOMString label;
};</webidl>
    <InterfaceInheritance>
      <Name name="HTMLElement"/>
    </InterfaceInheritance>
    <Attribute name="type" id="::HTMLMenuElement::type">
      <webidl>           attribute DOMString type;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="label" id="::HTMLMenuElement::label">
      <webidl>           attribute DOMString label;</webidl>
      <Type type="DOMString"/>
    </Attribute>
  </Interface>
  <Interface name="HTMLMenuItemElement" id="::HTMLMenuItemElement">
    <webidl>interface HTMLMenuItemElement : <ref>HTMLElement</ref> {
           attribute DOMString type;
           attribute DOMString label;
           attribute DOMString icon;
           attribute boolean disabled;
           attribute boolean checked;
           attribute DOMString radiogroup;
           attribute boolean default;
  readonly attribute <ref>HTMLElement</ref>? command;
};</webidl>
    <InterfaceInheritance>
      <Name name="HTMLElement"/>
    </InterfaceInheritance>
    <Attribute name="type" id="::HTMLMenuItemElement::type">
      <webidl>           attribute DOMString type;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="label" id="::HTMLMenuItemElement::label">
      <webidl>           attribute DOMString label;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="icon" id="::HTMLMenuItemElement::icon">
      <webidl>           attribute DOMString icon;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="disabled" id="::HTMLMenuItemElement::disabled">
      <webidl>           attribute boolean disabled;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute name="checked" id="::HTMLMenuItemElement::checked">
      <webidl>           attribute boolean checked;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute name="radiogroup" id="::HTMLMenuItemElement::radiogroup">
      <webidl>           attribute DOMString radiogroup;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="default" id="::HTMLMenuItemElement::default">
      <webidl>           attribute boolean default;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute readonly="readonly" name="command" id="::HTMLMenuItemElement::command">
      <webidl>  readonly attribute <ref>HTMLElement</ref>? command;</webidl>
      <Type name="HTMLElement" nullable="nullable"/>
    </Attribute>
  </Interface>
  <Interface name="RelatedEvent" id="::RelatedEvent">
    <webidl>[Constructor(DOMString type, optional <ref>RelatedEventInit</ref> eventInitDict)]
interface RelatedEvent : <ref>Event</ref> {
  readonly attribute <ref>EventTarget</ref>? relatedTarget;
};</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="Constructor">
        <webidl>Constructor(DOMString type, optional <ref>RelatedEventInit</ref> eventInitDict)</webidl>
        <ArgumentList>
          <Argument name="type">
            <Type type="DOMString"/>
          </Argument>
          <Argument optional="optional" name="eventInitDict">
            <Type name="RelatedEventInit"/>
          </Argument>
        </ArgumentList>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <InterfaceInheritance>
      <Name name="Event"/>
    </InterfaceInheritance>
    <Attribute readonly="readonly" name="relatedTarget" id="::RelatedEvent::relatedTarget">
      <webidl>  readonly attribute <ref>EventTarget</ref>? relatedTarget;</webidl>
      <Type name="EventTarget" nullable="nullable"/>
    </Attribute>
  </Interface>
  <Dictionary name="RelatedEventInit" id="::RelatedEventInit">
    <webidl>dictionary RelatedEventInit : <ref>EventInit</ref> {
  <ref>EventTarget</ref>? relatedTarget;
};</webidl>
    <DictionaryInheritance>
      <Name name="EventInit"/>
    </DictionaryInheritance>
    <DictionaryMember name="relatedTarget" id="::RelatedEventInit::relatedTarget">
      <webidl>  <ref>EventTarget</ref>? relatedTarget;</webidl>
      <Type name="EventTarget" nullable="nullable"/>
    </DictionaryMember>
  </Dictionary>
  <Interface name="HTMLDialogElement" id="::HTMLDialogElement">
    <webidl>interface HTMLDialogElement : <ref>HTMLElement</ref> {
           attribute boolean open;
           attribute DOMString returnValue;
  void show(optional (<ref>MouseEvent</ref> or <ref>Element</ref>) anchor);
  void showModal(optional (<ref>MouseEvent</ref> or <ref>Element</ref>) anchor);
  void close(optional DOMString returnValue);
};</webidl>
    <InterfaceInheritance>
      <Name name="HTMLElement"/>
    </InterfaceInheritance>
    <Attribute name="open" id="::HTMLDialogElement::open">
      <webidl>           attribute boolean open;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute name="returnValue" id="::HTMLDialogElement::returnValue">
      <webidl>           attribute DOMString returnValue;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Operation name="show" id="::HTMLDialogElement::show">
      <webidl>  void show(optional (<ref>MouseEvent</ref> or <ref>Element</ref>) anchor);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument optional="optional" name="anchor">
          <Type type="union">
            <Type name="MouseEvent"/>
            <Type name="Element"/>
          </Type>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="showModal" id="::HTMLDialogElement::showModal">
      <webidl>  void showModal(optional (<ref>MouseEvent</ref> or <ref>Element</ref>) anchor);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument optional="optional" name="anchor">
          <Type type="union">
            <Type name="MouseEvent"/>
            <Type name="Element"/>
          </Type>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="close" id="::HTMLDialogElement::close">
      <webidl>  void close(optional DOMString returnValue);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument optional="optional" name="returnValue">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
  </Interface>
  <Interface name="Window" id="::Window">
    <webidl>[NamedPropertiesObject]
interface Window : <ref>EventTarget</ref> {
  [Unforgeable] readonly attribute <ref>WindowProxy</ref> window;
  [Replaceable] readonly attribute <ref>WindowProxy</ref> self;
  [Unforgeable] readonly attribute <ref>Document</ref> document;
           attribute DOMString name; 
  [PutForwards=href, Unforgeable] readonly attribute <ref>Location</ref> location;
  readonly attribute <ref>History</ref> history;
  [Replaceable] readonly attribute <ref>BarProp</ref> locationbar;
  [Replaceable] readonly attribute <ref>BarProp</ref> menubar;
  [Replaceable] readonly attribute <ref>BarProp</ref> personalbar;
  [Replaceable] readonly attribute <ref>BarProp</ref> scrollbars;
  [Replaceable] readonly attribute <ref>BarProp</ref> statusbar;
  [Replaceable] readonly attribute <ref>BarProp</ref> toolbar;
           attribute DOMString status;
  void close();
  void stop();
  void focus();
  void blur();

  [Replaceable] readonly attribute <ref>WindowProxy</ref> frames;
  [Replaceable] readonly attribute unsigned long length;
  [Unforgeable] readonly attribute <ref>WindowProxy</ref> top;
           attribute <ref>WindowProxy</ref>? opener;
  readonly attribute <ref>WindowProxy</ref> parent;
  readonly attribute <ref>Element</ref>? frameElement;
  <ref>WindowProxy</ref> open(optional DOMString url = &quot;about:blank&quot;, optional DOMString target = &quot;_blank&quot;, optional DOMString features = &quot;&quot;, optional boolean replace = false);
  getter <ref>WindowProxy</ref> (unsigned long index);
  getter object (DOMString name);

  readonly attribute <ref>Navigator</ref> navigator; 
  readonly attribute <ref>External</ref> external;
  readonly attribute <ref>ApplicationCache</ref> applicationCache;

  void alert(optional DOMString message = &quot;&quot;);
  boolean confirm(optional DOMString message = &quot;&quot;);
  DOMString? prompt(optional DOMString message = &quot;&quot;, optional DOMString default = &quot;&quot;);
  void print();
  any showModalDialog(DOMString url, optional any argument);


};</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="NamedPropertiesObject">
        <webidl>NamedPropertiesObject</webidl>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <InterfaceInheritance>
      <Name name="EventTarget"/>
    </InterfaceInheritance>
    <Attribute readonly="readonly" name="window" id="::Window::window">
      <webidl>  [Unforgeable] readonly attribute <ref>WindowProxy</ref> window;</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="Unforgeable">
          <webidl>Unforgeable</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type name="WindowProxy"/>
    </Attribute>
    <Attribute readonly="readonly" name="self" id="::Window::self">
      <webidl>  [Replaceable] readonly attribute <ref>WindowProxy</ref> self;</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="Replaceable">
          <webidl>Replaceable</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type name="WindowProxy"/>
    </Attribute>
    <Attribute readonly="readonly" name="document" id="::Window::document">
      <webidl>  [Unforgeable] readonly attribute <ref>Document</ref> document;</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="Unforgeable">
          <webidl>Unforgeable</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type name="Document"/>
    </Attribute>
    <Attribute name="name" id="::Window::name">
      <webidl>           attribute DOMString name;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute readonly="readonly" name="location" id="::Window::location">
      <webidl>  [PutForwards=href, Unforgeable] readonly attribute <ref>Location</ref> location;</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="PutForwards" value="href">
          <webidl>PutForwards</webidl>
        </ExtendedAttribute>
        <ExtendedAttribute name="Unforgeable">
          <webidl> Unforgeable</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type name="Location"/>
    </Attribute>
    <Attribute readonly="readonly" name="history" id="::Window::history">
      <webidl>  readonly attribute <ref>History</ref> history;</webidl>
      <Type name="History"/>
    </Attribute>
    <Attribute readonly="readonly" name="locationbar" id="::Window::locationbar">
      <webidl>  [Replaceable] readonly attribute <ref>BarProp</ref> locationbar;</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="Replaceable">
          <webidl>Replaceable</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type name="BarProp"/>
    </Attribute>
    <Attribute readonly="readonly" name="menubar" id="::Window::menubar">
      <webidl>  [Replaceable] readonly attribute <ref>BarProp</ref> menubar;</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="Replaceable">
          <webidl>Replaceable</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type name="BarProp"/>
    </Attribute>
    <Attribute readonly="readonly" name="personalbar" id="::Window::personalbar">
      <webidl>  [Replaceable] readonly attribute <ref>BarProp</ref> personalbar;</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="Replaceable">
          <webidl>Replaceable</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type name="BarProp"/>
    </Attribute>
    <Attribute readonly="readonly" name="scrollbars" id="::Window::scrollbars">
      <webidl>  [Replaceable] readonly attribute <ref>BarProp</ref> scrollbars;</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="Replaceable">
          <webidl>Replaceable</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type name="BarProp"/>
    </Attribute>
    <Attribute readonly="readonly" name="statusbar" id="::Window::statusbar">
      <webidl>  [Replaceable] readonly attribute <ref>BarProp</ref> statusbar;</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="Replaceable">
          <webidl>Replaceable</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type name="BarProp"/>
    </Attribute>
    <Attribute readonly="readonly" name="toolbar" id="::Window::toolbar">
      <webidl>  [Replaceable] readonly attribute <ref>BarProp</ref> toolbar;</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="Replaceable">
          <webidl>Replaceable</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type name="BarProp"/>
    </Attribute>
    <Attribute name="status" id="::Window::status">
      <webidl>           attribute DOMString status;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Operation name="close" id="::Window::close">
      <webidl>  void close();</webidl>
      <Type type="void"/>
      <ArgumentList/>
    </Operation>
    <Operation name="stop" id="::Window::stop">
      <webidl>  void stop();</webidl>
      <Type type="void"/>
      <ArgumentList/>
    </Operation>
    <Operation name="focus" id="::Window::focus">
      <webidl>  void focus();</webidl>
      <Type type="void"/>
      <ArgumentList/>
    </Operation>
    <Operation name="blur" id="::Window::blur">
      <webidl>  void blur();</webidl>
      <Type type="void"/>
      <ArgumentList/>
    </Operation>
    <Attribute readonly="readonly" name="frames" id="::Window::frames">
      <webidl>  [Replaceable] readonly attribute <ref>WindowProxy</ref> frames;</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="Replaceable">
          <webidl>Replaceable</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type name="WindowProxy"/>
    </Attribute>
    <Attribute readonly="readonly" name="length" id="::Window::length">
      <webidl>  [Replaceable] readonly attribute unsigned long length;</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="Replaceable">
          <webidl>Replaceable</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type type="unsigned long"/>
    </Attribute>
    <Attribute readonly="readonly" name="top" id="::Window::top">
      <webidl>  [Unforgeable] readonly attribute <ref>WindowProxy</ref> top;</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="Unforgeable">
          <webidl>Unforgeable</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type name="WindowProxy"/>
    </Attribute>
    <Attribute name="opener" id="::Window::opener">
      <webidl>           attribute <ref>WindowProxy</ref>? opener;</webidl>
      <Type name="WindowProxy" nullable="nullable"/>
    </Attribute>
    <Attribute readonly="readonly" name="parent" id="::Window::parent">
      <webidl>  readonly attribute <ref>WindowProxy</ref> parent;</webidl>
      <Type name="WindowProxy"/>
    </Attribute>
    <Attribute readonly="readonly" name="frameElement" id="::Window::frameElement">
      <webidl>  readonly attribute <ref>Element</ref>? frameElement;</webidl>
      <Type name="Element" nullable="nullable"/>
    </Attribute>
    <Operation name="open" id="::Window::open">
      <webidl>  <ref>WindowProxy</ref> open(optional DOMString url = &quot;about:blank&quot;, optional DOMString target = &quot;_blank&quot;, optional DOMString features = &quot;&quot;, optional boolean replace = false);</webidl>
      <Type name="WindowProxy"/>
      <ArgumentList>
        <Argument optional="optional" name="url" stringvalue="about:blank">
          <Type type="DOMString"/>
        </Argument>
        <Argument optional="optional" name="target" stringvalue="_blank">
          <Type type="DOMString"/>
        </Argument>
        <Argument optional="optional" name="features" stringvalue="">
          <Type type="DOMString"/>
        </Argument>
        <Argument optional="optional" name="replace" value="false">
          <Type type="boolean"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation getter="getter">
      <webidl>  getter <ref>WindowProxy</ref> (unsigned long index);</webidl>
      <Type name="WindowProxy"/>
      <ArgumentList>
        <Argument name="index">
          <Type type="unsigned long"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation getter="getter">
      <webidl>  getter object (DOMString name);</webidl>
      <Type type="object"/>
      <ArgumentList>
        <Argument name="name">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Attribute readonly="readonly" name="navigator" id="::Window::navigator">
      <webidl>  readonly attribute <ref>Navigator</ref> navigator;</webidl>
      <Type name="Navigator"/>
    </Attribute>
    <Attribute readonly="readonly" name="external" id="::Window::external">
      <webidl>  readonly attribute <ref>External</ref> external;</webidl>
      <Type name="External"/>
    </Attribute>
    <Attribute readonly="readonly" name="applicationCache" id="::Window::applicationCache">
      <webidl>  readonly attribute <ref>ApplicationCache</ref> applicationCache;</webidl>
      <Type name="ApplicationCache"/>
    </Attribute>
    <Operation name="alert" id="::Window::alert">
      <webidl>  void alert(optional DOMString message = &quot;&quot;);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument optional="optional" name="message" stringvalue="">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="confirm" id="::Window::confirm">
      <webidl>  boolean confirm(optional DOMString message = &quot;&quot;);</webidl>
      <Type type="boolean"/>
      <ArgumentList>
        <Argument optional="optional" name="message" stringvalue="">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="prompt" id="::Window::prompt">
      <webidl>  DOMString? prompt(optional DOMString message = &quot;&quot;, optional DOMString default = &quot;&quot;);</webidl>
      <Type type="DOMString" nullable="nullable"/>
      <ArgumentList>
        <Argument optional="optional" name="message" stringvalue="">
          <Type type="DOMString"/>
        </Argument>
        <Argument optional="optional" name="default" stringvalue="">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="print" id="::Window::print">
      <webidl>  void print();</webidl>
      <Type type="void"/>
      <ArgumentList/>
    </Operation>
    <Operation name="showModalDialog" id="::Window::showModalDialog">
      <webidl>  any showModalDialog(DOMString url, optional any argument);</webidl>
      <Type type="any"/>
      <ArgumentList>
        <Argument name="url">
          <Type type="DOMString"/>
        </Argument>
        <Argument optional="optional" name="argument">
          <Type type="any"/>
        </Argument>
      </ArgumentList>
    </Operation>
  </Interface>
  <Implements name1="Window" name2="GlobalEventHandlers">
    <webidl><ref>Window</ref> implements <ref>GlobalEventHandlers</ref>;</webidl>
  </Implements>
  <Implements name1="Window" name2="WindowEventHandlers">
    <webidl><ref>Window</ref> implements <ref>WindowEventHandlers</ref>;</webidl>
  </Implements>
  <Interface name="BarProp" id="::BarProp">
    <webidl>interface BarProp {
           attribute boolean visible;
};</webidl>
    <Attribute name="visible" id="::BarProp::visible">
      <webidl>           attribute boolean visible;</webidl>
      <Type type="boolean"/>
    </Attribute>
  </Interface>
  <Interface name="History" id="::History">
    <webidl>interface History {
  readonly attribute long length;
  readonly attribute any state;
  void go(optional long delta);
  void back();
  void forward();
  void pushState(any data, DOMString title, optional DOMString? url = null);
  void replaceState(any data, DOMString title, optional DOMString? url = null);
};</webidl>
    <Attribute readonly="readonly" name="length" id="::History::length">
      <webidl>  readonly attribute long length;</webidl>
      <Type type="long"/>
    </Attribute>
    <Attribute readonly="readonly" name="state" id="::History::state">
      <webidl>  readonly attribute any state;</webidl>
      <Type type="any"/>
    </Attribute>
    <Operation name="go" id="::History::go">
      <webidl>  void go(optional long delta);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument optional="optional" name="delta">
          <Type type="long"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="back" id="::History::back">
      <webidl>  void back();</webidl>
      <Type type="void"/>
      <ArgumentList/>
    </Operation>
    <Operation name="forward" id="::History::forward">
      <webidl>  void forward();</webidl>
      <Type type="void"/>
      <ArgumentList/>
    </Operation>
    <Operation name="pushState" id="::History::pushState">
      <webidl>  void pushState(any data, DOMString title, optional DOMString? url = null);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument name="data">
          <Type type="any"/>
        </Argument>
        <Argument name="title">
          <Type type="DOMString"/>
        </Argument>
        <Argument optional="optional" name="url" value="null">
          <Type type="DOMString" nullable="nullable"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="replaceState" id="::History::replaceState">
      <webidl>  void replaceState(any data, DOMString title, optional DOMString? url = null);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument name="data">
          <Type type="any"/>
        </Argument>
        <Argument name="title">
          <Type type="DOMString"/>
        </Argument>
        <Argument optional="optional" name="url" value="null">
          <Type type="DOMString" nullable="nullable"/>
        </Argument>
      </ArgumentList>
    </Operation>
  </Interface>
  <Interface name="Location" id="::Location">
    <webidl>[Unforgeable] interface Location {
  void assign(DOMString url);
  void replace(DOMString url);
  void reload();
};</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="Unforgeable">
        <webidl>Unforgeable</webidl>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <Operation name="assign" id="::Location::assign">
      <webidl>  void assign(DOMString url);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument name="url">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="replace" id="::Location::replace">
      <webidl>  void replace(DOMString url);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument name="url">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="reload" id="::Location::reload">
      <webidl>  void reload();</webidl>
      <Type type="void"/>
      <ArgumentList/>
    </Operation>
  </Interface>
  <Implements name1="Location" name2="URLUtils">
    <webidl><ref>Location</ref> implements <ref>URLUtils</ref>;</webidl>
  </Implements>
  <Interface name="PopStateEvent" id="::PopStateEvent">
    <webidl>[Constructor(DOMString type, optional <ref>PopStateEventInit</ref> eventInitDict)]
interface PopStateEvent : <ref>Event</ref> {
  readonly attribute any state;
};</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="Constructor">
        <webidl>Constructor(DOMString type, optional <ref>PopStateEventInit</ref> eventInitDict)</webidl>
        <ArgumentList>
          <Argument name="type">
            <Type type="DOMString"/>
          </Argument>
          <Argument optional="optional" name="eventInitDict">
            <Type name="PopStateEventInit"/>
          </Argument>
        </ArgumentList>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <InterfaceInheritance>
      <Name name="Event"/>
    </InterfaceInheritance>
    <Attribute readonly="readonly" name="state" id="::PopStateEvent::state">
      <webidl>  readonly attribute any state;</webidl>
      <Type type="any"/>
    </Attribute>
  </Interface>
  <Dictionary name="PopStateEventInit" id="::PopStateEventInit">
    <webidl>dictionary PopStateEventInit : <ref>EventInit</ref> {
  any state;
};</webidl>
    <DictionaryInheritance>
      <Name name="EventInit"/>
    </DictionaryInheritance>
    <DictionaryMember name="state" id="::PopStateEventInit::state">
      <webidl>  any state;</webidl>
      <Type type="any"/>
    </DictionaryMember>
  </Dictionary>
  <Interface name="HashChangeEvent" id="::HashChangeEvent">
    <webidl>[Constructor(DOMString type, optional <ref>HashChangeEventInit</ref> eventInitDict)]
interface HashChangeEvent : <ref>Event</ref> {
  readonly attribute DOMString oldURL;
  readonly attribute DOMString newURL;
};</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="Constructor">
        <webidl>Constructor(DOMString type, optional <ref>HashChangeEventInit</ref> eventInitDict)</webidl>
        <ArgumentList>
          <Argument name="type">
            <Type type="DOMString"/>
          </Argument>
          <Argument optional="optional" name="eventInitDict">
            <Type name="HashChangeEventInit"/>
          </Argument>
        </ArgumentList>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <InterfaceInheritance>
      <Name name="Event"/>
    </InterfaceInheritance>
    <Attribute readonly="readonly" name="oldURL" id="::HashChangeEvent::oldURL">
      <webidl>  readonly attribute DOMString oldURL;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute readonly="readonly" name="newURL" id="::HashChangeEvent::newURL">
      <webidl>  readonly attribute DOMString newURL;</webidl>
      <Type type="DOMString"/>
    </Attribute>
  </Interface>
  <Dictionary name="HashChangeEventInit" id="::HashChangeEventInit">
    <webidl>dictionary HashChangeEventInit : <ref>EventInit</ref> {
  DOMString oldURL;
  DOMString newURL;
};</webidl>
    <DictionaryInheritance>
      <Name name="EventInit"/>
    </DictionaryInheritance>
    <DictionaryMember name="oldURL" id="::HashChangeEventInit::oldURL">
      <webidl>  DOMString oldURL;</webidl>
      <Type type="DOMString"/>
    </DictionaryMember>
    <DictionaryMember name="newURL" id="::HashChangeEventInit::newURL">
      <webidl>  DOMString newURL;</webidl>
      <Type type="DOMString"/>
    </DictionaryMember>
  </Dictionary>
  <Interface name="PageTransitionEvent" id="::PageTransitionEvent">
    <webidl>[Constructor(DOMString type, optional <ref>PageTransitionEventInit</ref> eventInitDict)]
interface PageTransitionEvent : <ref>Event</ref> {
  readonly attribute boolean persisted;
};</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="Constructor">
        <webidl>Constructor(DOMString type, optional <ref>PageTransitionEventInit</ref> eventInitDict)</webidl>
        <ArgumentList>
          <Argument name="type">
            <Type type="DOMString"/>
          </Argument>
          <Argument optional="optional" name="eventInitDict">
            <Type name="PageTransitionEventInit"/>
          </Argument>
        </ArgumentList>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <InterfaceInheritance>
      <Name name="Event"/>
    </InterfaceInheritance>
    <Attribute readonly="readonly" name="persisted" id="::PageTransitionEvent::persisted">
      <webidl>  readonly attribute boolean persisted;</webidl>
      <Type type="boolean"/>
    </Attribute>
  </Interface>
  <Dictionary name="PageTransitionEventInit" id="::PageTransitionEventInit">
    <webidl>dictionary PageTransitionEventInit : <ref>EventInit</ref> {
  boolean persisted;
};</webidl>
    <DictionaryInheritance>
      <Name name="EventInit"/>
    </DictionaryInheritance>
    <DictionaryMember name="persisted" id="::PageTransitionEventInit::persisted">
      <webidl>  boolean persisted;</webidl>
      <Type type="boolean"/>
    </DictionaryMember>
  </Dictionary>
  <Interface name="BeforeUnloadEvent" id="::BeforeUnloadEvent">
    <webidl>interface BeforeUnloadEvent : <ref>Event</ref> {
           attribute DOMString returnValue;
};</webidl>
    <InterfaceInheritance>
      <Name name="Event"/>
    </InterfaceInheritance>
    <Attribute name="returnValue" id="::BeforeUnloadEvent::returnValue">
      <webidl>           attribute DOMString returnValue;</webidl>
      <Type type="DOMString"/>
    </Attribute>
  </Interface>
  <Interface name="ApplicationCache" id="::ApplicationCache">
    <webidl>interface ApplicationCache : <ref>EventTarget</ref> {

  const unsigned short UNCACHED = 0;
  const unsigned short IDLE = 1;
  const unsigned short CHECKING = 2;
  const unsigned short DOWNLOADING = 3;
  const unsigned short UPDATEREADY = 4;
  const unsigned short OBSOLETE = 5;
  readonly attribute unsigned short status;

  void update();
  void abort();
  void swapCache();

           attribute <ref>EventHandler</ref> onchecking;
           attribute <ref>EventHandler</ref> onerror;
           attribute <ref>EventHandler</ref> onnoupdate;
           attribute <ref>EventHandler</ref> ondownloading;
           attribute <ref>EventHandler</ref> onprogress;
           attribute <ref>EventHandler</ref> onupdateready;
           attribute <ref>EventHandler</ref> oncached;
           attribute <ref>EventHandler</ref> onobsolete;
};</webidl>
    <InterfaceInheritance>
      <Name name="EventTarget"/>
    </InterfaceInheritance>
    <Const name="UNCACHED" value="0" id="::ApplicationCache::UNCACHED">
      <webidl>  const unsigned short UNCACHED = 0;</webidl>
      <Type type="unsigned short"/>
    </Const>
    <Const name="IDLE" value="1" id="::ApplicationCache::IDLE">
      <webidl>  const unsigned short IDLE = 1;</webidl>
      <Type type="unsigned short"/>
    </Const>
    <Const name="CHECKING" value="2" id="::ApplicationCache::CHECKING">
      <webidl>  const unsigned short CHECKING = 2;</webidl>
      <Type type="unsigned short"/>
    </Const>
    <Const name="DOWNLOADING" value="3" id="::ApplicationCache::DOWNLOADING">
      <webidl>  const unsigned short DOWNLOADING = 3;</webidl>
      <Type type="unsigned short"/>
    </Const>
    <Const name="UPDATEREADY" value="4" id="::ApplicationCache::UPDATEREADY">
      <webidl>  const unsigned short UPDATEREADY = 4;</webidl>
      <Type type="unsigned short"/>
    </Const>
    <Const name="OBSOLETE" value="5" id="::ApplicationCache::OBSOLETE">
      <webidl>  const unsigned short OBSOLETE = 5;</webidl>
      <Type type="unsigned short"/>
    </Const>
    <Attribute readonly="readonly" name="status" id="::ApplicationCache::status">
      <webidl>  readonly attribute unsigned short status;</webidl>
      <Type type="unsigned short"/>
    </Attribute>
    <Operation name="update" id="::ApplicationCache::update">
      <webidl>  void update();</webidl>
      <Type type="void"/>
      <ArgumentList/>
    </Operation>
    <Operation name="abort" id="::ApplicationCache::abort">
      <webidl>  void abort();</webidl>
      <Type type="void"/>
      <ArgumentList/>
    </Operation>
    <Operation name="swapCache" id="::ApplicationCache::swapCache">
      <webidl>  void swapCache();</webidl>
      <Type type="void"/>
      <ArgumentList/>
    </Operation>
    <Attribute name="onchecking" id="::ApplicationCache::onchecking">
      <webidl>           attribute <ref>EventHandler</ref> onchecking;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="onerror" id="::ApplicationCache::onerror">
      <webidl>           attribute <ref>EventHandler</ref> onerror;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="onnoupdate" id="::ApplicationCache::onnoupdate">
      <webidl>           attribute <ref>EventHandler</ref> onnoupdate;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="ondownloading" id="::ApplicationCache::ondownloading">
      <webidl>           attribute <ref>EventHandler</ref> ondownloading;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="onprogress" id="::ApplicationCache::onprogress">
      <webidl>           attribute <ref>EventHandler</ref> onprogress;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="onupdateready" id="::ApplicationCache::onupdateready">
      <webidl>           attribute <ref>EventHandler</ref> onupdateready;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="oncached" id="::ApplicationCache::oncached">
      <webidl>           attribute <ref>EventHandler</ref> oncached;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="onobsolete" id="::ApplicationCache::onobsolete">
      <webidl>           attribute <ref>EventHandler</ref> onobsolete;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
  </Interface>
  <Interface name="NavigatorOnLine" id="::NavigatorOnLine">
    <webidl>[NoInterfaceObject]
interface NavigatorOnLine {
  readonly attribute boolean onLine;
};</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="NoInterfaceObject">
        <webidl>NoInterfaceObject</webidl>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <Attribute readonly="readonly" name="onLine" id="::NavigatorOnLine::onLine">
      <webidl>  readonly attribute boolean onLine;</webidl>
      <Type type="boolean"/>
    </Attribute>
  </Interface>
  <Callback name="EventHandlerNonNull" id="::EventHandlerNonNull">
    <webidl>[TreatNonCallableAsNull]
callback EventHandlerNonNull = any (<ref>Event</ref> event);</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="TreatNonCallableAsNull">
        <webidl>TreatNonCallableAsNull</webidl>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <Type type="any"/>
    <ArgumentList>
      <Argument name="event">
        <Type name="Event"/>
      </Argument>
    </ArgumentList>
  </Callback>
  <Typedef name="EventHandler" id="::EventHandler">
    <webidl>typedef <ref>EventHandlerNonNull</ref>? EventHandler;</webidl>
    <Type name="EventHandlerNonNull" nullable="nullable"/>
  </Typedef>
  <Callback name="OnErrorEventHandlerNonNull" id="::OnErrorEventHandlerNonNull">
    <webidl>[TreatNonCallableAsNull]
callback OnErrorEventHandlerNonNull = any ((<ref>Event</ref> or DOMString) event, optional DOMString source, optional unsigned long lineno, optional unsigned long column);</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="TreatNonCallableAsNull">
        <webidl>TreatNonCallableAsNull</webidl>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <Type type="any"/>
    <ArgumentList>
      <Argument name="event">
        <Type type="union">
          <Type name="Event"/>
          <Type type="DOMString"/>
        </Type>
      </Argument>
      <Argument optional="optional" name="source">
        <Type type="DOMString"/>
      </Argument>
      <Argument optional="optional" name="lineno">
        <Type type="unsigned long"/>
      </Argument>
      <Argument optional="optional" name="column">
        <Type type="unsigned long"/>
      </Argument>
    </ArgumentList>
  </Callback>
  <Typedef name="OnErrorEventHandler" id="::OnErrorEventHandler">
    <webidl>typedef <ref>OnErrorEventHandlerNonNull</ref>? OnErrorEventHandler;</webidl>
    <Type name="OnErrorEventHandlerNonNull" nullable="nullable"/>
  </Typedef>
  <Interface name="GlobalEventHandlers" id="::GlobalEventHandlers">
    <webidl>[NoInterfaceObject]
interface GlobalEventHandlers {
           attribute <ref>EventHandler</ref> onabort;
           attribute <ref>EventHandler</ref> onblur;
           attribute <ref>OnErrorEventHandler</ref> onerror;
           attribute <ref>EventHandler</ref> onfocus;
           attribute <ref>EventHandler</ref> oncancel;
           attribute <ref>EventHandler</ref> oncanplay;
           attribute <ref>EventHandler</ref> oncanplaythrough;
           attribute <ref>EventHandler</ref> onchange;
           attribute <ref>EventHandler</ref> onclick;
           attribute <ref>EventHandler</ref> onclose;
           attribute <ref>EventHandler</ref> oncontextmenu;
           attribute <ref>EventHandler</ref> oncuechange;
           attribute <ref>EventHandler</ref> ondblclick;
           attribute <ref>EventHandler</ref> ondrag;
           attribute <ref>EventHandler</ref> ondragend;
           attribute <ref>EventHandler</ref> ondragenter;
           attribute <ref>EventHandler</ref> ondragexit;
           attribute <ref>EventHandler</ref> ondragleave;
           attribute <ref>EventHandler</ref> ondragover;
           attribute <ref>EventHandler</ref> ondragstart;
           attribute <ref>EventHandler</ref> ondrop;
           attribute <ref>EventHandler</ref> ondurationchange;
           attribute <ref>EventHandler</ref> onemptied;
           attribute <ref>EventHandler</ref> onended;
           attribute <ref>EventHandler</ref> oninput;
           attribute <ref>EventHandler</ref> oninvalid;
           attribute <ref>EventHandler</ref> onkeydown;
           attribute <ref>EventHandler</ref> onkeypress;
           attribute <ref>EventHandler</ref> onkeyup;
           attribute <ref>EventHandler</ref> onload;
           attribute <ref>EventHandler</ref> onloadeddata;
           attribute <ref>EventHandler</ref> onloadedmetadata;
           attribute <ref>EventHandler</ref> onloadstart;
           attribute <ref>EventHandler</ref> onmousedown;
  [LenientThis] attribute <ref>EventHandler</ref> onmouseenter;
  [LenientThis] attribute <ref>EventHandler</ref> onmouseleave;
           attribute <ref>EventHandler</ref> onmousemove;
           attribute <ref>EventHandler</ref> onmouseout;
           attribute <ref>EventHandler</ref> onmouseover;
           attribute <ref>EventHandler</ref> onmouseup;
           attribute <ref>EventHandler</ref> onmousewheel;
           attribute <ref>EventHandler</ref> onpause;
           attribute <ref>EventHandler</ref> onplay;
           attribute <ref>EventHandler</ref> onplaying;
           attribute <ref>EventHandler</ref> onprogress;
           attribute <ref>EventHandler</ref> onratechange;
           attribute <ref>EventHandler</ref> onreset;
           attribute <ref>EventHandler</ref> onscroll;
           attribute <ref>EventHandler</ref> onseeked;
           attribute <ref>EventHandler</ref> onseeking;
           attribute <ref>EventHandler</ref> onselect;
           attribute <ref>EventHandler</ref> onshow;
           attribute <ref>EventHandler</ref> onsort;
           attribute <ref>EventHandler</ref> onstalled;
           attribute <ref>EventHandler</ref> onsubmit;
           attribute <ref>EventHandler</ref> onsuspend;
           attribute <ref>EventHandler</ref> ontimeupdate;
           attribute <ref>EventHandler</ref> onvolumechange;
           attribute <ref>EventHandler</ref> onwaiting;
};</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="NoInterfaceObject">
        <webidl>NoInterfaceObject</webidl>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <Attribute name="onabort" id="::GlobalEventHandlers::onabort">
      <webidl>           attribute <ref>EventHandler</ref> onabort;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="onblur" id="::GlobalEventHandlers::onblur">
      <webidl>           attribute <ref>EventHandler</ref> onblur;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="onerror" id="::GlobalEventHandlers::onerror">
      <webidl>           attribute <ref>OnErrorEventHandler</ref> onerror;</webidl>
      <Type name="OnErrorEventHandler"/>
    </Attribute>
    <Attribute name="onfocus" id="::GlobalEventHandlers::onfocus">
      <webidl>           attribute <ref>EventHandler</ref> onfocus;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="oncancel" id="::GlobalEventHandlers::oncancel">
      <webidl>           attribute <ref>EventHandler</ref> oncancel;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="oncanplay" id="::GlobalEventHandlers::oncanplay">
      <webidl>           attribute <ref>EventHandler</ref> oncanplay;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="oncanplaythrough" id="::GlobalEventHandlers::oncanplaythrough">
      <webidl>           attribute <ref>EventHandler</ref> oncanplaythrough;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="onchange" id="::GlobalEventHandlers::onchange">
      <webidl>           attribute <ref>EventHandler</ref> onchange;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="onclick" id="::GlobalEventHandlers::onclick">
      <webidl>           attribute <ref>EventHandler</ref> onclick;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="onclose" id="::GlobalEventHandlers::onclose">
      <webidl>           attribute <ref>EventHandler</ref> onclose;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="oncontextmenu" id="::GlobalEventHandlers::oncontextmenu">
      <webidl>           attribute <ref>EventHandler</ref> oncontextmenu;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="oncuechange" id="::GlobalEventHandlers::oncuechange">
      <webidl>           attribute <ref>EventHandler</ref> oncuechange;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="ondblclick" id="::GlobalEventHandlers::ondblclick">
      <webidl>           attribute <ref>EventHandler</ref> ondblclick;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="ondrag" id="::GlobalEventHandlers::ondrag">
      <webidl>           attribute <ref>EventHandler</ref> ondrag;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="ondragend" id="::GlobalEventHandlers::ondragend">
      <webidl>           attribute <ref>EventHandler</ref> ondragend;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="ondragenter" id="::GlobalEventHandlers::ondragenter">
      <webidl>           attribute <ref>EventHandler</ref> ondragenter;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="ondragexit" id="::GlobalEventHandlers::ondragexit">
      <webidl>           attribute <ref>EventHandler</ref> ondragexit;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="ondragleave" id="::GlobalEventHandlers::ondragleave">
      <webidl>           attribute <ref>EventHandler</ref> ondragleave;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="ondragover" id="::GlobalEventHandlers::ondragover">
      <webidl>           attribute <ref>EventHandler</ref> ondragover;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="ondragstart" id="::GlobalEventHandlers::ondragstart">
      <webidl>           attribute <ref>EventHandler</ref> ondragstart;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="ondrop" id="::GlobalEventHandlers::ondrop">
      <webidl>           attribute <ref>EventHandler</ref> ondrop;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="ondurationchange" id="::GlobalEventHandlers::ondurationchange">
      <webidl>           attribute <ref>EventHandler</ref> ondurationchange;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="onemptied" id="::GlobalEventHandlers::onemptied">
      <webidl>           attribute <ref>EventHandler</ref> onemptied;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="onended" id="::GlobalEventHandlers::onended">
      <webidl>           attribute <ref>EventHandler</ref> onended;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="oninput" id="::GlobalEventHandlers::oninput">
      <webidl>           attribute <ref>EventHandler</ref> oninput;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="oninvalid" id="::GlobalEventHandlers::oninvalid">
      <webidl>           attribute <ref>EventHandler</ref> oninvalid;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="onkeydown" id="::GlobalEventHandlers::onkeydown">
      <webidl>           attribute <ref>EventHandler</ref> onkeydown;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="onkeypress" id="::GlobalEventHandlers::onkeypress">
      <webidl>           attribute <ref>EventHandler</ref> onkeypress;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="onkeyup" id="::GlobalEventHandlers::onkeyup">
      <webidl>           attribute <ref>EventHandler</ref> onkeyup;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="onload" id="::GlobalEventHandlers::onload">
      <webidl>           attribute <ref>EventHandler</ref> onload;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="onloadeddata" id="::GlobalEventHandlers::onloadeddata">
      <webidl>           attribute <ref>EventHandler</ref> onloadeddata;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="onloadedmetadata" id="::GlobalEventHandlers::onloadedmetadata">
      <webidl>           attribute <ref>EventHandler</ref> onloadedmetadata;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="onloadstart" id="::GlobalEventHandlers::onloadstart">
      <webidl>           attribute <ref>EventHandler</ref> onloadstart;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="onmousedown" id="::GlobalEventHandlers::onmousedown">
      <webidl>           attribute <ref>EventHandler</ref> onmousedown;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="onmouseenter" id="::GlobalEventHandlers::onmouseenter">
      <webidl>  [LenientThis] attribute <ref>EventHandler</ref> onmouseenter;</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="LenientThis">
          <webidl>LenientThis</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="onmouseleave" id="::GlobalEventHandlers::onmouseleave">
      <webidl>  [LenientThis] attribute <ref>EventHandler</ref> onmouseleave;</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="LenientThis">
          <webidl>LenientThis</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="onmousemove" id="::GlobalEventHandlers::onmousemove">
      <webidl>           attribute <ref>EventHandler</ref> onmousemove;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="onmouseout" id="::GlobalEventHandlers::onmouseout">
      <webidl>           attribute <ref>EventHandler</ref> onmouseout;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="onmouseover" id="::GlobalEventHandlers::onmouseover">
      <webidl>           attribute <ref>EventHandler</ref> onmouseover;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="onmouseup" id="::GlobalEventHandlers::onmouseup">
      <webidl>           attribute <ref>EventHandler</ref> onmouseup;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="onmousewheel" id="::GlobalEventHandlers::onmousewheel">
      <webidl>           attribute <ref>EventHandler</ref> onmousewheel;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="onpause" id="::GlobalEventHandlers::onpause">
      <webidl>           attribute <ref>EventHandler</ref> onpause;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="onplay" id="::GlobalEventHandlers::onplay">
      <webidl>           attribute <ref>EventHandler</ref> onplay;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="onplaying" id="::GlobalEventHandlers::onplaying">
      <webidl>           attribute <ref>EventHandler</ref> onplaying;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="onprogress" id="::GlobalEventHandlers::onprogress">
      <webidl>           attribute <ref>EventHandler</ref> onprogress;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="onratechange" id="::GlobalEventHandlers::onratechange">
      <webidl>           attribute <ref>EventHandler</ref> onratechange;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="onreset" id="::GlobalEventHandlers::onreset">
      <webidl>           attribute <ref>EventHandler</ref> onreset;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="onscroll" id="::GlobalEventHandlers::onscroll">
      <webidl>           attribute <ref>EventHandler</ref> onscroll;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="onseeked" id="::GlobalEventHandlers::onseeked">
      <webidl>           attribute <ref>EventHandler</ref> onseeked;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="onseeking" id="::GlobalEventHandlers::onseeking">
      <webidl>           attribute <ref>EventHandler</ref> onseeking;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="onselect" id="::GlobalEventHandlers::onselect">
      <webidl>           attribute <ref>EventHandler</ref> onselect;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="onshow" id="::GlobalEventHandlers::onshow">
      <webidl>           attribute <ref>EventHandler</ref> onshow;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="onsort" id="::GlobalEventHandlers::onsort">
      <webidl>           attribute <ref>EventHandler</ref> onsort;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="onstalled" id="::GlobalEventHandlers::onstalled">
      <webidl>           attribute <ref>EventHandler</ref> onstalled;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="onsubmit" id="::GlobalEventHandlers::onsubmit">
      <webidl>           attribute <ref>EventHandler</ref> onsubmit;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="onsuspend" id="::GlobalEventHandlers::onsuspend">
      <webidl>           attribute <ref>EventHandler</ref> onsuspend;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="ontimeupdate" id="::GlobalEventHandlers::ontimeupdate">
      <webidl>           attribute <ref>EventHandler</ref> ontimeupdate;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="onvolumechange" id="::GlobalEventHandlers::onvolumechange">
      <webidl>           attribute <ref>EventHandler</ref> onvolumechange;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="onwaiting" id="::GlobalEventHandlers::onwaiting">
      <webidl>           attribute <ref>EventHandler</ref> onwaiting;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
  </Interface>
  <Interface name="WindowEventHandlers" id="::WindowEventHandlers">
    <webidl>[NoInterfaceObject]
interface WindowEventHandlers {
           attribute <ref>EventHandler</ref> onafterprint;
           attribute <ref>EventHandler</ref> onbeforeprint;
           attribute <ref>EventHandler</ref> onbeforeunload;
           attribute <ref>EventHandler</ref> onfullscreenchange;
           attribute <ref>EventHandler</ref> onfullscreenerror;
           attribute <ref>EventHandler</ref> onhashchange;
           attribute <ref>EventHandler</ref> onmessage;
           attribute <ref>EventHandler</ref> onoffline;
           attribute <ref>EventHandler</ref> ononline;
           attribute <ref>EventHandler</ref> onpagehide;
           attribute <ref>EventHandler</ref> onpageshow;
           attribute <ref>EventHandler</ref> onpopstate;
           attribute <ref>EventHandler</ref> onresize;
           attribute <ref>EventHandler</ref> onstorage;
           attribute <ref>EventHandler</ref> onunload;
};</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="NoInterfaceObject">
        <webidl>NoInterfaceObject</webidl>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <Attribute name="onafterprint" id="::WindowEventHandlers::onafterprint">
      <webidl>           attribute <ref>EventHandler</ref> onafterprint;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="onbeforeprint" id="::WindowEventHandlers::onbeforeprint">
      <webidl>           attribute <ref>EventHandler</ref> onbeforeprint;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="onbeforeunload" id="::WindowEventHandlers::onbeforeunload">
      <webidl>           attribute <ref>EventHandler</ref> onbeforeunload;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="onfullscreenchange" id="::WindowEventHandlers::onfullscreenchange">
      <webidl>           attribute <ref>EventHandler</ref> onfullscreenchange;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="onfullscreenerror" id="::WindowEventHandlers::onfullscreenerror">
      <webidl>           attribute <ref>EventHandler</ref> onfullscreenerror;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="onhashchange" id="::WindowEventHandlers::onhashchange">
      <webidl>           attribute <ref>EventHandler</ref> onhashchange;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="onmessage" id="::WindowEventHandlers::onmessage">
      <webidl>           attribute <ref>EventHandler</ref> onmessage;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="onoffline" id="::WindowEventHandlers::onoffline">
      <webidl>           attribute <ref>EventHandler</ref> onoffline;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="ononline" id="::WindowEventHandlers::ononline">
      <webidl>           attribute <ref>EventHandler</ref> ononline;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="onpagehide" id="::WindowEventHandlers::onpagehide">
      <webidl>           attribute <ref>EventHandler</ref> onpagehide;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="onpageshow" id="::WindowEventHandlers::onpageshow">
      <webidl>           attribute <ref>EventHandler</ref> onpageshow;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="onpopstate" id="::WindowEventHandlers::onpopstate">
      <webidl>           attribute <ref>EventHandler</ref> onpopstate;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="onresize" id="::WindowEventHandlers::onresize">
      <webidl>           attribute <ref>EventHandler</ref> onresize;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="onstorage" id="::WindowEventHandlers::onstorage">
      <webidl>           attribute <ref>EventHandler</ref> onstorage;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="onunload" id="::WindowEventHandlers::onunload">
      <webidl>           attribute <ref>EventHandler</ref> onunload;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
  </Interface>
  <Interface name="WindowBase64" id="::WindowBase64">
    <webidl>[NoInterfaceObject]
interface WindowBase64 {
  DOMString btoa(DOMString btoa);
  DOMString atob(DOMString atob);
};</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="NoInterfaceObject">
        <webidl>NoInterfaceObject</webidl>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <Operation name="btoa" id="::WindowBase64::btoa">
      <webidl>  DOMString btoa(DOMString btoa);</webidl>
      <Type type="DOMString"/>
      <ArgumentList>
        <Argument name="btoa">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="atob" id="::WindowBase64::atob">
      <webidl>  DOMString atob(DOMString atob);</webidl>
      <Type type="DOMString"/>
      <ArgumentList>
        <Argument name="atob">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
  </Interface>
  <Implements name1="Window" name2="WindowBase64">
    <webidl><ref>Window</ref> implements <ref>WindowBase64</ref>;</webidl>
  </Implements>
  <Interface name="WindowTimers" id="::WindowTimers">
    <webidl>[NoInterfaceObject]
interface WindowTimers {
  long setTimeout(<ref>Function</ref> handler, optional long timeout, any... arguments);
  long setTimeout(DOMString handler, optional long timeout, any... arguments);
  void clearTimeout(long handle);
  long setInterval(<ref>Function</ref> handler, optional long timeout, any... arguments);
  long setInterval(DOMString handler, optional long timeout, any... arguments);
  void clearInterval(long handle);
};</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="NoInterfaceObject">
        <webidl>NoInterfaceObject</webidl>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <Operation name="setTimeout" id="::WindowTimers::setTimeout">
      <webidl>  long setTimeout(<ref>Function</ref> handler, optional long timeout, any... arguments);</webidl>
      <Type type="long"/>
      <ArgumentList>
        <Argument name="handler">
          <Type name="Function"/>
        </Argument>
        <Argument optional="optional" name="timeout">
          <Type type="long"/>
        </Argument>
        <Argument ellipsis="ellipsis" name="arguments">
          <Type type="any"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="setTimeout" id="::WindowTimers::setTimeout">
      <webidl>  long setTimeout(DOMString handler, optional long timeout, any... arguments);</webidl>
      <Type type="long"/>
      <ArgumentList>
        <Argument name="handler">
          <Type type="DOMString"/>
        </Argument>
        <Argument optional="optional" name="timeout">
          <Type type="long"/>
        </Argument>
        <Argument ellipsis="ellipsis" name="arguments">
          <Type type="any"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="clearTimeout" id="::WindowTimers::clearTimeout">
      <webidl>  void clearTimeout(long handle);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument name="handle">
          <Type type="long"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="setInterval" id="::WindowTimers::setInterval">
      <webidl>  long setInterval(<ref>Function</ref> handler, optional long timeout, any... arguments);</webidl>
      <Type type="long"/>
      <ArgumentList>
        <Argument name="handler">
          <Type name="Function"/>
        </Argument>
        <Argument optional="optional" name="timeout">
          <Type type="long"/>
        </Argument>
        <Argument ellipsis="ellipsis" name="arguments">
          <Type type="any"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="setInterval" id="::WindowTimers::setInterval">
      <webidl>  long setInterval(DOMString handler, optional long timeout, any... arguments);</webidl>
      <Type type="long"/>
      <ArgumentList>
        <Argument name="handler">
          <Type type="DOMString"/>
        </Argument>
        <Argument optional="optional" name="timeout">
          <Type type="long"/>
        </Argument>
        <Argument ellipsis="ellipsis" name="arguments">
          <Type type="any"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="clearInterval" id="::WindowTimers::clearInterval">
      <webidl>  void clearInterval(long handle);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument name="handle">
          <Type type="long"/>
        </Argument>
      </ArgumentList>
    </Operation>
  </Interface>
  <Implements name1="Window" name2="WindowTimers">
    <webidl><ref>Window</ref> implements <ref>WindowTimers</ref>;</webidl>
  </Implements>
  <Interface name="WindowModal" id="::WindowModal">
    <webidl>[NoInterfaceObject] interface WindowModal {
  readonly attribute any dialogArguments;
           attribute DOMString returnValue;
};</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="NoInterfaceObject">
        <webidl>NoInterfaceObject</webidl>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <Attribute readonly="readonly" name="dialogArguments" id="::WindowModal::dialogArguments">
      <webidl>  readonly attribute any dialogArguments;</webidl>
      <Type type="any"/>
    </Attribute>
    <Attribute name="returnValue" id="::WindowModal::returnValue">
      <webidl>           attribute DOMString returnValue;</webidl>
      <Type type="DOMString"/>
    </Attribute>
  </Interface>
  <Interface name="Navigator" id="::Navigator">
    <webidl>interface Navigator {
};</webidl>
  </Interface>
  <Implements name1="Navigator" name2="NavigatorID">
    <webidl><ref>Navigator</ref> implements <ref>NavigatorID</ref>;</webidl>
  </Implements>
  <Implements name1="Navigator" name2="NavigatorLanguage">
    <webidl><ref>Navigator</ref> implements <ref>NavigatorLanguage</ref>;</webidl>
  </Implements>
  <Implements name1="Navigator" name2="NavigatorOnLine">
    <webidl><ref>Navigator</ref> implements <ref>NavigatorOnLine</ref>;</webidl>
  </Implements>
  <Implements name1="Navigator" name2="NavigatorContentUtils">
    <webidl><ref>Navigator</ref> implements <ref>NavigatorContentUtils</ref>;</webidl>
  </Implements>
  <Implements name1="Navigator" name2="NavigatorStorageUtils">
    <webidl><ref>Navigator</ref> implements <ref>NavigatorStorageUtils</ref>;</webidl>
  </Implements>
  <Interface name="NavigatorID" id="::NavigatorID">
    <webidl>[NoInterfaceObject]
interface NavigatorID {
  readonly attribute DOMString appName;
  readonly attribute DOMString appVersion;
  readonly attribute DOMString platform;
  readonly attribute DOMString userAgent;

  readonly attribute DOMString product; 
};</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="NoInterfaceObject">
        <webidl>NoInterfaceObject</webidl>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <Attribute readonly="readonly" name="appName" id="::NavigatorID::appName">
      <webidl>  readonly attribute DOMString appName;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute readonly="readonly" name="appVersion" id="::NavigatorID::appVersion">
      <webidl>  readonly attribute DOMString appVersion;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute readonly="readonly" name="platform" id="::NavigatorID::platform">
      <webidl>  readonly attribute DOMString platform;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute readonly="readonly" name="userAgent" id="::NavigatorID::userAgent">
      <webidl>  readonly attribute DOMString userAgent;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute readonly="readonly" name="product" id="::NavigatorID::product">
      <webidl>  readonly attribute DOMString product;</webidl>
      <Type type="DOMString"/>
    </Attribute>
  </Interface>
  <Interface name="NavigatorLanguage" id="::NavigatorLanguage">
    <webidl>[NoInterfaceObject]
interface NavigatorLanguage {
  readonly attribute DOMString? language;
};</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="NoInterfaceObject">
        <webidl>NoInterfaceObject</webidl>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <Attribute readonly="readonly" name="language" id="::NavigatorLanguage::language">
      <webidl>  readonly attribute DOMString? language;</webidl>
      <Type type="DOMString" nullable="nullable"/>
    </Attribute>
  </Interface>
  <Interface name="NavigatorContentUtils" id="::NavigatorContentUtils">
    <webidl>[NoInterfaceObject]
interface NavigatorContentUtils {
  void registerProtocolHandler(DOMString scheme, DOMString url, DOMString title);
  void registerContentHandler(DOMString mimeType, DOMString url, DOMString title);
  DOMString isProtocolHandlerRegistered(DOMString scheme, DOMString url);
  DOMString isContentHandlerRegistered(DOMString mimeType, DOMString url);
  void unregisterProtocolHandler(DOMString scheme, DOMString url);
  void unregisterContentHandler(DOMString mimeType, DOMString url);
};</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="NoInterfaceObject">
        <webidl>NoInterfaceObject</webidl>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <Operation name="registerProtocolHandler" id="::NavigatorContentUtils::registerProtocolHandler">
      <webidl>  void registerProtocolHandler(DOMString scheme, DOMString url, DOMString title);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument name="scheme">
          <Type type="DOMString"/>
        </Argument>
        <Argument name="url">
          <Type type="DOMString"/>
        </Argument>
        <Argument name="title">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="registerContentHandler" id="::NavigatorContentUtils::registerContentHandler">
      <webidl>  void registerContentHandler(DOMString mimeType, DOMString url, DOMString title);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument name="mimeType">
          <Type type="DOMString"/>
        </Argument>
        <Argument name="url">
          <Type type="DOMString"/>
        </Argument>
        <Argument name="title">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="isProtocolHandlerRegistered" id="::NavigatorContentUtils::isProtocolHandlerRegistered">
      <webidl>  DOMString isProtocolHandlerRegistered(DOMString scheme, DOMString url);</webidl>
      <Type type="DOMString"/>
      <ArgumentList>
        <Argument name="scheme">
          <Type type="DOMString"/>
        </Argument>
        <Argument name="url">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="isContentHandlerRegistered" id="::NavigatorContentUtils::isContentHandlerRegistered">
      <webidl>  DOMString isContentHandlerRegistered(DOMString mimeType, DOMString url);</webidl>
      <Type type="DOMString"/>
      <ArgumentList>
        <Argument name="mimeType">
          <Type type="DOMString"/>
        </Argument>
        <Argument name="url">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="unregisterProtocolHandler" id="::NavigatorContentUtils::unregisterProtocolHandler">
      <webidl>  void unregisterProtocolHandler(DOMString scheme, DOMString url);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument name="scheme">
          <Type type="DOMString"/>
        </Argument>
        <Argument name="url">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="unregisterContentHandler" id="::NavigatorContentUtils::unregisterContentHandler">
      <webidl>  void unregisterContentHandler(DOMString mimeType, DOMString url);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument name="mimeType">
          <Type type="DOMString"/>
        </Argument>
        <Argument name="url">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
  </Interface>
  <Interface name="NavigatorStorageUtils" id="::NavigatorStorageUtils">
    <webidl>[NoInterfaceObject]
interface NavigatorStorageUtils {
  void yieldForStorageUpdates();
};</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="NoInterfaceObject">
        <webidl>NoInterfaceObject</webidl>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <Operation name="yieldForStorageUpdates" id="::NavigatorStorageUtils::yieldForStorageUpdates">
      <webidl>  void yieldForStorageUpdates();</webidl>
      <Type type="void"/>
      <ArgumentList/>
    </Operation>
  </Interface>
  <Interface name="External" id="::External">
    <webidl>interface External {
  void AddSearchProvider(DOMString engineURL);
  unsigned long IsSearchProviderInstalled(DOMString engineURL);
};</webidl>
    <Operation name="AddSearchProvider" id="::External::AddSearchProvider">
      <webidl>  void AddSearchProvider(DOMString engineURL);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument name="engineURL">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="IsSearchProviderInstalled" id="::External::IsSearchProviderInstalled">
      <webidl>  unsigned long IsSearchProviderInstalled(DOMString engineURL);</webidl>
      <Type type="unsigned long"/>
      <ArgumentList>
        <Argument name="engineURL">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
  </Interface>
  <Interface name="ImageBitmap" id="::ImageBitmap">
    <webidl>interface ImageBitmap {
};</webidl>
  </Interface>
  <Callback name="ImageBitmapCallback" id="::ImageBitmapCallback">
    <webidl>callback ImageBitmapCallback = void (<ref>ImageBitmap</ref> image);</webidl>
    <Type type="void"/>
    <ArgumentList>
      <Argument name="image">
        <Type name="ImageBitmap"/>
      </Argument>
    </ArgumentList>
  </Callback>
  <Typedef name="ImageBitmapSource" id="::ImageBitmapSource">
    <webidl>typedef (<ref>HTMLImageElement</ref> or
         <ref>HTMLVideoElement</ref> or
         <ref>HTMLCanvasElement</ref> or
         <ref>Blob</ref> or
         <ref>ImageData</ref> or
         <ref>CanvasRenderingContext2D</ref> or
         <ref>ImageBitmap</ref>) ImageBitmapSource;</webidl>
    <Type type="union">
      <Type name="HTMLImageElement"/>
      <Type name="HTMLVideoElement"/>
      <Type name="HTMLCanvasElement"/>
      <Type name="Blob"/>
      <Type name="ImageData"/>
      <Type name="CanvasRenderingContext2D"/>
      <Type name="ImageBitmap"/>
    </Type>
  </Typedef>
  <Interface name="ImageBitmapFactories" id="::ImageBitmapFactories">
    <webidl>[NoInterfaceObject]
interface ImageBitmapFactories {
  void createImageBitmap(<ref>ImageBitmapSource</ref> image, <ref>ImageBitmapCallback</ref> _callback, optional long sx, long sy, long sw, long sh);
};</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="NoInterfaceObject">
        <webidl>NoInterfaceObject</webidl>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <Operation name="createImageBitmap" id="::ImageBitmapFactories::createImageBitmap">
      <webidl>  void createImageBitmap(<ref>ImageBitmapSource</ref> image, <ref>ImageBitmapCallback</ref> _callback, optional long sx, long sy, long sw, long sh);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument name="image">
          <Type name="ImageBitmapSource"/>
        </Argument>
        <Argument name="_callback">
          <Type name="ImageBitmapCallback"/>
        </Argument>
        <Argument optional="optional" name="sx">
          <Type type="long"/>
        </Argument>
        <Argument name="sy">
          <Type type="long"/>
        </Argument>
        <Argument name="sw">
          <Type type="long"/>
        </Argument>
        <Argument name="sh">
          <Type type="long"/>
        </Argument>
      </ArgumentList>
    </Operation>
  </Interface>
  <Implements name1="Window" name2="ImageBitmapFactories">
    <webidl><ref>Window</ref> implements <ref>ImageBitmapFactories</ref>;</webidl>
  </Implements>
  <Implements name1="WorkerGlobalScope" name2="ImageBitmapFactories">
    <webidl><ref>WorkerGlobalScope</ref> implements <ref>ImageBitmapFactories</ref>;</webidl>
  </Implements>
  <Interface name="DataTransfer" id="::DataTransfer">
    <webidl>interface DataTransfer {
           attribute DOMString dropEffect;
           attribute DOMString effectAllowed;

  readonly attribute <ref>DataTransferItemList</ref> items;

  void setDragImage(<ref>Element</ref> image, long x, long y);

  readonly attribute DOMString[] types;
  DOMString getData(DOMString format);
  void setData(DOMString format, DOMString data);
  void clearData(optional DOMString format);
  readonly attribute <ref>FileList</ref> files;
};</webidl>
    <Attribute name="dropEffect" id="::DataTransfer::dropEffect">
      <webidl>           attribute DOMString dropEffect;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="effectAllowed" id="::DataTransfer::effectAllowed">
      <webidl>           attribute DOMString effectAllowed;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute readonly="readonly" name="items" id="::DataTransfer::items">
      <webidl>  readonly attribute <ref>DataTransferItemList</ref> items;</webidl>
      <Type name="DataTransferItemList"/>
    </Attribute>
    <Operation name="setDragImage" id="::DataTransfer::setDragImage">
      <webidl>  void setDragImage(<ref>Element</ref> image, long x, long y);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument name="image">
          <Type name="Element"/>
        </Argument>
        <Argument name="x">
          <Type type="long"/>
        </Argument>
        <Argument name="y">
          <Type type="long"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Attribute readonly="readonly" name="types" id="::DataTransfer::types">
      <webidl>  readonly attribute DOMString[] types;</webidl>
      <Type type="array">
        <Type type="DOMString"/>
      </Type>
    </Attribute>
    <Operation name="getData" id="::DataTransfer::getData">
      <webidl>  DOMString getData(DOMString format);</webidl>
      <Type type="DOMString"/>
      <ArgumentList>
        <Argument name="format">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="setData" id="::DataTransfer::setData">
      <webidl>  void setData(DOMString format, DOMString data);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument name="format">
          <Type type="DOMString"/>
        </Argument>
        <Argument name="data">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="clearData" id="::DataTransfer::clearData">
      <webidl>  void clearData(optional DOMString format);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument optional="optional" name="format">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Attribute readonly="readonly" name="files" id="::DataTransfer::files">
      <webidl>  readonly attribute <ref>FileList</ref> files;</webidl>
      <Type name="FileList"/>
    </Attribute>
  </Interface>
  <Interface name="DataTransferItemList" id="::DataTransferItemList">
    <webidl>interface DataTransferItemList {
  readonly attribute unsigned long length;
  getter <ref>DataTransferItem</ref> (unsigned long index);
  void remove(unsigned long index);
  void clear();

  <ref>DataTransferItem</ref>? add(DOMString data, DOMString type);
  <ref>DataTransferItem</ref>? add(<ref>File</ref> data);
};</webidl>
    <Attribute readonly="readonly" name="length" id="::DataTransferItemList::length">
      <webidl>  readonly attribute unsigned long length;</webidl>
      <Type type="unsigned long"/>
    </Attribute>
    <Operation getter="getter">
      <webidl>  getter <ref>DataTransferItem</ref> (unsigned long index);</webidl>
      <Type name="DataTransferItem"/>
      <ArgumentList>
        <Argument name="index">
          <Type type="unsigned long"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="remove" id="::DataTransferItemList::remove">
      <webidl>  void remove(unsigned long index);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument name="index">
          <Type type="unsigned long"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="clear" id="::DataTransferItemList::clear">
      <webidl>  void clear();</webidl>
      <Type type="void"/>
      <ArgumentList/>
    </Operation>
    <Operation name="add" id="::DataTransferItemList::add">
      <webidl>  <ref>DataTransferItem</ref>? add(DOMString data, DOMString type);</webidl>
      <Type name="DataTransferItem" nullable="nullable"/>
      <ArgumentList>
        <Argument name="data">
          <Type type="DOMString"/>
        </Argument>
        <Argument name="type">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="add" id="::DataTransferItemList::add">
      <webidl>  <ref>DataTransferItem</ref>? add(<ref>File</ref> data);</webidl>
      <Type name="DataTransferItem" nullable="nullable"/>
      <ArgumentList>
        <Argument name="data">
          <Type name="File"/>
        </Argument>
      </ArgumentList>
    </Operation>
  </Interface>
  <Interface name="DataTransferItem" id="::DataTransferItem">
    <webidl>interface DataTransferItem {
  readonly attribute DOMString kind;
  readonly attribute DOMString type;
  void getAsString(<ref>FunctionStringCallback</ref>? _callback);
  <ref>File</ref>? getAsFile();
};</webidl>
    <Attribute readonly="readonly" name="kind" id="::DataTransferItem::kind">
      <webidl>  readonly attribute DOMString kind;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute readonly="readonly" name="type" id="::DataTransferItem::type">
      <webidl>  readonly attribute DOMString type;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Operation name="getAsString" id="::DataTransferItem::getAsString">
      <webidl>  void getAsString(<ref>FunctionStringCallback</ref>? _callback);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument name="_callback">
          <Type name="FunctionStringCallback" nullable="nullable"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="getAsFile" id="::DataTransferItem::getAsFile">
      <webidl>  <ref>File</ref>? getAsFile();</webidl>
      <Type name="File" nullable="nullable"/>
      <ArgumentList/>
    </Operation>
  </Interface>
  <Interface name="FunctionStringCallback" id="::FunctionStringCallback">
    <webidl>[Callback, NoInterfaceObject]
interface FunctionStringCallback {
  void handleEvent(DOMString data);
};</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="Callback">
        <webidl>Callback</webidl>
      </ExtendedAttribute>
      <ExtendedAttribute name="NoInterfaceObject">
        <webidl> NoInterfaceObject</webidl>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <Operation name="handleEvent" id="::FunctionStringCallback::handleEvent">
      <webidl>  void handleEvent(DOMString data);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument name="data">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
  </Interface>
  <Interface name="DragEvent" id="::DragEvent">
    <webidl>[Constructor(DOMString type, optional <ref>DragEventInit</ref> eventInitDict)]
interface DragEvent : <ref>MouseEvent</ref> {
  readonly attribute <ref>DataTransfer</ref>? dataTransfer;
};</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="Constructor">
        <webidl>Constructor(DOMString type, optional <ref>DragEventInit</ref> eventInitDict)</webidl>
        <ArgumentList>
          <Argument name="type">
            <Type type="DOMString"/>
          </Argument>
          <Argument optional="optional" name="eventInitDict">
            <Type name="DragEventInit"/>
          </Argument>
        </ArgumentList>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <InterfaceInheritance>
      <Name name="MouseEvent"/>
    </InterfaceInheritance>
    <Attribute readonly="readonly" name="dataTransfer" id="::DragEvent::dataTransfer">
      <webidl>  readonly attribute <ref>DataTransfer</ref>? dataTransfer;</webidl>
      <Type name="DataTransfer" nullable="nullable"/>
    </Attribute>
  </Interface>
  <Dictionary name="DragEventInit" id="::DragEventInit">
    <webidl>dictionary DragEventInit : <ref>EventInit</ref> {
  <ref>Window</ref>? view = null;
  long detail = 0;
  long screenX = 0;
  long screenY = 0;
  long clientX = 0;
  long clientY = 0;
  boolean ctrlKey = false;
  boolean shiftKey = false;
  boolean altKey = false;
  boolean metaKey = false;
  unsigned short button = 0;
  unsigned short buttons = 0;
  <ref>EventTarget</ref>? relatedTarget = null;
  <ref>DataTransfer</ref>? dataTransfer;
};</webidl>
    <DictionaryInheritance>
      <Name name="EventInit"/>
    </DictionaryInheritance>
    <DictionaryMember name="view" value="null" id="::DragEventInit::view">
      <webidl>  <ref>Window</ref>? view = null;</webidl>
      <Type name="Window" nullable="nullable"/>
    </DictionaryMember>
    <DictionaryMember name="detail" value="0" id="::DragEventInit::detail">
      <webidl>  long detail = 0;</webidl>
      <Type type="long"/>
    </DictionaryMember>
    <DictionaryMember name="screenX" value="0" id="::DragEventInit::screenX">
      <webidl>  long screenX = 0;</webidl>
      <Type type="long"/>
    </DictionaryMember>
    <DictionaryMember name="screenY" value="0" id="::DragEventInit::screenY">
      <webidl>  long screenY = 0;</webidl>
      <Type type="long"/>
    </DictionaryMember>
    <DictionaryMember name="clientX" value="0" id="::DragEventInit::clientX">
      <webidl>  long clientX = 0;</webidl>
      <Type type="long"/>
    </DictionaryMember>
    <DictionaryMember name="clientY" value="0" id="::DragEventInit::clientY">
      <webidl>  long clientY = 0;</webidl>
      <Type type="long"/>
    </DictionaryMember>
    <DictionaryMember name="ctrlKey" value="false" id="::DragEventInit::ctrlKey">
      <webidl>  boolean ctrlKey = false;</webidl>
      <Type type="boolean"/>
    </DictionaryMember>
    <DictionaryMember name="shiftKey" value="false" id="::DragEventInit::shiftKey">
      <webidl>  boolean shiftKey = false;</webidl>
      <Type type="boolean"/>
    </DictionaryMember>
    <DictionaryMember name="altKey" value="false" id="::DragEventInit::altKey">
      <webidl>  boolean altKey = false;</webidl>
      <Type type="boolean"/>
    </DictionaryMember>
    <DictionaryMember name="metaKey" value="false" id="::DragEventInit::metaKey">
      <webidl>  boolean metaKey = false;</webidl>
      <Type type="boolean"/>
    </DictionaryMember>
    <DictionaryMember name="button" value="0" id="::DragEventInit::button">
      <webidl>  unsigned short button = 0;</webidl>
      <Type type="unsigned short"/>
    </DictionaryMember>
    <DictionaryMember name="buttons" value="0" id="::DragEventInit::buttons">
      <webidl>  unsigned short buttons = 0;</webidl>
      <Type type="unsigned short"/>
    </DictionaryMember>
    <DictionaryMember name="relatedTarget" value="null" id="::DragEventInit::relatedTarget">
      <webidl>  <ref>EventTarget</ref>? relatedTarget = null;</webidl>
      <Type name="EventTarget" nullable="nullable"/>
    </DictionaryMember>
    <DictionaryMember name="dataTransfer" id="::DragEventInit::dataTransfer">
      <webidl>  <ref>DataTransfer</ref>? dataTransfer;</webidl>
      <Type name="DataTransfer" nullable="nullable"/>
    </DictionaryMember>
  </Dictionary>
  <Interface name="HTMLAppletElement" id="::HTMLAppletElement">
    <webidl>interface HTMLAppletElement : <ref>HTMLElement</ref> {
           attribute DOMString align;
           attribute DOMString alt;
           attribute DOMString archive;
           attribute DOMString code;
           attribute DOMString codeBase;
           attribute DOMString height;
           attribute unsigned long hspace;
           attribute DOMString name;
           attribute DOMString _object; 
           attribute unsigned long vspace;
           attribute DOMString width;
};</webidl>
    <InterfaceInheritance>
      <Name name="HTMLElement"/>
    </InterfaceInheritance>
    <Attribute name="align" id="::HTMLAppletElement::align">
      <webidl>           attribute DOMString align;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="alt" id="::HTMLAppletElement::alt">
      <webidl>           attribute DOMString alt;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="archive" id="::HTMLAppletElement::archive">
      <webidl>           attribute DOMString archive;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="code" id="::HTMLAppletElement::code">
      <webidl>           attribute DOMString code;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="codeBase" id="::HTMLAppletElement::codeBase">
      <webidl>           attribute DOMString codeBase;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="height" id="::HTMLAppletElement::height">
      <webidl>           attribute DOMString height;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="hspace" id="::HTMLAppletElement::hspace">
      <webidl>           attribute unsigned long hspace;</webidl>
      <Type type="unsigned long"/>
    </Attribute>
    <Attribute name="name" id="::HTMLAppletElement::name">
      <webidl>           attribute DOMString name;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="_object" id="::HTMLAppletElement::_object">
      <webidl>           attribute DOMString _object;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="vspace" id="::HTMLAppletElement::vspace">
      <webidl>           attribute unsigned long vspace;</webidl>
      <Type type="unsigned long"/>
    </Attribute>
    <Attribute name="width" id="::HTMLAppletElement::width">
      <webidl>           attribute DOMString width;</webidl>
      <Type type="DOMString"/>
    </Attribute>
  </Interface>
  <Interface name="HTMLMarqueeElement" id="::HTMLMarqueeElement">
    <webidl>interface HTMLMarqueeElement : <ref>HTMLElement</ref> {
           attribute DOMString behavior;
           attribute DOMString bgColor;
           attribute DOMString direction;
           attribute DOMString height;
           attribute unsigned long hspace;
           attribute long loop;
           attribute unsigned long scrollAmount;
           attribute unsigned long scrollDelay;
           attribute boolean trueSpeed;
           attribute unsigned long vspace;
           attribute DOMString width;

           attribute <ref>EventHandler</ref> onbounce;
           attribute <ref>EventHandler</ref> onfinish;
           attribute <ref>EventHandler</ref> onstart;

  void start();
  void stop();
};</webidl>
    <InterfaceInheritance>
      <Name name="HTMLElement"/>
    </InterfaceInheritance>
    <Attribute name="behavior" id="::HTMLMarqueeElement::behavior">
      <webidl>           attribute DOMString behavior;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="bgColor" id="::HTMLMarqueeElement::bgColor">
      <webidl>           attribute DOMString bgColor;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="direction" id="::HTMLMarqueeElement::direction">
      <webidl>           attribute DOMString direction;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="height" id="::HTMLMarqueeElement::height">
      <webidl>           attribute DOMString height;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="hspace" id="::HTMLMarqueeElement::hspace">
      <webidl>           attribute unsigned long hspace;</webidl>
      <Type type="unsigned long"/>
    </Attribute>
    <Attribute name="loop" id="::HTMLMarqueeElement::loop">
      <webidl>           attribute long loop;</webidl>
      <Type type="long"/>
    </Attribute>
    <Attribute name="scrollAmount" id="::HTMLMarqueeElement::scrollAmount">
      <webidl>           attribute unsigned long scrollAmount;</webidl>
      <Type type="unsigned long"/>
    </Attribute>
    <Attribute name="scrollDelay" id="::HTMLMarqueeElement::scrollDelay">
      <webidl>           attribute unsigned long scrollDelay;</webidl>
      <Type type="unsigned long"/>
    </Attribute>
    <Attribute name="trueSpeed" id="::HTMLMarqueeElement::trueSpeed">
      <webidl>           attribute boolean trueSpeed;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute name="vspace" id="::HTMLMarqueeElement::vspace">
      <webidl>           attribute unsigned long vspace;</webidl>
      <Type type="unsigned long"/>
    </Attribute>
    <Attribute name="width" id="::HTMLMarqueeElement::width">
      <webidl>           attribute DOMString width;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="onbounce" id="::HTMLMarqueeElement::onbounce">
      <webidl>           attribute <ref>EventHandler</ref> onbounce;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="onfinish" id="::HTMLMarqueeElement::onfinish">
      <webidl>           attribute <ref>EventHandler</ref> onfinish;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="onstart" id="::HTMLMarqueeElement::onstart">
      <webidl>           attribute <ref>EventHandler</ref> onstart;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Operation name="start" id="::HTMLMarqueeElement::start">
      <webidl>  void start();</webidl>
      <Type type="void"/>
      <ArgumentList/>
    </Operation>
    <Operation name="stop" id="::HTMLMarqueeElement::stop">
      <webidl>  void stop();</webidl>
      <Type type="void"/>
      <ArgumentList/>
    </Operation>
  </Interface>
  <Interface name="HTMLFrameSetElement" id="::HTMLFrameSetElement">
    <webidl>interface HTMLFrameSetElement : <ref>HTMLElement</ref> {
           attribute DOMString cols;
           attribute DOMString rows;
};</webidl>
    <InterfaceInheritance>
      <Name name="HTMLElement"/>
    </InterfaceInheritance>
    <Attribute name="cols" id="::HTMLFrameSetElement::cols">
      <webidl>           attribute DOMString cols;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="rows" id="::HTMLFrameSetElement::rows">
      <webidl>           attribute DOMString rows;</webidl>
      <Type type="DOMString"/>
    </Attribute>
  </Interface>
  <Implements name1="HTMLFrameSetElement" name2="WindowEventHandlers">
    <webidl><ref>HTMLFrameSetElement</ref> implements <ref>WindowEventHandlers</ref>;</webidl>
  </Implements>
  <Interface name="HTMLFrameElement" id="::HTMLFrameElement">
    <webidl>interface HTMLFrameElement : <ref>HTMLElement</ref> {
           attribute DOMString name;
           attribute DOMString scrolling;
           attribute DOMString src;
           attribute DOMString frameBorder;
           attribute DOMString longDesc;
           attribute boolean noResize;
  readonly attribute <ref>Document</ref>? contentDocument;
  readonly attribute <ref>WindowProxy</ref>? contentWindow;

  [TreatNullAs=EmptyString] attribute DOMString marginHeight;
  [TreatNullAs=EmptyString] attribute DOMString marginWidth;
};</webidl>
    <InterfaceInheritance>
      <Name name="HTMLElement"/>
    </InterfaceInheritance>
    <Attribute name="name" id="::HTMLFrameElement::name">
      <webidl>           attribute DOMString name;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="scrolling" id="::HTMLFrameElement::scrolling">
      <webidl>           attribute DOMString scrolling;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="src" id="::HTMLFrameElement::src">
      <webidl>           attribute DOMString src;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="frameBorder" id="::HTMLFrameElement::frameBorder">
      <webidl>           attribute DOMString frameBorder;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="longDesc" id="::HTMLFrameElement::longDesc">
      <webidl>           attribute DOMString longDesc;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="noResize" id="::HTMLFrameElement::noResize">
      <webidl>           attribute boolean noResize;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute readonly="readonly" name="contentDocument" id="::HTMLFrameElement::contentDocument">
      <webidl>  readonly attribute <ref>Document</ref>? contentDocument;</webidl>
      <Type name="Document" nullable="nullable"/>
    </Attribute>
    <Attribute readonly="readonly" name="contentWindow" id="::HTMLFrameElement::contentWindow">
      <webidl>  readonly attribute <ref>WindowProxy</ref>? contentWindow;</webidl>
      <Type name="WindowProxy" nullable="nullable"/>
    </Attribute>
    <Attribute name="marginHeight" id="::HTMLFrameElement::marginHeight">
      <webidl>  [TreatNullAs=EmptyString] attribute DOMString marginHeight;</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="TreatNullAs" value="EmptyString">
          <webidl>TreatNullAs</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="marginWidth" id="::HTMLFrameElement::marginWidth">
      <webidl>  [TreatNullAs=EmptyString] attribute DOMString marginWidth;</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="TreatNullAs" value="EmptyString">
          <webidl>TreatNullAs</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type type="DOMString"/>
    </Attribute>
  </Interface>
  <Interface name="HTMLAnchorElement" partial="partial" id="::HTMLAnchorElement">
    <webidl>partial interface HTMLAnchorElement {
           attribute DOMString coords;
           attribute DOMString charset;
           attribute DOMString name;
           attribute DOMString rev;
           attribute DOMString shape;
};</webidl>
    <Attribute name="coords" id="::HTMLAnchorElement::coords">
      <webidl>           attribute DOMString coords;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="charset" id="::HTMLAnchorElement::charset">
      <webidl>           attribute DOMString charset;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="name" id="::HTMLAnchorElement::name">
      <webidl>           attribute DOMString name;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="rev" id="::HTMLAnchorElement::rev">
      <webidl>           attribute DOMString rev;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="shape" id="::HTMLAnchorElement::shape">
      <webidl>           attribute DOMString shape;</webidl>
      <Type type="DOMString"/>
    </Attribute>
  </Interface>
  <Interface name="HTMLAreaElement" partial="partial" id="::HTMLAreaElement">
    <webidl>partial interface HTMLAreaElement {
           attribute boolean noHref;
};</webidl>
    <Attribute name="noHref" id="::HTMLAreaElement::noHref">
      <webidl>           attribute boolean noHref;</webidl>
      <Type type="boolean"/>
    </Attribute>
  </Interface>
  <Interface name="HTMLBodyElement" partial="partial" id="::HTMLBodyElement">
    <webidl>partial interface HTMLBodyElement {
  [TreatNullAs=EmptyString] attribute DOMString text;
  [TreatNullAs=EmptyString] attribute DOMString link;
  [TreatNullAs=EmptyString] attribute DOMString vLink;
  [TreatNullAs=EmptyString] attribute DOMString aLink;
  [TreatNullAs=EmptyString] attribute DOMString bgColor;
                            attribute DOMString background;
};</webidl>
    <Attribute name="text" id="::HTMLBodyElement::text">
      <webidl>  [TreatNullAs=EmptyString] attribute DOMString text;</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="TreatNullAs" value="EmptyString">
          <webidl>TreatNullAs</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="link" id="::HTMLBodyElement::link">
      <webidl>  [TreatNullAs=EmptyString] attribute DOMString link;</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="TreatNullAs" value="EmptyString">
          <webidl>TreatNullAs</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="vLink" id="::HTMLBodyElement::vLink">
      <webidl>  [TreatNullAs=EmptyString] attribute DOMString vLink;</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="TreatNullAs" value="EmptyString">
          <webidl>TreatNullAs</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="aLink" id="::HTMLBodyElement::aLink">
      <webidl>  [TreatNullAs=EmptyString] attribute DOMString aLink;</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="TreatNullAs" value="EmptyString">
          <webidl>TreatNullAs</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="bgColor" id="::HTMLBodyElement::bgColor">
      <webidl>  [TreatNullAs=EmptyString] attribute DOMString bgColor;</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="TreatNullAs" value="EmptyString">
          <webidl>TreatNullAs</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="background" id="::HTMLBodyElement::background">
      <webidl>                            attribute DOMString background;</webidl>
      <Type type="DOMString"/>
    </Attribute>
  </Interface>
  <Interface name="HTMLBRElement" partial="partial" id="::HTMLBRElement">
    <webidl>partial interface HTMLBRElement {
           attribute DOMString clear;
};</webidl>
    <Attribute name="clear" id="::HTMLBRElement::clear">
      <webidl>           attribute DOMString clear;</webidl>
      <Type type="DOMString"/>
    </Attribute>
  </Interface>
  <Interface name="HTMLTableCaptionElement" partial="partial" id="::HTMLTableCaptionElement">
    <webidl>partial interface HTMLTableCaptionElement {
           attribute DOMString align;
};</webidl>
    <Attribute name="align" id="::HTMLTableCaptionElement::align">
      <webidl>           attribute DOMString align;</webidl>
      <Type type="DOMString"/>
    </Attribute>
  </Interface>
  <Interface name="HTMLTableColElement" partial="partial" id="::HTMLTableColElement">
    <webidl>partial interface HTMLTableColElement {
           attribute DOMString align;
           attribute DOMString ch;
           attribute DOMString chOff;
           attribute DOMString vAlign;
           attribute DOMString width;
};</webidl>
    <Attribute name="align" id="::HTMLTableColElement::align">
      <webidl>           attribute DOMString align;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="ch" id="::HTMLTableColElement::ch">
      <webidl>           attribute DOMString ch;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="chOff" id="::HTMLTableColElement::chOff">
      <webidl>           attribute DOMString chOff;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="vAlign" id="::HTMLTableColElement::vAlign">
      <webidl>           attribute DOMString vAlign;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="width" id="::HTMLTableColElement::width">
      <webidl>           attribute DOMString width;</webidl>
      <Type type="DOMString"/>
    </Attribute>
  </Interface>
  <Interface name="HTMLDirectoryElement" id="::HTMLDirectoryElement">
    <webidl>interface HTMLDirectoryElement : <ref>HTMLElement</ref> {
           attribute boolean compact;
};</webidl>
    <InterfaceInheritance>
      <Name name="HTMLElement"/>
    </InterfaceInheritance>
    <Attribute name="compact" id="::HTMLDirectoryElement::compact">
      <webidl>           attribute boolean compact;</webidl>
      <Type type="boolean"/>
    </Attribute>
  </Interface>
  <Interface name="HTMLDivElement" partial="partial" id="::HTMLDivElement">
    <webidl>partial interface HTMLDivElement {
           attribute DOMString align;
};</webidl>
    <Attribute name="align" id="::HTMLDivElement::align">
      <webidl>           attribute DOMString align;</webidl>
      <Type type="DOMString"/>
    </Attribute>
  </Interface>
  <Interface name="HTMLDListElement" partial="partial" id="::HTMLDListElement">
    <webidl>partial interface HTMLDListElement {
           attribute boolean compact;
};</webidl>
    <Attribute name="compact" id="::HTMLDListElement::compact">
      <webidl>           attribute boolean compact;</webidl>
      <Type type="boolean"/>
    </Attribute>
  </Interface>
  <Interface name="HTMLEmbedElement" partial="partial" id="::HTMLEmbedElement">
    <webidl>partial interface HTMLEmbedElement {
           attribute DOMString align;
           attribute DOMString name;
};</webidl>
    <Attribute name="align" id="::HTMLEmbedElement::align">
      <webidl>           attribute DOMString align;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="name" id="::HTMLEmbedElement::name">
      <webidl>           attribute DOMString name;</webidl>
      <Type type="DOMString"/>
    </Attribute>
  </Interface>
  <Interface name="HTMLFontElement" id="::HTMLFontElement">
    <webidl>interface HTMLFontElement : <ref>HTMLElement</ref> {
  [TreatNullAs=EmptyString] attribute DOMString color;
                            attribute DOMString face;
                            attribute DOMString size; 
};</webidl>
    <InterfaceInheritance>
      <Name name="HTMLElement"/>
    </InterfaceInheritance>
    <Attribute name="color" id="::HTMLFontElement::color">
      <webidl>  [TreatNullAs=EmptyString] attribute DOMString color;</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="TreatNullAs" value="EmptyString">
          <webidl>TreatNullAs</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="face" id="::HTMLFontElement::face">
      <webidl>                            attribute DOMString face;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="size" id="::HTMLFontElement::size">
      <webidl>                            attribute DOMString size;</webidl>
      <Type type="DOMString"/>
    </Attribute>
  </Interface>
  <Interface name="HTMLHeadingElement" partial="partial" id="::HTMLHeadingElement">
    <webidl>partial interface HTMLHeadingElement {
           attribute DOMString align;
};</webidl>
    <Attribute name="align" id="::HTMLHeadingElement::align">
      <webidl>           attribute DOMString align;</webidl>
      <Type type="DOMString"/>
    </Attribute>
  </Interface>
  <Interface name="HTMLHRElement" partial="partial" id="::HTMLHRElement">
    <webidl>partial interface HTMLHRElement {
           attribute DOMString align;
           attribute DOMString color;
           attribute boolean noShade;
           attribute DOMString size;
           attribute DOMString width;
};</webidl>
    <Attribute name="align" id="::HTMLHRElement::align">
      <webidl>           attribute DOMString align;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="color" id="::HTMLHRElement::color">
      <webidl>           attribute DOMString color;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="noShade" id="::HTMLHRElement::noShade">
      <webidl>           attribute boolean noShade;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute name="size" id="::HTMLHRElement::size">
      <webidl>           attribute DOMString size;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="width" id="::HTMLHRElement::width">
      <webidl>           attribute DOMString width;</webidl>
      <Type type="DOMString"/>
    </Attribute>
  </Interface>
  <Interface name="HTMLHtmlElement" partial="partial" id="::HTMLHtmlElement">
    <webidl>partial interface HTMLHtmlElement {
           attribute DOMString version;
};</webidl>
    <Attribute name="version" id="::HTMLHtmlElement::version">
      <webidl>           attribute DOMString version;</webidl>
      <Type type="DOMString"/>
    </Attribute>
  </Interface>
  <Interface name="HTMLIFrameElement" partial="partial" id="::HTMLIFrameElement">
    <webidl>partial interface HTMLIFrameElement {
           attribute DOMString align;
           attribute DOMString scrolling;
           attribute DOMString frameBorder;
           attribute DOMString longDesc;

  [TreatNullAs=EmptyString] attribute DOMString marginHeight;
  [TreatNullAs=EmptyString] attribute DOMString marginWidth;
};</webidl>
    <Attribute name="align" id="::HTMLIFrameElement::align">
      <webidl>           attribute DOMString align;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="scrolling" id="::HTMLIFrameElement::scrolling">
      <webidl>           attribute DOMString scrolling;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="frameBorder" id="::HTMLIFrameElement::frameBorder">
      <webidl>           attribute DOMString frameBorder;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="longDesc" id="::HTMLIFrameElement::longDesc">
      <webidl>           attribute DOMString longDesc;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="marginHeight" id="::HTMLIFrameElement::marginHeight">
      <webidl>  [TreatNullAs=EmptyString] attribute DOMString marginHeight;</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="TreatNullAs" value="EmptyString">
          <webidl>TreatNullAs</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="marginWidth" id="::HTMLIFrameElement::marginWidth">
      <webidl>  [TreatNullAs=EmptyString] attribute DOMString marginWidth;</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="TreatNullAs" value="EmptyString">
          <webidl>TreatNullAs</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type type="DOMString"/>
    </Attribute>
  </Interface>
  <Interface name="HTMLImageElement" partial="partial" id="::HTMLImageElement">
    <webidl>partial interface HTMLImageElement {
           attribute DOMString name;
           attribute DOMString align;
           attribute unsigned long hspace;
           attribute unsigned long vspace;
           attribute DOMString longDesc;

  [TreatNullAs=EmptyString] attribute DOMString border;
};</webidl>
    <Attribute name="name" id="::HTMLImageElement::name">
      <webidl>           attribute DOMString name;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="align" id="::HTMLImageElement::align">
      <webidl>           attribute DOMString align;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="hspace" id="::HTMLImageElement::hspace">
      <webidl>           attribute unsigned long hspace;</webidl>
      <Type type="unsigned long"/>
    </Attribute>
    <Attribute name="vspace" id="::HTMLImageElement::vspace">
      <webidl>           attribute unsigned long vspace;</webidl>
      <Type type="unsigned long"/>
    </Attribute>
    <Attribute name="longDesc" id="::HTMLImageElement::longDesc">
      <webidl>           attribute DOMString longDesc;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="border" id="::HTMLImageElement::border">
      <webidl>  [TreatNullAs=EmptyString] attribute DOMString border;</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="TreatNullAs" value="EmptyString">
          <webidl>TreatNullAs</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type type="DOMString"/>
    </Attribute>
  </Interface>
  <Interface name="HTMLInputElement" partial="partial" id="::HTMLInputElement">
    <webidl>partial interface HTMLInputElement {
           attribute DOMString align;
           attribute DOMString useMap;
};</webidl>
    <Attribute name="align" id="::HTMLInputElement::align">
      <webidl>           attribute DOMString align;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="useMap" id="::HTMLInputElement::useMap">
      <webidl>           attribute DOMString useMap;</webidl>
      <Type type="DOMString"/>
    </Attribute>
  </Interface>
  <Interface name="HTMLLegendElement" partial="partial" id="::HTMLLegendElement">
    <webidl>partial interface HTMLLegendElement {
           attribute DOMString align;
};</webidl>
    <Attribute name="align" id="::HTMLLegendElement::align">
      <webidl>           attribute DOMString align;</webidl>
      <Type type="DOMString"/>
    </Attribute>
  </Interface>
  <Interface name="HTMLLIElement" partial="partial" id="::HTMLLIElement">
    <webidl>partial interface HTMLLIElement {
           attribute DOMString type;
};</webidl>
    <Attribute name="type" id="::HTMLLIElement::type">
      <webidl>           attribute DOMString type;</webidl>
      <Type type="DOMString"/>
    </Attribute>
  </Interface>
  <Interface name="HTMLLinkElement" partial="partial" id="::HTMLLinkElement">
    <webidl>partial interface HTMLLinkElement {
           attribute DOMString charset;
           attribute DOMString rev;
           attribute DOMString target;
};</webidl>
    <Attribute name="charset" id="::HTMLLinkElement::charset">
      <webidl>           attribute DOMString charset;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="rev" id="::HTMLLinkElement::rev">
      <webidl>           attribute DOMString rev;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="target" id="::HTMLLinkElement::target">
      <webidl>           attribute DOMString target;</webidl>
      <Type type="DOMString"/>
    </Attribute>
  </Interface>
  <Interface name="HTMLMenuElement" partial="partial" id="::HTMLMenuElement">
    <webidl>partial interface HTMLMenuElement {
           attribute boolean compact;
};</webidl>
    <Attribute name="compact" id="::HTMLMenuElement::compact">
      <webidl>           attribute boolean compact;</webidl>
      <Type type="boolean"/>
    </Attribute>
  </Interface>
  <Interface name="HTMLMetaElement" partial="partial" id="::HTMLMetaElement">
    <webidl>partial interface HTMLMetaElement {
           attribute DOMString scheme;
};</webidl>
    <Attribute name="scheme" id="::HTMLMetaElement::scheme">
      <webidl>           attribute DOMString scheme;</webidl>
      <Type type="DOMString"/>
    </Attribute>
  </Interface>
  <Interface name="HTMLObjectElement" partial="partial" id="::HTMLObjectElement">
    <webidl>partial interface HTMLObjectElement {
           attribute DOMString align;
           attribute DOMString archive;
           attribute DOMString code;
           attribute boolean declare;
           attribute unsigned long hspace;
           attribute DOMString standby;
           attribute unsigned long vspace;
           attribute DOMString codeBase;
           attribute DOMString codeType;

  [TreatNullAs=EmptyString] attribute DOMString border;
};</webidl>
    <Attribute name="align" id="::HTMLObjectElement::align">
      <webidl>           attribute DOMString align;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="archive" id="::HTMLObjectElement::archive">
      <webidl>           attribute DOMString archive;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="code" id="::HTMLObjectElement::code">
      <webidl>           attribute DOMString code;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="declare" id="::HTMLObjectElement::declare">
      <webidl>           attribute boolean declare;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute name="hspace" id="::HTMLObjectElement::hspace">
      <webidl>           attribute unsigned long hspace;</webidl>
      <Type type="unsigned long"/>
    </Attribute>
    <Attribute name="standby" id="::HTMLObjectElement::standby">
      <webidl>           attribute DOMString standby;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="vspace" id="::HTMLObjectElement::vspace">
      <webidl>           attribute unsigned long vspace;</webidl>
      <Type type="unsigned long"/>
    </Attribute>
    <Attribute name="codeBase" id="::HTMLObjectElement::codeBase">
      <webidl>           attribute DOMString codeBase;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="codeType" id="::HTMLObjectElement::codeType">
      <webidl>           attribute DOMString codeType;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="border" id="::HTMLObjectElement::border">
      <webidl>  [TreatNullAs=EmptyString] attribute DOMString border;</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="TreatNullAs" value="EmptyString">
          <webidl>TreatNullAs</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type type="DOMString"/>
    </Attribute>
  </Interface>
  <Interface name="HTMLOListElement" partial="partial" id="::HTMLOListElement">
    <webidl>partial interface HTMLOListElement {
           attribute boolean compact;
};</webidl>
    <Attribute name="compact" id="::HTMLOListElement::compact">
      <webidl>           attribute boolean compact;</webidl>
      <Type type="boolean"/>
    </Attribute>
  </Interface>
  <Interface name="HTMLParagraphElement" partial="partial" id="::HTMLParagraphElement">
    <webidl>partial interface HTMLParagraphElement {
           attribute DOMString align;
};</webidl>
    <Attribute name="align" id="::HTMLParagraphElement::align">
      <webidl>           attribute DOMString align;</webidl>
      <Type type="DOMString"/>
    </Attribute>
  </Interface>
  <Interface name="HTMLParamElement" partial="partial" id="::HTMLParamElement">
    <webidl>partial interface HTMLParamElement {
           attribute DOMString type;
           attribute DOMString valueType;
};</webidl>
    <Attribute name="type" id="::HTMLParamElement::type">
      <webidl>           attribute DOMString type;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="valueType" id="::HTMLParamElement::valueType">
      <webidl>           attribute DOMString valueType;</webidl>
      <Type type="DOMString"/>
    </Attribute>
  </Interface>
  <Interface name="HTMLPreElement" partial="partial" id="::HTMLPreElement">
    <webidl>partial interface HTMLPreElement {
           attribute long width;
};</webidl>
    <Attribute name="width" id="::HTMLPreElement::width">
      <webidl>           attribute long width;</webidl>
      <Type type="long"/>
    </Attribute>
  </Interface>
  <Interface name="HTMLScriptElement" partial="partial" id="::HTMLScriptElement">
    <webidl>partial interface HTMLScriptElement {
           attribute DOMString event;
           attribute DOMString htmlFor;
};</webidl>
    <Attribute name="event" id="::HTMLScriptElement::event">
      <webidl>           attribute DOMString event;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="htmlFor" id="::HTMLScriptElement::htmlFor">
      <webidl>           attribute DOMString htmlFor;</webidl>
      <Type type="DOMString"/>
    </Attribute>
  </Interface>
  <Interface name="HTMLTableElement" partial="partial" id="::HTMLTableElement">
    <webidl>partial interface HTMLTableElement {
           attribute DOMString align;
           attribute DOMString frame;
           attribute DOMString rules;
           attribute DOMString summary;
           attribute DOMString width;

  [TreatNullAs=EmptyString] attribute DOMString bgColor;
  [TreatNullAs=EmptyString] attribute DOMString cellPadding;
  [TreatNullAs=EmptyString] attribute DOMString cellSpacing;
};</webidl>
    <Attribute name="align" id="::HTMLTableElement::align">
      <webidl>           attribute DOMString align;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="frame" id="::HTMLTableElement::frame">
      <webidl>           attribute DOMString frame;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="rules" id="::HTMLTableElement::rules">
      <webidl>           attribute DOMString rules;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="summary" id="::HTMLTableElement::summary">
      <webidl>           attribute DOMString summary;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="width" id="::HTMLTableElement::width">
      <webidl>           attribute DOMString width;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="bgColor" id="::HTMLTableElement::bgColor">
      <webidl>  [TreatNullAs=EmptyString] attribute DOMString bgColor;</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="TreatNullAs" value="EmptyString">
          <webidl>TreatNullAs</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="cellPadding" id="::HTMLTableElement::cellPadding">
      <webidl>  [TreatNullAs=EmptyString] attribute DOMString cellPadding;</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="TreatNullAs" value="EmptyString">
          <webidl>TreatNullAs</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="cellSpacing" id="::HTMLTableElement::cellSpacing">
      <webidl>  [TreatNullAs=EmptyString] attribute DOMString cellSpacing;</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="TreatNullAs" value="EmptyString">
          <webidl>TreatNullAs</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type type="DOMString"/>
    </Attribute>
  </Interface>
  <Interface name="HTMLTableSectionElement" partial="partial" id="::HTMLTableSectionElement">
    <webidl>partial interface HTMLTableSectionElement {
           attribute DOMString align;
           attribute DOMString ch;
           attribute DOMString chOff;
           attribute DOMString vAlign;
};</webidl>
    <Attribute name="align" id="::HTMLTableSectionElement::align">
      <webidl>           attribute DOMString align;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="ch" id="::HTMLTableSectionElement::ch">
      <webidl>           attribute DOMString ch;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="chOff" id="::HTMLTableSectionElement::chOff">
      <webidl>           attribute DOMString chOff;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="vAlign" id="::HTMLTableSectionElement::vAlign">
      <webidl>           attribute DOMString vAlign;</webidl>
      <Type type="DOMString"/>
    </Attribute>
  </Interface>
  <Interface name="HTMLTableCellElement" partial="partial" id="::HTMLTableCellElement">
    <webidl>partial interface HTMLTableCellElement {
           attribute DOMString align;
           attribute DOMString axis;
           attribute DOMString height;
           attribute DOMString width;

           attribute DOMString ch;
           attribute DOMString chOff;
           attribute boolean noWrap;
           attribute DOMString vAlign;

  [TreatNullAs=EmptyString] attribute DOMString bgColor;
};</webidl>
    <Attribute name="align" id="::HTMLTableCellElement::align">
      <webidl>           attribute DOMString align;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="axis" id="::HTMLTableCellElement::axis">
      <webidl>           attribute DOMString axis;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="height" id="::HTMLTableCellElement::height">
      <webidl>           attribute DOMString height;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="width" id="::HTMLTableCellElement::width">
      <webidl>           attribute DOMString width;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="ch" id="::HTMLTableCellElement::ch">
      <webidl>           attribute DOMString ch;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="chOff" id="::HTMLTableCellElement::chOff">
      <webidl>           attribute DOMString chOff;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="noWrap" id="::HTMLTableCellElement::noWrap">
      <webidl>           attribute boolean noWrap;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute name="vAlign" id="::HTMLTableCellElement::vAlign">
      <webidl>           attribute DOMString vAlign;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="bgColor" id="::HTMLTableCellElement::bgColor">
      <webidl>  [TreatNullAs=EmptyString] attribute DOMString bgColor;</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="TreatNullAs" value="EmptyString">
          <webidl>TreatNullAs</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type type="DOMString"/>
    </Attribute>
  </Interface>
  <Interface name="HTMLTableDataCellElement" partial="partial" id="::HTMLTableDataCellElement">
    <webidl>partial interface HTMLTableDataCellElement {
           attribute DOMString abbr;
};</webidl>
    <Attribute name="abbr" id="::HTMLTableDataCellElement::abbr">
      <webidl>           attribute DOMString abbr;</webidl>
      <Type type="DOMString"/>
    </Attribute>
  </Interface>
  <Interface name="HTMLTableRowElement" partial="partial" id="::HTMLTableRowElement">
    <webidl>partial interface HTMLTableRowElement {
           attribute DOMString align;
           attribute DOMString ch;
           attribute DOMString chOff;
           attribute DOMString vAlign;

  [TreatNullAs=EmptyString] attribute DOMString bgColor;
};</webidl>
    <Attribute name="align" id="::HTMLTableRowElement::align">
      <webidl>           attribute DOMString align;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="ch" id="::HTMLTableRowElement::ch">
      <webidl>           attribute DOMString ch;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="chOff" id="::HTMLTableRowElement::chOff">
      <webidl>           attribute DOMString chOff;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="vAlign" id="::HTMLTableRowElement::vAlign">
      <webidl>           attribute DOMString vAlign;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="bgColor" id="::HTMLTableRowElement::bgColor">
      <webidl>  [TreatNullAs=EmptyString] attribute DOMString bgColor;</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="TreatNullAs" value="EmptyString">
          <webidl>TreatNullAs</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type type="DOMString"/>
    </Attribute>
  </Interface>
  <Interface name="HTMLUListElement" partial="partial" id="::HTMLUListElement">
    <webidl>partial interface HTMLUListElement {
           attribute boolean compact;
           attribute DOMString type;
};</webidl>
    <Attribute name="compact" id="::HTMLUListElement::compact">
      <webidl>           attribute boolean compact;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute name="type" id="::HTMLUListElement::type">
      <webidl>           attribute DOMString type;</webidl>
      <Type type="DOMString"/>
    </Attribute>
  </Interface>
  <Interface name="Document" partial="partial" id="::Document">
    <webidl>partial interface Document {
  [TreatNullAs=EmptyString] attribute DOMString fgColor;
  [TreatNullAs=EmptyString] attribute DOMString linkColor;
  [TreatNullAs=EmptyString] attribute DOMString vlinkColor;
  [TreatNullAs=EmptyString] attribute DOMString alinkColor;
  [TreatNullAs=EmptyString] attribute DOMString bgColor;

  readonly attribute <ref>HTMLCollection</ref> anchors;
  readonly attribute <ref>HTMLCollection</ref> applets;

  void clear();

  readonly attribute <ref>HTMLAllCollection</ref> all;
};</webidl>
    <Attribute name="fgColor" id="::Document::fgColor">
      <webidl>  [TreatNullAs=EmptyString] attribute DOMString fgColor;</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="TreatNullAs" value="EmptyString">
          <webidl>TreatNullAs</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="linkColor" id="::Document::linkColor">
      <webidl>  [TreatNullAs=EmptyString] attribute DOMString linkColor;</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="TreatNullAs" value="EmptyString">
          <webidl>TreatNullAs</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="vlinkColor" id="::Document::vlinkColor">
      <webidl>  [TreatNullAs=EmptyString] attribute DOMString vlinkColor;</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="TreatNullAs" value="EmptyString">
          <webidl>TreatNullAs</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="alinkColor" id="::Document::alinkColor">
      <webidl>  [TreatNullAs=EmptyString] attribute DOMString alinkColor;</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="TreatNullAs" value="EmptyString">
          <webidl>TreatNullAs</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute name="bgColor" id="::Document::bgColor">
      <webidl>  [TreatNullAs=EmptyString] attribute DOMString bgColor;</webidl>
      <ExtendedAttributeList>
        <ExtendedAttribute name="TreatNullAs" value="EmptyString">
          <webidl>TreatNullAs</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute readonly="readonly" name="anchors" id="::Document::anchors">
      <webidl>  readonly attribute <ref>HTMLCollection</ref> anchors;</webidl>
      <Type name="HTMLCollection"/>
    </Attribute>
    <Attribute readonly="readonly" name="applets" id="::Document::applets">
      <webidl>  readonly attribute <ref>HTMLCollection</ref> applets;</webidl>
      <Type name="HTMLCollection"/>
    </Attribute>
    <Operation name="clear" id="::Document::clear">
      <webidl>  void clear();</webidl>
      <Type type="void"/>
      <ArgumentList/>
    </Operation>
    <Attribute readonly="readonly" name="all" id="::Document::all">
      <webidl>  readonly attribute <ref>HTMLAllCollection</ref> all;</webidl>
      <Type name="HTMLAllCollection"/>
    </Attribute>
  </Interface>
</Definitions>
</Module>
